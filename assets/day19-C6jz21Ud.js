import{G as X,k as E,T as R,E as G}from"./index-geDchL-P.js";import{FactoredNetwork as z,generateAllPairs as Y,splitData as B,calcAccuracy as F}from"./day19.grokking-BLQhquhM.js";import"./day19.utils-DeEDoNyc.js";class H{constructor(t,e,s=4){this.x=t,this.y=e,this.targetX=t,this.targetY=e,this.baseSize=s,this.activation=0,this.isActive=!1,this.isSelected=!1,this.isTarget=!1,this.isError=!1,this.isCorrect=!1,this.spawnScale=1}render(t,e){const{neuronIdle:s,neuronActive:r,neuronBright:o}=e;if(this.isActive){const i=this.baseSize,a=i*1.1,n=.2;t.fillStyle=`rgba(0, 255, 0, ${n})`,t.beginPath(),t.arc(this.x,this.y,a,0,Math.PI*2),t.fill();let h=r;(this.isSelected||this.isTarget)&&(h=o),t.fillStyle=h,t.globalAlpha=1,t.beginPath(),t.arc(this.x,this.y,i,0,Math.PI*2),t.fill(),t.globalAlpha=1}else t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,this.baseSize*.5,0,Math.PI*2),t.fill()}renderGrid(t,e,s=1,r=0,o=1,i=0,a=0,n=0,h=0,c=1){var D;if(this.spawnScale<=.01)return;const{neuronActive:d,neuronBright:l}=e,u=this.spawnScale,S=c,m=((D=p.neuron)==null?void 0:D.baseSize)*o*u*S,f=2*o*u,y=(a*.1+n*.15+h*.1)%1,T=Math.floor((.5+.5*Math.sin(y*6.28))*255),g=Math.floor((.5+.5*Math.sin(y*6.28+2.09))*255),k=Math.floor((.5+.5*Math.sin(y*6.28+4.18))*255);if(!(c>.4)){const O=Math.max(2,f);i>.5?t.fillStyle=`rgb(${Math.floor(T*.4)}, ${Math.floor(g*.4)}, ${Math.floor(k*.4)})`:t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,O,0,Math.PI*2),t.fill();return}const C=m;let M,b,v;i>.5?(M=T,b=g,v=k):i>.01?(M=Math.floor(T*i),b=Math.floor(255*(1-i)+g*i),v=Math.floor(255*(1-i)+k*i)):(M=0,b=255,v=255),t.fillStyle=`rgba(${M}, ${b}, ${v}, 0.15)`,t.beginPath(),t.arc(this.x,this.y,C*2.2,0,Math.PI*2),t.fill(),t.fillStyle=`rgba(${M}, ${b}, ${v}, 0.25)`,t.beginPath(),t.arc(this.x,this.y,C*1.5,0,Math.PI*2),t.fill(),t.fillStyle=`rgb(${M}, ${b}, ${v})`,t.beginPath(),t.arc(this.x,this.y,C,0,Math.PI*2),t.fill(),t.fillStyle="#fff",t.beginPath(),t.arc(this.x,this.y,C*.55,0,Math.PI*2),t.fill()}renderOutput(t,e,s=0,r=1,o=0){var f;if(this.spawnScale<=.01)return;const i=this.spawnScale,a=p.neuron;this.currentScale===void 0&&(this.currentScale=a.minScale);const n=s>.5?a.maxScale:a.minScale,h=n>this.currentScale?a.growSpeed:a.shrinkSpeed;this.currentScale+=(n-this.currentScale)*Math.min(1,h*.016);const c=this.currentScale,l=((f=p.neuron)==null?void 0:f.baseSize)*r*i*c,u=3*r*i,S=this.isError&&o<.5;if(c<.4){const y=this.isTarget||this.isSelected?.4:.2;t.fillStyle=`rgba(255, 255, 255, ${y})`,t.beginPath(),t.arc(this.x,this.y,Math.max(2,u),0,Math.PI*2),t.fill();return}let w,m;S?(w="#f44",m="rgba(255, 50, 50, 0.3)"):this.isCorrect?(w="#0f0",m="rgba(0, 255, 0, 0.3)"):(w="#fff",m="rgba(255, 255, 255, 0.2)"),t.fillStyle=m,t.beginPath(),t.arc(this.x,this.y,l*1.6,0,Math.PI*2),t.fill(),t.fillStyle=w,t.beginPath(),t.arc(this.x,this.y,l,0,Math.PI*2),t.fill(),t.fillStyle="rgba(100, 100, 100, 0.5)",t.beginPath(),t.arc(this.x,this.y,l*.4,0,Math.PI*2),t.fill()}}class _{constructor(t,e,s=16,r=16){this.hiddenSize=t,this.nTokens=e,this.gridRows=s,this.gridCols=r,this.gridSize=s*r,this._buildHiddenMapping(),this._buildOutputMapping()}_buildHiddenMapping(){const s=Math.floor((this.gridRows-16)/2),r=Math.floor((this.gridCols-8*2)/2);this.hiddenToGrid=[],this.gridToHidden=new Int16Array(this.gridSize).fill(-1);for(let o=0;o<this.hiddenSize;o++){const i=Math.floor(o/8),a=o%8,n=s+i*2,h=r+a*2,c=[];for(let d=0;d<2;d++)for(let l=0;l<2;l++){const u=n+d,S=h+l;if(u>=0&&u<this.gridRows&&S>=0&&S<this.gridCols){const w=u*this.gridCols+S;c.push(w),this.gridToHidden[w]=o}}this.hiddenToGrid.push(c)}}_buildOutputMapping(){this.tokenToRow=new Int16Array(this.nTokens),this.rowToTokens=[];for(let e=0;e<16;e++)this.rowToTokens.push([]);for(let e=0;e<this.nTokens;e++){const s=Math.floor(e*16/this.nTokens);this.tokenToRow[e]=s,this.rowToTokens[s].push(e)}}getGridCells(t){return this.hiddenToGrid[t]||[]}getOutputRow(t){return this.tokenToRow[t]}getHiddenNeuron(t){return this.gridToHidden[t]}isMapped(t){return this.gridToHidden[t]>=0}getNeuronCenter(t){const s=Math.floor((this.gridRows-16)/2),r=Math.floor((this.gridCols-8*2)/2),o=Math.floor(t/8),i=t%8;return{row:s+o*2+.5,col:r+i*2+.5}}}const p={background:"#000",network:{nTokens:67,embedSize:500,hiddenSize:64,learningRate:.01,weightDecay:1,beta1:.9,beta2:.98,symmetric:!0,trainFraction:.4},training:{batchSize:64,epochsPerFrame:16,showGrokking:!0,useWorker:!0},grid:{rows:16,cols:16,neuronRows:8,neuronCols:8,baseSpacing:38,referenceSize:800},testAnimation:{testDuration:.8,inputToHidden:.2,hiddenToOutput:.2,holdAtPeak:.15,holdResult:.25,maxActiveNeurons:8},synapse:{trailLength:.25,headSize:5,trailWidth:2,glowSize:12,coreAlpha:.3},neuron:{minScale:.15,maxScale:1.2,growSpeed:25,shrinkSpeed:8,baseSize:8},colors:{neuronIdle:"#0a0",neuronActive:"#0f0",neuronBright:"#fff",text:"#0f0",testCase:"rgba(0, 255, 0, 0.3)"}};class L extends X{constructor(t){super(t),this.backgroundColor=p.background}init(){super.init(),console.log("[Day19] Creating FactoredNetwork...");const t=performance.now();try{this.network=new z(p.network),console.log(`[Day19] Network created in ${(performance.now()-t).toFixed(1)}ms`)}catch(n){console.error("[Day19] Failed to create network:",n);return}const{nTokens:e,symmetric:s,trainFraction:r}=p.network,o=Y(e,s),i=B(o,r);this.trainData=i.train,this.testData=i.test,console.log(`Generated ${o.length} pairs (symmetric=${s}): ${this.trainData.length} train, ${this.testData.length} test`),this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.trainLoss=0,this.testLoss=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.neuronMapper=new _(p.network.hiddenSize,p.network.nTokens,p.grid.rows,p.grid.cols),this.currentTestCase=null,this.testCaseIndex=0,this.testTime=0,this.testRunning=!1,this.currentHiddenActivations=null,this.currentOutputActivations=null,this.currentPrediction=null,this.activeHiddenNeurons=[],this.activeGridCells=[],this.nextTestCase=null,this.nextHiddenActivations=null,this.nextActiveNeurons=[],this.nextPrediction=null;const a=Math.min(this.width,this.height);if(this.scale=a/p.grid.referenceSize,this.gridSpacing=p.grid.baseSpacing*this.scale,this.synapseAnimationTime=0,this.outputFlashes=new Map,this.gridFlashes=new Map,this.activatedGridNeurons=new Set,this.activatedOutputNeurons=new Set,this.inputSynapseTargets=[],this.outputSynapseTargets=[],this.grokMode=0,this.grokThreshold=.6,this.outputNeurons=[],this.outputNeuronsInitialized=!1,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainData.length>0){const n=this.trainData[0];this.network.forward(n.a,n.b)}this.gridOffsetX=0,this.gridOffsetY=0,this.useWorker=p.training.useWorker,this.workerReady=!1,this.workerTraining=!1,this.useWorker&&this.initWorker(),this.inputDots=[],this.outputDots=[],this.fsm=new E({initial:"intro",context:this,states:{intro:{enter:()=>this.startIntroAnimation(),update:n=>this.updateIntro(n)},training:{enter:()=>this.startTraining(),update:n=>this.updateTraining(n)}}}),this.trainingOpacity=0,this.synapseOpacity=0,this.canvas.addEventListener("click",()=>{this.restart()}),this.grokModeOverride=!1,this.originalTestData=null,window.addEventListener("keydown",n=>{(n.key==="g"||n.key==="G")&&(this.grokModeOverride=!this.grokModeOverride,this.grokModeOverride?(this.originalTestData=this.testData,this.testData=[...this.trainData],this.grokMode=1,console.log(`[DEBUG] Grok mode ON - test set = train set (${this.testData.length} examples)`),this.worker&&(this.worker.postMessage({type:"grokMode",enabled:!0}),this.worker.postMessage({type:"syncWeights"}))):(this.originalTestData&&(this.testData=this.originalTestData,this.originalTestData=null),this.grokMode=0,console.log(`[DEBUG] Grok mode OFF - original test set restored (${this.testData.length} examples)`),this.worker&&this.worker.postMessage({type:"grokMode",enabled:!1})))})}initWorker(){try{this.worker=new Worker(new URL("/assets/day19.worker-CiCYPVIj.js",import.meta.url),{type:"module"}),this.worker.onmessage=t=>{const{type:e}=t.data;switch(e){case"state":this.epoch=t.data.epoch,this.trainAccuracy=t.data.trainAccuracy,this.testAccuracy=t.data.testAccuracy,this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.workerTraining=!1,this.workerReady=!0;break;case"forward":this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.cachedOutput=new Float32Array(t.data.outputActivations),this.cachedPrediction=t.data.prediction;break;case"syncWeights":if(this.network&&t.data.weights){const s=t.data.weights;this.network.embed=s.embed,this.network.Whidden=s.Whidden,this.network.Wout=s.Wout,console.log("[Main] Synced weights from worker"),this._weightsSynced=!0}break}},this.worker.onerror=t=>{console.error("Worker error:",t),this.useWorker=!1,this.workerReady=!1},this.worker.postMessage({type:"init",data:{config:p.network}}),console.log("Web Worker initialized for training")}catch(t){console.warn("Failed to create Web Worker, falling back to main thread:",t),this.useWorker=!1}}startIntroAnimation(){const t=this.width/2,e=this.height/2,{rows:s,cols:r}=p.grid;this.pendingTweens=0,this.gridOffsetX=this.width/2-r*this.gridSpacing/2,this.gridOffsetY=this.height/2-s*this.gridSpacing/2,this.gridNeurons=[];for(let i=0;i<s;i++)for(let a=0;a<r;a++){const n=this.gridOffsetX+a*this.gridSpacing,h=this.gridOffsetY+i*this.gridSpacing,c=new H(t,e,4*this.scale);c.targetX=n,c.targetY=h,c.spawnScale=0,this.gridNeurons.push(c);const l=Math.sqrt(Math.pow(a-r/2,2)+Math.pow(i-s/2,2))*.04;this.pendingTweens++,R.to(c,{x:n,y:h,spawnScale:1},.4,G.easeOutBack,{delay:.1+l,onComplete:()=>this.onTweenComplete()})}const o=r*this.gridSpacing;t-o/2-100*this.scale,t+o/2+100*this.scale,this.inputDots=[];for(let i=0;i<14;i++){const a={x:t,y:e,spawnScale:0};this.inputDots.push(a),this.pendingTweens++,R.to(a,{spawnScale:1},.3,G.easeOutBack,{delay:.05+i*.01,onComplete:()=>this.onTweenComplete()})}this.outputDots=[];for(let i=0;i<7;i++){const a={x:t,y:e,spawnScale:0};this.outputDots.push(a),this.pendingTweens++,R.to(a,{spawnScale:1},.3,G.easeOutBack,{delay:.1+i*.01,onComplete:()=>this.onTweenComplete()})}}onTweenComplete(){this.pendingTweens--,this.pendingTweens<=0&&this.fsm.is("intro")&&this.fsm.setState("training")}updateIntro(t){}startTraining(){this.trainingOpacity=0,this.synapseOpacity=0,R.to(this,{trainingOpacity:1},.8,G.easeOutQuad),R.to(this,{synapseOpacity:1},1.5,G.easeInOutQuad,{delay:.5})}updateTraining(t){R.updateAll(t),this.trainNetwork()}restart(){this.network=new z(p.network);const{nTokens:t,symmetric:e,trainFraction:s}=p.network,r=Y(t,e),o=B(r,s);this.trainData=o.train,this.testData=o.test,this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.grokMode=0,this.grokModeOverride=!1,this.outputNeuronsInitialized=!1,this.outputNeuronsKeys=null,this.gridNeurons=null,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainingOpacity=0,this.synapseOpacity=0,this.testTime=0,this.testRunning=!1,this.testCaseIndex=0,this.currentTestCase=null,this.currentHiddenActivations=null,this.currentOutputActivations=null,this.currentPrediction=null,this.activeHiddenNeurons=[],this.activeGridCells=[],this.predictionRow=-1,this.targetRow=-1,this.nextTestCase=null,this.nextHiddenActivations=null,this.nextActiveNeurons=[],this.nextPrediction=null,this.useWorker&&this.worker&&(this.workerReady=!1,this.workerTraining=!1,this.worker.postMessage({type:"reset",data:{config:p.network}})),R.killAll(),this.fsm.setState("intro")}update(t){super.update(t);const e=Math.min(this.width,this.height);this.scale=e/p.grid.referenceSize,this.gridSpacing=p.grid.baseSpacing*this.scale,this.gridOffsetX=this.width/2-p.grid.cols*this.gridSpacing/2,this.gridOffsetY=this.height/2-p.grid.rows*this.gridSpacing/2,this.fsm.update(t),this.animTime+=t,this.updateTestCaseAnimation(t)}updateTestCaseAnimation(t){if(!this.fsm.is("training"))return;const e=p.testAnimation;if(!this.testRunning){this.startNewTestCase();return}this.testTime+=t,this.testTime>=e.testDuration&&this.startNewTestCase()}preloadNextTest(){if(this.testData.length===0)return;const t=(this.testCaseIndex+1)%this.testData.length;this.nextTestCase=this.testData[t];const{probs:e}=this.network.forward(this.nextTestCase.a,this.nextTestCase.b);this.nextHiddenActivations=new Float32Array(this.network._actualHiddenActivations);let s=0,r=e[0];for(let n=1;n<e.length;n++)e[n]>r&&(r=e[n],s=n);this.nextPrediction=s;const o=p.testAnimation.maxActiveNeurons,i=this.nextHiddenActivations,a=[];for(let n=0;n<i.length;n++)i[n]>.01&&a.push({idx:n,val:i[n]});a.sort((n,h)=>h.val-n.val),this.nextActiveNeurons=a.slice(0,o).map(n=>n.idx)}startNewTestCase(){if(this.testData.length!==0){if(this.nextTestCase)this.testCaseIndex=(this.testCaseIndex+1)%this.testData.length,this.currentTestCase=this.nextTestCase,this.currentHiddenActivations=this.nextHiddenActivations,this.currentPrediction=this.nextPrediction,this.activeHiddenNeurons=this.nextActiveNeurons,this.cachedPrediction=this.nextPrediction;else{this.testCaseIndex=0,this.currentTestCase=this.testData[0];const{probs:t}=this.network.forward(this.currentTestCase.a,this.currentTestCase.b);this.currentHiddenActivations=new Float32Array(this.network._actualHiddenActivations),this.cachedOutput=t;let e=0,s=t[0];for(let i=1;i<t.length;i++)t[i]>s&&(s=t[i],e=i);this.currentPrediction=e,this.cachedPrediction=e;const r=p.testAnimation.maxActiveNeurons,o=[];for(let i=0;i<this.currentHiddenActivations.length;i++)this.currentHiddenActivations[i]>.01&&o.push({idx:i,val:this.currentHiddenActivations[i]});o.sort((i,a)=>a.val-i.val),this.activeHiddenNeurons=o.slice(0,r).map(i=>i.idx)}this.activeGridCells=[];for(const t of this.activeHiddenNeurons){const e=this.neuronMapper.getGridCells(t);if(e.length>0){const s=e[Math.floor(Math.random()*e.length)];this.activeGridCells.push(s)}}this.predictionRow=this.currentPrediction!==null?this.neuronMapper.getOutputRow(this.currentPrediction):-1,this.targetRow=this.currentTestCase?this.neuronMapper.getOutputRow(this.currentTestCase.target):-1,this.testTime=0,this.testRunning=!0,this.outputNeuronsInitialized=!1,this.useWorker&&this.workerReady&&this.worker.postMessage({type:"forward",data:{a:this.currentTestCase.a,b:this.currentTestCase.b}}),this.preloadNextTest()}}trainNetwork(){const{epochsPerFrame:t,batchSize:e}=p.training,{nTokens:s}=p.network;if(this.useWorker&&this.workerReady&&!this.workerTraining){if(this.workerTraining=!0,this.worker.postMessage({type:"train",data:{epochsPerFrame:t,batchSize:e}}),this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokModeOverride){const r=this.trainAccuracy>=.95,i=r&&this.testAccuracy>=this.grokThreshold?1:0,a=this.grokMode>.5;this.grokMode+=(i-this.grokMode)*.05,!a&&this.grokMode>.5&&(this.currentTestCase=null,this.cachedOutput=null,this.cachedPrediction=null,this.useWorker&&this.workerReady&&!this._weightsSynced&&this.worker.postMessage({type:"syncWeights"})),r&&this.useWorker&&this.workerReady&&(!this._lastWeightSync||Date.now()-this._lastWeightSync>5e3)&&(this._lastWeightSync=Date.now(),this.worker.postMessage({type:"syncWeights"}))}return}if(!this.useWorker){this.network.resetGradients();for(let r=0;r<t;r++){for(let o=0;o<this.trainData.length;o++){const i=this.trainData[o],{cache:a}=this.network.forward(i.a,i.b);this.network.backward(i.target,a)}this.network.applyAdamW(this.trainData.length),this.epoch++}if(this.epoch%20===0){const r=this.trainData.slice(0,Math.min(100,this.trainData.length)),o=this.testData.slice(0,Math.min(100,this.testData.length));this.trainAccuracy=F(this.network,r),this.testAccuracy=F(this.network,o)}if(this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokkingDetected&&this.epoch>100){const r=this.accuracyHistory.slice(-50);if(r.length>=50){const o=r[0].test,i=r[r.length-1].test;this.trainAccuracy>.8&&i-o>.3&&(this.grokkingDetected=!0,this.grokkingEpoch=this.epoch)}}}}render(){const t=this.ctx,e=this.width,s=this.height;t.fillStyle="rgba(0, 0, 0, 0.2)",t.fillRect(0,0,e,s),this.updateOutputNeuronState(),this.drawSynapses(t),this.drawNeuronGrid(t),this.drawInputOutputNeurons(t),this.drawInputOutput(t),this.drawStats(t)}drawNeuronGrid(t){const{rows:e,cols:s}=p.grid,r=this.gridSpacing,o=this.fsm.is("intro"),i=this._lastSpacing&&Math.abs(this._lastSpacing-r)>1;if(this._lastSpacing=r,!this.gridNeurons||this.gridNeurons.length!==e*s||i&&!o){this.gridNeurons=[];for(let f=0;f<e;f++)for(let y=0;y<s;y++){const T=this.gridOffsetX+y*r,g=this.gridOffsetY+f*r;this.gridNeurons.push(new H(T,g,4*this.scale))}}const a=new Map;if(this.activeGridCells)for(let f=0;f<this.activeGridCells.length;f++)a.set(this.activeGridCells[f],f);const n=p.testAnimation,h=p.neuron,c=this.testTime||0,d=n.inputToHidden,l=d+n.hiddenToOutput,u=n.holdAtPeak,S=l+u,w=Math.min(1,c/d),m=c>S?(c-S)/n.holdResult:0;for(let f=0;f<e;f++)for(let y=0;y<s;y++){const T=f*s+y,g=this.gridNeurons[T];g.x=this.gridOffsetX+y*r,g.y=this.gridOffsetY+f*r;const k=this.neuronMapper.isMapped(T),A=a.get(T),C=A!==void 0;g.currentScale===void 0&&(g.currentScale=h.minScale);let M=h.minScale;if(o)M=h.minScale;else if(!k)M=h.minScale;else if(C&&this.testRunning){const v=A/this.activeGridCells.length*.3;if(Math.max(0,(w-v)/(1-v))>=.98)if(m>0){const O=(this.activeGridCells.length-1-A)/this.activeGridCells.length*.5,P=Math.max(0,(m-O)/(1-O));M=h.maxScale-(h.maxScale-h.minScale)*Math.min(1,P)}else M=h.maxScale;else M=h.minScale}else M=h.minScale;const b=M>g.currentScale?h.growSpeed:h.shrinkSpeed;g.currentScale+=(M-g.currentScale)*Math.min(1,b*.016),g.activation=(g.currentScale-h.minScale)/(h.maxScale-h.minScale),g.isActive=g.currentScale>h.minScale+.1,g.renderGrid(t,p.colors,1,g.activation,this.scale,this.grokMode,f,y,this.animTime,g.currentScale)}}updateOutputNeuronState(){if(!this.currentTestCase||!this.fsm.is("training"))return;const t=this.width/2,e=p.grid.cols*this.gridSpacing,s=t+e/2+50*this.scale,r=this.cachedOutput||this.currentOutputActivations,o=this.cachedPrediction??this.currentPrediction,i=16,a=this.gridSpacing,n=this.gridOffsetY;if(!this.outputNeurons||this.outputNeurons.length!==i){this.outputNeurons=[];for(let l=0;l<i;l++){const u=n+l*a;this.outputNeurons.push(new H(s,u,4*this.scale))}}const h=o!=null?this.neuronMapper.getOutputRow(o):-1,c=this.currentTestCase.target!==void 0?this.neuronMapper.getOutputRow(this.currentTestCase.target):-1,d=new Float32Array(i);if(r)for(let l=0;l<r.length;l++){const u=this.neuronMapper.getOutputRow(l);r[l]>d[u]&&(d[u]=r[l])}for(let l=0;l<i;l++){const u=this.outputNeurons[l];u.x=s,u.y=n+l*a,u.isTarget=l===c,u.isSelected=l===h,u.activation=d[l]}}drawInputOutputNeurons(t){if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0||!this.outputNeurons||this.outputNeurons.length===0)return;t.save(),t.globalAlpha=this.trainingOpacity;const e=16,s=p.testAnimation,r=this.testTime||0,o=s.inputToHidden,i=r>o?Math.min(1,(r-o)/s.hiddenToOutput):0,a=this.cachedPrediction??this.currentPrediction,n=a!=null?this.neuronMapper.getOutputRow(a):-1,h=this.targetRow;for(let c=0;c<e;c++){const d=this.outputNeurons[c];let l=0;this.testRunning&&i>0&&(c===n||c===h)&&(l=Math.max(0,(i-.3)/.7)>=.98?1:0),d.activation=l;const u=n===h,S=c===n,w=c===h;d.isError=!1,d.isCorrect=!1,l>.1&&(u&&S?d.isCorrect=!0:u||(S?d.isError=!0:w&&(d.isCorrect=!0))),d.renderOutput(t,p.colors,l,this.scale,this.grokMode)}t.restore()}drawTronSynapse(t,e,s,r,o,i,a="#0ff",n=!0){if(i<=0)return;const h=p.synapse,c=this.scale,d=1-Math.pow(1-Math.min(1,i),2),l=e+(r-e)*d,u=s+(o-s)*d,S=Math.max(0,d-h.trailLength),w=e+(r-e)*S,m=s+(o-s)*S,f=a==="#0ff",y=0,T=255,g=f?255:0;if(i<1){const k=t.createLinearGradient(w,m,l,u);k.addColorStop(0,`rgba(${y}, ${T}, ${g}, 0)`),k.addColorStop(.5,`rgba(${y}, ${T}, ${g}, 0.15)`),k.addColorStop(1,`rgba(${y}, ${T}, ${g}, 0.4)`),t.strokeStyle=k,t.lineWidth=h.glowSize*c*(n?1:.6),t.lineCap="round",t.beginPath(),t.moveTo(w,m),t.lineTo(l,u),t.stroke()}if(i<1){const k=t.createLinearGradient(w,m,l,u);k.addColorStop(0,`rgba(${y}, ${T}, ${g}, 0)`),k.addColorStop(.3,`rgba(${y}, ${T}, ${g}, 0.6)`),k.addColorStop(1,`rgba(${y}, ${T}, ${g}, 1)`),t.strokeStyle=k,t.lineWidth=h.trailWidth*c*(n?1:.7),t.beginPath(),t.moveTo(w,m),t.lineTo(l,u),t.stroke()}if(i>0){const k=Math.min(d,1),A=e+(r-e)*k,C=s+(o-s)*k;t.strokeStyle=`rgba(${y}, ${T}, ${g}, ${h.coreAlpha*(n?1:.5)})`,t.lineWidth=1*c,t.beginPath(),t.moveTo(e,s),t.lineTo(A,C),t.stroke()}if(i>0&&i<1){const k=t.createRadialGradient(l,u,0,l,u,h.headSize*2*c);k.addColorStop(0,"rgba(255, 255, 255, 0.9)"),k.addColorStop(.3,`rgba(${y}, ${T}, ${g}, 0.6)`),k.addColorStop(1,`rgba(${y}, ${T}, ${g}, 0)`),t.fillStyle=k,t.beginPath(),t.arc(l,u,h.headSize*2*c,0,Math.PI*2),t.fill(),t.fillStyle="#fff",t.beginPath(),t.arc(l,u,h.headSize*.5*c,0,Math.PI*2),t.fill()}}drawSynapses(t){if(!this.currentTestCase||!this.fsm.is("training")||!this.testRunning||this.synapseOpacity<=0)return;t.save(),t.globalAlpha=this.synapseOpacity;const e=this.width/2,s=this.height/2,r=p.grid.cols*this.gridSpacing,{cols:o}=p.grid,i=this.gridSpacing,a=p.testAnimation,n=this.testTime,h=a.inputToHidden,c=Math.min(1,n/h),d=n>h?Math.min(1,(n-h)/a.hiddenToOutput):0,l=e-r/2-100*this.scale,u=l,S=s-40*this.scale,w=l,m=s+40*this.scale,f=e+r/2+50*this.scale,y=this.gridSpacing,T=this.gridOffsetY;if(c>0&&this.activeGridCells.length>0)for(let g=0;g<this.activeGridCells.length;g++){const k=this.activeGridCells[g],A=Math.floor(k/o),C=k%o,M=this.gridOffsetX+C*i,b=this.gridOffsetY+A*i,v=g%2===0,D=v?u:w,O=v?S:m,P=g/this.activeGridCells.length*.3,$=Math.max(0,(c-P)/(1-P));this.drawTronSynapse(t,D,O,M,b,$,"#0ff",!0)}if(d>0&&this.activeGridCells.length>0){const g=this.cachedPrediction??this.currentPrediction,k=g!=null?this.neuronMapper.getOutputRow(g):-1,A=this.targetRow;for(let C=0;C<this.activeGridCells.length;C++){const M=this.activeGridCells[C],b=Math.floor(M/o),v=M%o,D=this.gridOffsetX+v*i,O=this.gridOffsetY+b*i;if(k>=0){const P=f,$=T+k*y,N=C/this.activeGridCells.length*.3,W=Math.max(0,(d-N)/(1-N));this.drawTronSynapse(t,D,O,P,$,W,"#0ff",!0)}if(A>=0&&A!==k){const P=f,$=T+A*y,N=C/this.activeGridCells.length*.3,W=Math.max(0,(d-N)/(1-N));this.drawTronSynapse(t,D,O,P,$,W,"#0f0",!1)}}}t.restore()}drawInputOutput(t){var M,b;if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const{text:e,neuronActive:s,neuronBright:r}=p.colors,o=this.currentTestCase.a??((M=this.currentTestCase.original)==null?void 0:M[0])??0,i=this.currentTestCase.b??((b=this.currentTestCase.original)==null?void 0:b[1])??0,a=this.currentTestCase.target,n=this.cachedPrediction??this.network.predict(o,i),h=n===a,c=this.width/2,d=this.height/2,l=p.grid.cols*this.gridSpacing;p.grid.rows*this.gridSpacing;const u=c-l/2-100*this.scale,S=c+l/2+150*this.scale,w=4*this.scale,m=18*this.scale,f=10,y=d-40*this.scale;this.drawNumberAsDots(t,o,u,y,w,m,f,s),t.fillStyle=e,t.font=`bold ${Math.round(32*this.scale)}px monospace`,t.textAlign="center",t.textBaseline="middle",t.fillText("+",u,d);const T=d+40*this.scale;this.drawNumberAsDots(t,i,u,T,w,m,f,s),this.drawNumberAsDots(t,a,S,d,w,m,f,r);const g=40*this.scale,A=40*this.scale+22*this.scale*6+60*this.scale+30*this.scale;t.textAlign="left",t.font=`bold ${Math.round(14*this.scale)}px monospace`,t.fillStyle=e;const C=o+i;t.fillText(`${o} + ${i} = ${C}`,g,A),t.font=`${Math.round(12*this.scale)}px monospace`,t.fillText(`mod ${p.network.nTokens} = ${a}`,g,A+18*this.scale),t.font=`bold ${Math.round(12*this.scale)}px monospace`,t.fillStyle=h?"#0ff":"#f00",t.fillText(`Predicted: ${n} ${h?"✓":"✗"}`,g,A+36*this.scale),t.restore()}drawNumberAsDots(t,e,s,r,o,i,a,n){const h=p.network.nTokens,c=Math.max(1,Math.ceil(Math.log2(h))),d=[];let l=e;for(let w=c-1;w>=0;w--){const m=l>>w&1;d.push(m)}const u=Math.ceil(c/a),S=r-(u-1)*i/2;t.globalAlpha=1;for(let w=0;w<c;w++){const m=d[w],f=Math.floor(w/a),y=w%a,g=(Math.min(a,c-f*a)-1)*i,k=s-g/2+y*i,A=S+f*i,C=new H(k,A,o);C.isActive=m===1,C.activation=m===1?1:0,C.render(t,p.colors)}}drawStats(t){if(!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const e=40*this.scale,s=40*this.scale,r=22*this.scale;if(t.fillStyle="#888",t.font=`${Math.round(14*this.scale)}px monospace`,t.textAlign="left",t.textBaseline="top",t.fillText(`Epoch: ${this.epoch}`,e,s),t.fillText(`Train: ${(this.trainAccuracy*100).toFixed(1)}%`,e,s+r),t.fillText(`Test: ${(this.testAccuracy*100).toFixed(1)}%`,e,s+r*2),this.grokMode>.5?(t.fillStyle="#f0f",t.fillText("✨ GROKKED!",e,s+r*3)):this.grokkingDetected&&(t.fillStyle="#0ff",t.fillText("✓ GROKKING!",e,s+r*3)),this.accuracyHistory.length>2){const o=150*this.scale,i=50*this.scale,a=e,n=s+r*6;t.fillStyle="rgba(0, 0, 0, 0.7)",t.fillRect(a-5,n-i-5,o+10,i+10),t.strokeStyle="rgba(0, 255, 0, 0.3)",t.lineWidth=1,t.strokeRect(a-5,n-i-5,o+10,i+10),t.strokeStyle="rgba(255, 255, 255, 0.15)",t.beginPath(),t.moveTo(a,n-i*.5),t.lineTo(a+o,n-i*.5),t.stroke();const h=Math.max(1,Math.floor(this.accuracyHistory.length/100));t.strokeStyle="#0f0",t.lineWidth=2.5*this.scale,t.shadowColor="#0f0",t.shadowBlur=4,t.beginPath();let c=!0;for(let d=0;d<this.accuracyHistory.length;d+=h){const l=this.accuracyHistory[d],u=a+d/this.accuracyHistory.length*o,S=n-l.train*i;c?(t.moveTo(u,S),c=!1):t.lineTo(u,S)}t.stroke(),t.strokeStyle="#0ff",t.shadowColor="#0ff",t.beginPath(),c=!0;for(let d=0;d<this.accuracyHistory.length;d+=h){const l=this.accuracyHistory[d],u=a+d/this.accuracyHistory.length*o,S=n-l.test*i;c?(t.moveTo(u,S),c=!1):t.lineTo(u,S)}t.stroke(),t.shadowBlur=0,t.font=`${Math.round(10*this.scale)}px monospace`,t.fillStyle="#0f0",t.fillText("Train",a,n+12*this.scale),t.fillStyle="#0ff",t.fillText("Test",a+50*this.scale,n+12*this.scale)}t.restore()}}function j(I){const t=new L(I);return t.start(),{stop:()=>t.stop(),game:t}}export{j as default};
