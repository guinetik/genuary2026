import{G as M,P as S,C as w,c as v}from"./index-BijcbkZy.js";const h={background:"#000",maxDepth:3,particleBaseSize:20,particleMinSize:2,particleShape:"square",colors:{stroke:"#0f0"},camera:{perspective:800,rotationX:.5,rotationY:-.6,inertia:!0,friction:.92,clampX:!1},animation:{autoRotateSpeed:.15,attractStrength:8,damping:.92,scatterForce:800,buildDelay:.003}},f=[{x:1,y:0,z:0},{x:-1,y:0,z:0},{x:0,y:-1,z:0},{x:0,y:1,z:0},{x:0,y:0,z:1},{x:0,y:0,z:-1},{x:1,y:-1,z:0},{x:-1,y:-1,z:0},{x:1,y:1,z:0},{x:-1,y:1,z:0},{x:1,y:0,z:1},{x:-1,y:0,z:1},{x:1,y:0,z:-1},{x:-1,y:0,z:-1},{x:0,y:-1,z:1},{x:0,y:-1,z:-1},{x:0,y:1,z:1},{x:0,y:1,z:-1}];function b(x,t,s,a,n,i,o=[]){if(n>=i)return o.push({x,y:t,z:s,size:a,depth:n}),o;const c=a/3,r=a/3;for(let l=-1;l<=1;l++)for(let e=-1;e<=1;e++)for(let p=-1;p<=1;p++){if((l===0?1:0)+(e===0?1:0)+(p===0?1:0)>=2)continue;const d=x+l*r,z=t+e*r,y=s+p*r;b(d,z,y,c,n+1,i,o)}return o}class P extends M{constructor(t){super(t),this.backgroundColor=h.background}init(){super.init(),S.init(this.ctx),this.camera=new w({perspective:h.camera.perspective,rotationX:h.camera.rotationX,rotationY:h.camera.rotationY,inertia:h.camera.inertia,friction:h.camera.friction,clampX:h.camera.clampX}),this.camera.enableMouseControl(this.canvas),this.time=0,this.globalRotation=0,this.zoom=1,this.targetZoom=1,this.buildTime=0,this.cubesSpawned=0,this.spongeCount=0,this.totalParticles=0,this.existingPositions=new Set,this.positionTolerance=.1,this.nextCubeIndex=0,this.generateTargets(),this.createParticleSystem(),this.canvas.addEventListener("dblclick",()=>{this.scatterParticles()}),this.canvas.addEventListener("wheel",t=>{t.preventDefault();const s=t.deltaY>0?.9:1.1;this.targetZoom=Math.max(.3,Math.min(15,this.targetZoom*s))},{passive:!1})}generateTargets(){const s=Math.min(this.width,this.height)*.35,a=b(0,0,0,s,0,h.maxDepth);a.sort((i,o)=>i.depth-o.depth);const n=this.positionTolerance;this.cubes=a.map((i,o)=>{const c=`${Math.round(i.x/n)},${Math.round(i.y/n)},${Math.round(i.z/n)}`;return this.existingPositions.add(c),{x:i.x,y:i.y,z:i.z,size:i.size,spawnDelay:o*h.animation.buildDelay,spawned:!1}}),console.log(`Menger Sponge: ${this.cubes.length} cubes/particles`)}createParticleSystem(){this._cosY=1,this._sinY=0,this._strength=h.animation.attractStrength,this._damping=h.animation.damping;const t=(s,a)=>{if(!s.alive)return;const n=s.custom;if(n.targetX===void 0)return;const i=n.targetX*this._cosY-n.targetZ*this._sinY,o=n.targetX*this._sinY+n.targetZ*this._cosY,c=this.zoom,r=i*c-s.x,l=n.targetY*c-s.y,e=o*c-s.z,p=this._strength*a,g=this._damping;s.vx=(s.vx+r*p)*g,s.vy=(s.vy+l*p)*g,s.vz=(s.vz+e*p)*g,s.x+=s.vx*a,s.y+=s.vy*a,s.z+=s.vz*a};this.particles=new v(this,{camera:this.camera,depthSort:!0,maxParticles:5e4,blendMode:"source-over",updaters:[t]}),this.pipeline.add(this.particles)}spawnCube(t){const s=this._spawnRadius||(this._spawnRadius=Math.max(this.width,this.height)*.8),a=Math.random()*Math.PI*2,n=Math.acos(2*Math.random()-1),i=s*(.3+Math.random()*.7),o=Math.sin(n),c=i*o*Math.cos(a),r=i*o*Math.sin(a),l=i*Math.cos(n),e=this.particles.acquire();e.x=c,e.y=r,e.z=l,e.vx=-c*.5,e.vy=-r*.5,e.vz=-l*.5;const p=this._baseSizeRef||(this._baseSizeRef=Math.min(this.width,this.height)*.35);e.size=Math.max(h.particleMinSize,h.particleBaseSize*t.size/p),e.color.r=0,e.color.g=255,e.color.b=0,e.color.a=1,e.shape=h.particleShape,e.age=0,e.lifetime=1/0,e.alive=!0,e.custom.targetX=t.x,e.custom.targetY=t.y,e.custom.targetZ=t.z,this.particles.particles.push(e),t.spawned=!0,this.cubesSpawned++}scatterParticles(){const t=this.particles.particles,s=h.animation.scatterForce;for(let a=0,n=t.length;a<n;a++){const i=t[a];if(!i.alive)continue;const o=Math.random()*Math.PI*2,c=Math.acos(2*Math.random()-1),r=s*(.5+Math.random()),l=Math.sin(c);i.vx+=r*l*Math.cos(o),i.vy+=r*l*Math.sin(o),i.vz+=r*Math.cos(c)}}update(t){for(super.update(t),this.time+=t,this.buildTime+=t,this.camera.update(t),this.globalRotation+=h.animation.autoRotateSpeed*t,this._cosY=Math.cos(this.globalRotation),this._sinY=Math.sin(this.globalRotation),this.zoom+=(this.targetZoom-this.zoom)*.15;this.nextCubeIndex<this.cubes.length;){const s=this.cubes[this.nextCubeIndex];if(this.buildTime>=s.spawnDelay)this.spawnCube(s),this.nextCubeIndex++;else break}this.nextCubeIndex>=this.cubes.length&&this.spawnNextSponge()}spawnNextSponge(){this.spongeCount++,this.totalParticles+=this.cubesSpawned;const s=Math.min(this.width,this.height)*.35,a=s,n=Math.floor(this.spongeCount/f.length)+1,i=(this.spongeCount-1)%f.length,o=f[i],c=o.x*a*n,r=o.y*a*n,l=o.z*a*n,e=b(c,r,l,s,0,h.maxDepth),p=this.positionTolerance,g=this.existingPositions,d=[];for(const m of e){const u=`${Math.round(m.x/p)},${Math.round(m.y/p)},${Math.round(m.z/p)}`;g.has(u)||(g.add(u),d.push(m))}d.sort((m,u)=>m.depth-u.depth);const z=this.buildTime;for(let m=0;m<d.length;m++){const u=d[m];this.cubes.push({x:u.x,y:u.y,z:u.z,size:u.size,spawnDelay:z+m*h.animation.buildDelay,spawned:!1})}const y=e.length-d.length;console.log(`Sponge #${this.spongeCount+1} | New: ${d.length} | Shared: ${y}`)}clear(){this.ctx.fillStyle="rgba(0, 0, 0, 0.1)",this.ctx.fillRect(0,0,this.width,this.height)}render(){super.render();const t=this.ctx;t.fillStyle=h.colors.stroke,t.font="12px monospace",t.textAlign="left",t.fillText(`MENGER SPONGE | Depth: ${h.maxDepth} | Sponges: ${this.spongeCount+1} | Particles: ${this.cubesSpawned}`,10,this.height-10),t.textAlign="right",t.fillText(`Zoom: ${this.zoom.toFixed(1)}x | Dbl-click to scatter`,this.width-10,this.height-10)}onResize(){this._spawnRadius=null,this._baseSizeRef=null}}function D(x){const t=new P(x);return t.start(),{stop:()=>t.stop(),game:t}}export{D as default};
