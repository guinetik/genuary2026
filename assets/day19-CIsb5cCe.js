import{G as z,k as H,T as N,E as F}from"./index-B6QQFJuW.js";import{FactoredNetwork as I,generateAllPairs as G,splitData as _,calcAccuracy as B}from"./day19.grokking-BLQhquhM.js";import"./day19.utils-DeEDoNyc.js";class P{constructor(t,l,r=4){this.x=t,this.y=l,this.targetX=t,this.targetY=l,this.baseSize=r,this.activation=0,this.isActive=!1,this.isSelected=!1,this.isTarget=!1,this.isError=!1,this.spawnScale=1}render(t,l){const{neuronIdle:r,neuronActive:i,neuronBright:a}=l;if(this.isActive){const s=this.baseSize,e=s*1.1,h=.2;t.fillStyle=`rgba(0, 255, 0, ${h})`,t.beginPath(),t.arc(this.x,this.y,e,0,Math.PI*2),t.fill();let o=i;(this.isSelected||this.isTarget)&&(o=a),t.fillStyle=o,t.globalAlpha=1,t.beginPath(),t.arc(this.x,this.y,s,0,Math.PI*2),t.fill(),t.globalAlpha=1}else t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,this.baseSize*.5,0,Math.PI*2),t.fill()}renderGrid(t,l,r=1,i=0,a=1,s=0,e=0,h=0,o=0){if(this.spawnScale<=.01)return;const{neuronActive:u,neuronBright:f}=l,w=Math.min(1,this.activation/r),n=Math.min(1,w+i*.5),y=i>.1,c=this.spawnScale,$=4*a*c,O=2*a*c,d=(e*.1+h*.15+o*.1)%1,m=Math.floor((.5+.5*Math.sin(d*6.28))*255),k=Math.floor((.5+.5*Math.sin(d*6.28+2.09))*255),g=Math.floor((.5+.5*Math.sin(d*6.28+4.18))*255);if(n<.05&&!y){if(s>.5){const M=.3+s*.2,D=Math.floor(m*M),A=Math.floor(k*M),C=Math.floor(g*M);t.fillStyle=`rgb(${D}, ${A}, ${C})`,t.beginPath(),t.arc(this.x,this.y,O*(1+s*.5),0,Math.PI*2),t.fill()}else if(s>.01){const M=(.1+s*.4)*c,D=Math.floor(255*(1-s)+k*s),A=Math.floor(0*(1-s)+m*s),C=Math.floor(0*(1-s)+g*s);t.fillStyle=`rgba(${A}, ${D}, ${C}, ${M})`,t.beginPath(),t.arc(this.x,this.y,O,0,Math.PI*2),t.fill()}else t.fillStyle=`rgba(0, 255, 0, ${.1*c})`,t.beginPath(),t.arc(this.x,this.y,O,0,Math.PI*2),t.fill();return}const T=($+n*3*a+i*2*a)*c;let b,S;if(s>.5)if(y){const M=Math.min(255,m+Math.floor(i*100)),D=Math.min(255,k+Math.floor(i*100)),A=Math.min(255,g+Math.floor(i*100));b=`rgb(${M}, ${D}, ${A})`,S=`rgba(${m}, ${k}, ${g}, ${(.4+i*.5)*c})`}else b=`rgb(${m}, ${k}, ${g})`,S=`rgba(${m}, ${k}, ${g}, ${(.15+n*.3)*c})`;else if(y){const M=Math.floor(i*255),D=Math.floor(M*(1-s)+Math.min(255,m+100)*s),A=Math.floor(255*(1-s)+Math.min(255,k+100)*s),C=Math.floor(M*(1-s)+Math.min(255,g+100)*s);b=`rgb(${D}, ${A}, ${C})`;const Y=Math.floor(0*(1-s)+m*s),R=Math.floor(255*(1-s)+k*s),X=Math.floor(255*(1-s)+g*s);S=`rgba(${Y}, ${R}, ${X}, ${(.3+i*.4)*c})`}else if(n>.5)s>.01?(b=`rgb(${m}, ${k}, ${g})`,S=`rgba(${m}, ${k}, ${g}, ${(.1+n*.25)*c})`):(b=f,S=`rgba(0, 255, 0, ${(.1+n*.25)*c})`);else if(s>.01){const D=Math.floor(m*.7),A=Math.floor(k*.7),C=Math.floor(g*.7);b=`rgb(${D}, ${A}, ${C})`,S=`rgba(${m}, ${k}, ${g}, ${(.1+n*.25)*c})`}else b=u,S=`rgba(0, 255, 0, ${(.1+n*.25)*c})`;const v=1.6+i*.5;t.fillStyle=S,t.beginPath(),t.arc(this.x,this.y,T*v,0,Math.PI*2),t.fill(),t.fillStyle=b,t.beginPath(),t.arc(this.x,this.y,T,0,Math.PI*2),t.fill(),s<.5&&(n>.2||y)&&c>.5&&(t.fillStyle="#fff",t.beginPath(),t.arc(this.x,this.y,T*.3,0,Math.PI*2),t.fill())}renderOutput(t,l,r=0,i=1,a=0){if(this.spawnScale<=.01)return;const s=this.spawnScale,e=4*i*s,h=2*i*s,o=r,u=this.isError&&a<.5;if(o<.05){const c=this.isTarget||this.isSelected?.25:.1;t.fillStyle=u?`rgba(255, 0, 0, ${c*s})`:`rgba(0, 255, 0, ${c*s})`,t.beginPath(),t.arc(this.x,this.y,h,0,Math.PI*2),t.fill();return}const f=(e+o*5*i)*s;let w,n;if(u)w=`rgb(${Math.floor(200+o*55)}, ${Math.floor(o*50)}, ${Math.floor(o*50)})`,n=`rgba(255, 50, 50, ${o*.5*s})`;else if(this.isTarget&&this.isSelected){const c=Math.floor(200+o*55);w=`rgb(${Math.floor(o*200)}, ${c}, ${Math.floor(o*200)})`,n=`rgba(100, 255, 100, ${o*.5*s})`}else{const c=Math.floor(o*255);w=`rgb(${c}, 255, ${c})`,n=`rgba(0, 255, 255, ${o*.5*s})`}const y=1.5+o*.8;t.fillStyle=n,t.beginPath(),t.arc(this.x,this.y,f*y,0,Math.PI*2),t.fill(),t.fillStyle=w,t.beginPath(),t.arc(this.x,this.y,f,0,Math.PI*2),t.fill(),o>.3&&(t.fillStyle=`rgba(255, 255, 255, ${o})`,t.beginPath(),t.arc(this.x,this.y,f*.3,0,Math.PI*2),t.fill())}}const p={background:"#000",network:{nTokens:67,embedSize:500,hiddenSize:64,learningRate:.01,weightDecay:1,beta1:.9,beta2:.98,symmetric:!0,trainFraction:.4},training:{batchSize:64,epochsPerFrame:16,showGrokking:!0,useWorker:!0},grid:{rows:16,cols:16,baseSpacing:38,referenceSize:800},timing:{flashDuration:.5,activationDuration:.4,traceLength:.4,connectionCycle:.5},colors:{neuronIdle:"#0a0",neuronActive:"#0f0",neuronBright:"#fff",text:"#0f0",testCase:"rgba(0, 255, 0, 0.3)"}};class E extends z{constructor(t){super(t),this.backgroundColor=p.background}init(){super.init(),console.log("[Day19] Creating FactoredNetwork...");const t=performance.now();try{this.network=new I(p.network),console.log(`[Day19] Network created in ${(performance.now()-t).toFixed(1)}ms`)}catch(h){console.error("[Day19] Failed to create network:",h);return}const{nTokens:l,symmetric:r,trainFraction:i}=p.network,a=G(l,r),s=_(a,i);this.trainData=s.train,this.testData=s.test,console.log(`Generated ${a.length} pairs (symmetric=${r}): ${this.trainData.length} train, ${this.testData.length} test`),this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.trainLoss=0,this.testLoss=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.currentTestCase=null,this.testCaseTime=0;const e=Math.min(this.width,this.height);if(this.scale=e/p.grid.referenceSize,this.gridSpacing=p.grid.baseSpacing*this.scale,this.synapseAnimationTime=0,this.outputFlashes=new Map,this.gridFlashes=new Map,this.lastGridFlashIdx=-1,this.lastOutputFlashIdx=-1,this.lastOutputSourceFlashKey=null,this.activatedGridNeurons=new Set,this.activatedOutputNeurons=new Set,this.currentTestCaseId=null,this.grokMode=0,this.grokThreshold=.6,this.outputNeurons=[],this.outputNeuronsInitialized=!1,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainData.length>0){const h=this.trainData[0];this.network.forward(h.a,h.b)}this.gridOffsetX=0,this.gridOffsetY=0,this.useWorker=p.training.useWorker,this.workerReady=!1,this.workerTraining=!1,this.useWorker&&this.initWorker(),this.inputDots=[],this.outputDots=[],this.fsm=new H({initial:"intro",context:this,states:{intro:{enter:()=>this.startIntroAnimation(),update:h=>this.updateIntro(h)},training:{enter:()=>this.startTraining(),update:h=>this.updateTraining(h)}}}),this.trainingOpacity=0,this.synapseOpacity=0,this.canvas.addEventListener("click",()=>{this.restart()}),this.grokModeOverride=!1,this.originalTestData=null,window.addEventListener("keydown",h=>{(h.key==="g"||h.key==="G")&&(this.grokModeOverride=!this.grokModeOverride,this.grokModeOverride?(this.originalTestData=this.testData,this.testData=[...this.trainData],this.grokMode=1,console.log(`[DEBUG] Grok mode ON - test set = train set (${this.testData.length} examples)`),this.worker&&(this.worker.postMessage({type:"grokMode",enabled:!0}),this.worker.postMessage({type:"syncWeights"}))):(this.originalTestData&&(this.testData=this.originalTestData,this.originalTestData=null),this.grokMode=0,console.log(`[DEBUG] Grok mode OFF - original test set restored (${this.testData.length} examples)`),this.worker&&this.worker.postMessage({type:"grokMode",enabled:!1})))})}initWorker(){try{this.worker=new Worker(new URL("/assets/day19.worker-CiCYPVIj.js",import.meta.url),{type:"module"}),this.worker.onmessage=t=>{const{type:l}=t.data;switch(l){case"state":this.epoch=t.data.epoch,this.trainAccuracy=t.data.trainAccuracy,this.testAccuracy=t.data.testAccuracy,this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.workerTraining=!1,this.workerReady=!0;break;case"forward":this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.cachedOutput=new Float32Array(t.data.outputActivations),this.cachedPrediction=t.data.prediction;break;case"syncWeights":if(this.network&&t.data.weights){const r=t.data.weights;this.network.embed=r.embed,this.network.Whidden=r.Whidden,this.network.Wout=r.Wout,console.log("[Main] Synced weights from worker"),this._weightsSynced=!0}break}},this.worker.onerror=t=>{console.error("Worker error:",t),this.useWorker=!1,this.workerReady=!1},this.worker.postMessage({type:"init",data:{config:p.network}}),console.log("Web Worker initialized for training")}catch(t){console.warn("Failed to create Web Worker, falling back to main thread:",t),this.useWorker=!1}}startIntroAnimation(){const t=this.width/2,l=this.height/2,{rows:r,cols:i}=p.grid;this.pendingTweens=0,this.gridOffsetX=this.width/2-i*this.gridSpacing/2,this.gridOffsetY=this.height/2-r*this.gridSpacing/2,this.gridNeurons=[];for(let s=0;s<r;s++)for(let e=0;e<i;e++){const h=this.gridOffsetX+e*this.gridSpacing,o=this.gridOffsetY+s*this.gridSpacing,u=new P(t,l,4*this.scale);u.targetX=h,u.targetY=o,u.spawnScale=0,this.gridNeurons.push(u);const w=Math.sqrt(Math.pow(e-i/2,2)+Math.pow(s-r/2,2))*.04;this.pendingTweens++,N.to(u,{x:h,y:o,spawnScale:1},.4,F.easeOutBack,{delay:.1+w,onComplete:()=>this.onTweenComplete()})}const a=i*this.gridSpacing;t-a/2-100*this.scale,t+a/2+100*this.scale,this.inputDots=[];for(let s=0;s<14;s++){const e={x:t,y:l,spawnScale:0};this.inputDots.push(e),this.pendingTweens++,N.to(e,{spawnScale:1},.3,F.easeOutBack,{delay:.05+s*.01,onComplete:()=>this.onTweenComplete()})}this.outputDots=[];for(let s=0;s<7;s++){const e={x:t,y:l,spawnScale:0};this.outputDots.push(e),this.pendingTweens++,N.to(e,{spawnScale:1},.3,F.easeOutBack,{delay:.1+s*.01,onComplete:()=>this.onTweenComplete()})}}onTweenComplete(){this.pendingTweens--,this.pendingTweens<=0&&this.fsm.is("intro")&&this.fsm.setState("training")}updateIntro(t){}startTraining(){this.trainingOpacity=0,this.synapseOpacity=0,N.to(this,{trainingOpacity:1},.8,F.easeOutQuad),N.to(this,{synapseOpacity:1},1.5,F.easeInOutQuad,{delay:.5})}updateTraining(t){N.updateAll(t),this.trainNetwork(),this.synapseAnimationTime+=t}restart(){this.network=new I(p.network);const{nTokens:t,symmetric:l,trainFraction:r}=p.network,i=G(t,l),a=_(i,r);this.trainData=a.train,this.testData=a.test,this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.grokMode=0,this.grokModeOverride=!1,this.outputNeuronsInitialized=!1,this.outputNeuronsKeys=null,this.gridNeurons=null,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainingOpacity=0,this.synapseOpacity=0,this.useWorker&&this.worker&&(this.workerReady=!1,this.workerTraining=!1,this.worker.postMessage({type:"reset",data:{config:p.network}})),N.killAll(),this.fsm.setState("intro")}update(t){super.update(t);const l=Math.min(this.width,this.height);if(this.scale=l/p.grid.referenceSize,this.gridSpacing=p.grid.baseSpacing*this.scale,this.gridOffsetX=this.width/2-p.grid.cols*this.gridSpacing/2,this.gridOffsetY=this.height/2-p.grid.rows*this.gridSpacing/2,this.fsm.update(t),this.animTime+=t,this.testCaseTime+=t,this.testCaseTime>2){this.testCaseTime=0;const r=Math.floor(Math.random()*this.testData.length);this.currentTestCase=this.testData[r],this.currentTestCaseId=r,this.outputNeuronsInitialized=!1,this.cachedOutput=null,this.cachedPrediction=null,this.activatedGridNeurons.clear(),this.activatedOutputNeurons.clear(),this.gridFlashes.clear(),this.outputFlashes.clear(),this.lastGridFlashIdx=-1,this.lastOutputFlashIdx=-1,this.lastOutputSourceFlashKey=null}if(this.currentTestCase){const{probs:r}=this.network.forward(this.currentTestCase.a,this.currentTestCase.b);this.cachedOutput=r,(!this.useWorker||!this.workerReady)&&(this.cachedPrediction=this.network.predict(this.currentTestCase.a,this.currentTestCase.b))}else this.trainData.length>0&&(this.currentTestCase=this.trainData[0]);this.currentTestCase&&this.useWorker&&this.workerReady&&(!this._lastForwardRequest||Date.now()-this._lastForwardRequest>100)&&(this._lastForwardRequest=Date.now(),this.worker.postMessage({type:"forward",data:{a:this.currentTestCase.a,b:this.currentTestCase.b}}))}trainNetwork(){const{epochsPerFrame:t,batchSize:l}=p.training,{nTokens:r}=p.network;if(this.useWorker&&this.workerReady&&!this.workerTraining){if(this.workerTraining=!0,this.worker.postMessage({type:"train",data:{epochsPerFrame:t,batchSize:l}}),this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokModeOverride){const i=this.trainAccuracy>=.95,s=i&&this.testAccuracy>=this.grokThreshold?1:0,e=this.grokMode>.5;this.grokMode+=(s-this.grokMode)*.05,!e&&this.grokMode>.5&&(this.currentTestCase=null,this.cachedOutput=null,this.cachedPrediction=null,this.useWorker&&this.workerReady&&!this._weightsSynced&&this.worker.postMessage({type:"syncWeights"})),i&&this.useWorker&&this.workerReady&&(!this._lastWeightSync||Date.now()-this._lastWeightSync>5e3)&&(this._lastWeightSync=Date.now(),this.worker.postMessage({type:"syncWeights"}))}return}if(!this.useWorker){this.network.resetGradients();for(let i=0;i<t;i++){for(let a=0;a<this.trainData.length;a++){const s=this.trainData[a],{cache:e}=this.network.forward(s.a,s.b);this.network.backward(s.target,e)}this.network.applyAdamW(this.trainData.length),this.epoch++}if(this.epoch%20===0){const i=this.trainData.slice(0,Math.min(100,this.trainData.length)),a=this.testData.slice(0,Math.min(100,this.testData.length));this.trainAccuracy=B(this.network,i),this.testAccuracy=B(this.network,a)}if(this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokkingDetected&&this.epoch>100){const i=this.accuracyHistory.slice(-50);if(i.length>=50){const a=i[0].test,s=i[i.length-1].test;this.trainAccuracy>.8&&s-a>.3&&(this.grokkingDetected=!0,this.grokkingEpoch=this.epoch)}}}}render(){const t=this.ctx,l=this.width,r=this.height;t.fillStyle="rgba(0, 0, 0, 0.2)",t.fillRect(0,0,l,r),this.updateOutputNeuronState(),this.drawSynapses(t),this.drawNeuronGrid(t),this.drawInputOutputNeurons(t),this.drawInputOutput(t),this.drawStats(t)}drawNeuronGrid(t){const{rows:l,cols:r}=p.grid,i=this.gridSpacing,a=this.network.hiddenActivations;if(!a||a.length===0)return;let s=0;for(let o=0;o<a.length;o++)a[o]>s&&(s=a[o]);s=Math.max(s,.001),this._normCache=this._normCache?this._normCache*.9+s*.1:s;const e=this._lastSpacing&&Math.abs(this._lastSpacing-i)>1;this._lastSpacing=i;const h=this.fsm.is("intro");if(!this.gridNeurons||this.gridNeurons.length!==l*r||e&&!h){this.gridNeurons=[];for(let o=0;o<l;o++)for(let u=0;u<r;u++){const f=this.gridOffsetX+u*i,w=this.gridOffsetY+o*i;this.gridNeurons.push(new P(f,w,4*this.scale))}}for(let o=0;o<l;o++)for(let u=0;u<r;u++){const f=o*r+u,w=this.gridNeurons[f];w.x=this.gridOffsetX+u*i,w.y=this.gridOffsetY+o*i;let n=0;if(this.gridFlashes&&this.gridFlashes.has(f)){const y=this.gridFlashes.get(f),c=this.synapseAnimationTime-y;if(c<p.timing.flashDuration){const $=c/p.timing.flashDuration;n=1-$*$,this.activatedGridNeurons.add(f)}else this.gridFlashes.delete(f),this.activatedGridNeurons.delete(f)}h?(w.activation=0,w.isActive=!1):(w.activation=n,w.isActive=n>.1),w.renderGrid(t,p.colors,this._normCache,n,this.scale,this.grokMode,o,u,this.animTime)}}updateOutputNeuronState(){if(!this.currentTestCase||!this.cachedOutput||!this.fsm.is("training"))return;const t=this.width/2,l=this.height/2,r=p.grid.cols*this.gridSpacing,i=t+r/2+8*this.scale,a=this.cachedOutput,s=this.cachedPrediction,e=16,h=p.network.nTokens;this._rowActivations||(this._rowActivations=new Float32Array(e)),this._rowTokens||(this._rowTokens=new Int16Array(e)),this._rowActivations.fill(0),this._rowTokens.fill(-1);for(let n=0;n<h;n++){const y=Math.floor(n*e/h);a[n]>this._rowActivations[y]&&(this._rowActivations[y]=a[n],this._rowTokens[y]=n)}const o=this.gridSpacing,u=l-(e-1)*o/2;if(!this.outputNeurons||this.outputNeurons.length!==e){this.outputNeurons=[];for(let n=0;n<e;n++){const y=u+n*o;this.outputNeurons.push(new P(i,y,4*this.scale))}}const f=s!=null?Math.floor(s*e/h):-1,w=this.currentTestCase.target!==void 0?Math.floor(this.currentTestCase.target*e/h):-1;for(let n=0;n<e;n++){const y=this.outputNeurons[n];y.x=i,y.y=u+n*o,y.isTarget=n===w,y.isSelected=n===f}}drawInputOutputNeurons(t){if(!this.currentTestCase||!this.cachedOutput||!this.fsm.is("training")||this.trainingOpacity<=0||!this.outputNeurons||this.outputNeurons.length===0)return;t.save(),t.globalAlpha=this.trainingOpacity;const l=16;for(let r=0;r<l;r++){const i=this.outputNeurons[r];let a=0;if(this.outputFlashes.has(r)){const e=this.outputFlashes.get(r),h=this.synapseAnimationTime-e;if(h<p.timing.flashDuration){const o=h/p.timing.flashDuration;a=1-o*o,this.activatedOutputNeurons.add(r)}else this.outputFlashes.delete(r),this.activatedOutputNeurons.delete(r)}i.activation=a;const s=i.isTarget&&!i.isSelected||!i.isTarget&&i.isSelected;i.isError=a>.1&&s,i.renderOutput(t,p.colors,a,this.scale,this.grokMode)}t.restore()}drawSynapses(t){if(!this.currentTestCase||!this.fsm.is("training")||this.synapseOpacity<=0||!this.cachedOutput||!this.gridNeurons)return;t.save(),t.globalAlpha=this.synapseOpacity;const l=this.width/2,r=this.height/2,i=p.grid.cols*this.gridSpacing,{cols:a}=p.grid,s=this.gridSpacing,e=this.synapseAnimationTime;for(const[d,m]of this.gridFlashes.entries())e-m>p.timing.activationDuration&&(this.gridFlashes.delete(d),this.activatedGridNeurons.delete(d));for(const[d,m]of this.outputFlashes.entries())e-m>p.timing.activationDuration&&(this.outputFlashes.delete(d),this.activatedOutputNeurons.delete(d));const h=this.network.hiddenActivations;h&&Math.max(...h,.001);const o=d=>{const k=(Math.floor(e*8)*17+d*31)%256,g=Math.floor(k/a),T=k%a;return{index:k,x:this.gridOffsetX+T*s,y:this.gridOffsetY+g*s}},u=l-i/2-100*this.scale,f=u,w=r-40*this.scale,n=u,y=r+40*this.scale;t.lineCap="round";const c=12,$=8;for(let d=0;d<c;d++){const m=(e*6+d*.083)%1,k=o(d),g=d%2===0,T=g?f:n,b=g?w:y,S=Math.min(1,m*3),v=1-Math.pow(1-S,3),M=T+(k.x-T)*v,D=b+(k.y-b)*v;let A=(1-m)*.6;t.strokeStyle="#0ff",t.lineWidth=Math.max(.5,1*this.scale),t.globalAlpha=this.synapseOpacity*A,t.beginPath(),t.moveTo(T,b),t.lineTo(M,D),t.stroke(),S<1&&A>.1&&(t.fillStyle=`rgba(0, 255, 255, ${A*.5})`,t.beginPath(),t.arc(M,D,2*this.scale,0,Math.PI*2),t.fill()),S>.9&&(this.gridFlashes.set(k.index,e),this.activatedGridNeurons.add(k.index))}const O=[];if(this.outputNeurons&&this.outputNeurons.length>0)for(let d=0;d<this.outputNeurons.length;d++){const m=this.outputNeurons[d];(m.isSelected||m.isTarget)&&O.push({position:d,x:m.x,y:m.y,isPrimary:m.isSelected})}if(O.length>0){if(!this._sourcesBuffer){this._sourcesBuffer=[];for(let g=0;g<8;g++)this._sourcesBuffer.push({index:0,x:0,y:0})}let d=0;for(const g of this.activatedGridNeurons){if(d>=8)break;const T=Math.floor(g/a),b=g%a;this._sourcesBuffer[d].index=g,this._sourcesBuffer[d].x=this.gridOffsetX+b*s,this._sourcesBuffer[d].y=this.gridOffsetY+T*s,d++}if(d===0)for(let g=0;g<4;g++){const T=o(g);this._sourcesBuffer[d].index=T.index,this._sourcesBuffer[d].x=T.x,this._sourcesBuffer[d].y=T.y,d++}const m=this._sourcesBuffer,k=d;for(let g=0;g<$;g++){const T=(e*5+g*.125+.15)%1,b=m[g%k],S=O[g%O.length],v=Math.min(1,T*3),M=1-Math.pow(1-v,3),D=b.x+(S.x-b.x)*M,A=b.y+(S.y-b.y)*M;let C=(1-T)*.5;t.strokeStyle="#0ff",t.lineWidth=Math.max(.5,1*this.scale),t.globalAlpha=this.synapseOpacity*C,t.beginPath(),t.moveTo(b.x,b.y),t.lineTo(D,A),t.stroke(),v<1&&C>.1&&(t.fillStyle=`rgba(0, 255, 255, ${C*.5})`,t.beginPath(),t.arc(D,A,2*this.scale,0,Math.PI*2),t.fill()),v>.1&&v<.3&&this.gridFlashes.set(b.index,e),v>.9&&(this.outputFlashes.set(S.position,e),this.activatedOutputNeurons.add(S.position))}}t.restore()}drawInputOutput(t){var S,v;if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const{text:l,neuronActive:r,neuronBright:i}=p.colors,a=this.currentTestCase.a??((S=this.currentTestCase.original)==null?void 0:S[0])??0,s=this.currentTestCase.b??((v=this.currentTestCase.original)==null?void 0:v[1])??0,e=this.currentTestCase.target,h=this.cachedPrediction??this.network.predict(a,s),o=h===e,u=this.width/2,f=this.height/2,w=p.grid.cols*this.gridSpacing;p.grid.rows*this.gridSpacing;const n=u-w/2-100*this.scale,y=u+w/2+100*this.scale,c=4*this.scale,$=18*this.scale,O=10,d=f-40*this.scale;this.drawNumberAsDots(t,a,n,d,c,$,O,r),t.fillStyle=l,t.font=`bold ${Math.round(32*this.scale)}px monospace`,t.textAlign="center",t.textBaseline="middle",t.fillText("+",n,f);const m=f+40*this.scale;this.drawNumberAsDots(t,s,n,m,c,$,O,r),this.drawNumberAsDots(t,e,y,f,c,$,O,i);const k=40*this.scale,T=40*this.scale+22*this.scale*6+40*this.scale+30*this.scale;t.textAlign="left",t.font=`bold ${Math.round(14*this.scale)}px monospace`,t.fillStyle=l;const b=a+s;t.fillText(`${a} + ${s} = ${b}`,k,T),t.font=`${Math.round(12*this.scale)}px monospace`,t.fillText(`mod ${p.network.nTokens} = ${e}`,k,T+18*this.scale),t.font=`bold ${Math.round(12*this.scale)}px monospace`,t.fillStyle=o?"#0ff":"#f00",t.fillText(`Predicted: ${h} ${o?"✓":"✗"}`,k,T+36*this.scale),t.restore()}drawNumberAsDots(t,l,r,i,a,s,e,h){const o=p.network.nTokens,u=Math.max(1,Math.ceil(Math.log2(o))),f=[];let w=l;for(let c=u-1;c>=0;c--){const $=w>>c&1;f.push($)}const n=Math.ceil(u/e),y=i-(n-1)*s/2;t.globalAlpha=1;for(let c=0;c<u;c++){const $=f[c],O=Math.floor(c/e),d=c%e,k=(Math.min(e,u-O*e)-1)*s,g=r-k/2+d*s,T=y+O*s,b=new P(g,T,a);b.isActive=$===1,b.activation=$===1?1:0,b.render(t,p.colors)}}drawStats(t){if(!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const l=40*this.scale,r=40*this.scale,i=22*this.scale;if(t.fillStyle="#888",t.font=`${Math.round(14*this.scale)}px monospace`,t.textAlign="left",t.textBaseline="top",t.fillText(`Epoch: ${this.epoch}`,l,r),t.fillText(`Train: ${(this.trainAccuracy*100).toFixed(1)}%`,l,r+i),t.fillText(`Test: ${(this.testAccuracy*100).toFixed(1)}%`,l,r+i*2),this.grokMode>.5?(t.fillStyle="#f0f",t.fillText("✨ GROKKED!",l,r+i*3)):this.grokkingDetected&&(t.fillStyle="#0ff",t.fillText("✓ GROKKING!",l,r+i*3)),this.accuracyHistory.length>2){const a=150*this.scale,s=50*this.scale,e=l,h=r+i*6;t.fillStyle="rgba(0, 0, 0, 0.7)",t.fillRect(e-5,h-s-5,a+10,s+10),t.strokeStyle="rgba(0, 255, 0, 0.3)",t.lineWidth=1,t.strokeRect(e-5,h-s-5,a+10,s+10),t.strokeStyle="rgba(255, 255, 255, 0.15)",t.beginPath(),t.moveTo(e,h-s*.5),t.lineTo(e+a,h-s*.5),t.stroke();const o=Math.max(1,Math.floor(this.accuracyHistory.length/100));t.strokeStyle="#0f0",t.lineWidth=2.5*this.scale,t.shadowColor="#0f0",t.shadowBlur=4,t.beginPath();let u=!0;for(let f=0;f<this.accuracyHistory.length;f+=o){const w=this.accuracyHistory[f],n=e+f/this.accuracyHistory.length*a,y=h-w.train*s;u?(t.moveTo(n,y),u=!1):t.lineTo(n,y)}t.stroke(),t.strokeStyle="#0ff",t.shadowColor="#0ff",t.beginPath(),u=!0;for(let f=0;f<this.accuracyHistory.length;f+=o){const w=this.accuracyHistory[f],n=e+f/this.accuracyHistory.length*a,y=h-w.test*s;u?(t.moveTo(n,y),u=!1):t.lineTo(n,y)}t.stroke(),t.shadowBlur=0,t.font=`${Math.round(10*this.scale)}px monospace`,t.fillStyle="#0f0",t.fillText("Train",e,h+12*this.scale),t.fillStyle="#0ff",t.fillText("Test",e+50*this.scale,h+12*this.scale)}t.restore()}}function U(W){const t=new E(W);return t.start(),{stop:()=>t.stop(),game:t}}export{U as default};
