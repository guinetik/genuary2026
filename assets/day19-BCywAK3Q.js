import{G as U,H as V,k as j,T as R,E as W}from"./index-D3AXu9BF.js";import{FactoredNetwork as B,generateAllPairs as E,splitData as _,calcAccuracy as X}from"./day19.grokking-BLQhquhM.js";import"./day19.utils-DeEDoNyc.js";class z{constructor(t,i,s=4){this.x=t,this.y=i,this.targetX=t,this.targetY=i,this.baseSize=s,this.activation=0,this.isActive=!1,this.isSelected=!1,this.isTarget=!1,this.isError=!1,this.isCorrect=!1,this.spawnScale=1}render(t,i){const{neuronIdle:s,neuronActive:r,neuronBright:o}=i;if(this.isActive){const e=this.baseSize,a=e*1.1,h=.2;t.fillStyle=`rgba(0, 255, 0, ${h})`,t.beginPath(),t.arc(this.x,this.y,a,0,Math.PI*2),t.fill();let l=r;(this.isSelected||this.isTarget)&&(l=o),t.fillStyle=l,t.globalAlpha=1,t.beginPath(),t.arc(this.x,this.y,e,0,Math.PI*2),t.fill(),t.globalAlpha=1}else t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,this.baseSize*.5,0,Math.PI*2),t.fill()}renderGrid(t,i,s=1,r=0,o=1,e=0,a=0,h=0,l=0,n=1){var D;if(this.spawnScale<=.01)return;const{neuronActive:d,neuronBright:c}=i,u=this.spawnScale,S=n,k=((D=p.neuron)==null?void 0:D.baseSize)*o*u*S,f=2*o*u,m=(a*.1+h*.15+l*.1)%1,T=Math.floor((.5+.5*Math.sin(m*6.28))*255),g=Math.floor((.5+.5*Math.sin(m*6.28+2.09))*255),y=Math.floor((.5+.5*Math.sin(m*6.28+4.18))*255);if(!(n>.4)){const O=Math.max(2,f);if(e>.5){const L=l*2%1*(16+4*2)-4,Z=Math.abs(h-L),F=Math.max(0,1-Z/4),Y=.3,H=Y+F*(1-Y),K=O*(1+F*.5);t.fillStyle=`rgb(${Math.floor(T*H)}, ${Math.floor(g*H)}, ${Math.floor(y*H)})`,t.beginPath(),t.arc(this.x,this.y,K,0,Math.PI*2),t.fill()}else t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,O,0,Math.PI*2),t.fill();return}const M=k;let v,b,A;e>.5?(v=T,b=g,A=y):e>.01?(v=Math.floor(T*e),b=Math.floor(255*(1-e)+g*e),A=Math.floor(255*(1-e)+y*e)):(v=0,b=255,A=255),t.fillStyle=`rgba(${v}, ${b}, ${A}, 0.15)`,t.beginPath(),t.arc(this.x,this.y,M*2.2,0,Math.PI*2),t.fill(),t.fillStyle=`rgba(${v}, ${b}, ${A}, 0.25)`,t.beginPath(),t.arc(this.x,this.y,M*1.5,0,Math.PI*2),t.fill(),t.fillStyle=`rgb(${v}, ${b}, ${A})`,t.beginPath(),t.arc(this.x,this.y,M,0,Math.PI*2),t.fill(),t.fillStyle="#fff",t.beginPath(),t.arc(this.x,this.y,M*.55,0,Math.PI*2),t.fill()}renderOutput(t,i,s=0,r=1,o=0){var f;if(this.spawnScale<=.01)return;const e=this.spawnScale,a=p.neuron;this.currentScale===void 0&&(this.currentScale=a.minScale);const h=s>.5?a.maxScale:a.minScale,l=h>this.currentScale?a.growSpeed:a.shrinkSpeed;this.currentScale+=(h-this.currentScale)*Math.min(1,l*.016);const n=this.currentScale,c=((f=p.neuron)==null?void 0:f.baseSize)*r*e*n,u=3*r*e,S=this.isError&&o<.5;if(n<.4){const m=this.isTarget||this.isSelected?.4:.2;t.fillStyle=`rgba(255, 255, 255, ${m})`,t.beginPath(),t.arc(this.x,this.y,Math.max(2,u),0,Math.PI*2),t.fill();return}let w,k;S?(w="#f44",k="rgba(255, 50, 50, 0.3)"):this.isCorrect?(w="#0f0",k="rgba(0, 255, 0, 0.3)"):(w="#fff",k="rgba(255, 255, 255, 0.2)"),t.fillStyle=k,t.beginPath(),t.arc(this.x,this.y,c*1.6,0,Math.PI*2),t.fill(),t.fillStyle=w,t.beginPath(),t.arc(this.x,this.y,c,0,Math.PI*2),t.fill(),t.fillStyle="rgba(100, 100, 100, 0.5)",t.beginPath(),t.arc(this.x,this.y,c*.4,0,Math.PI*2),t.fill()}}class Q{constructor(t,i,s=16,r=16){this.hiddenSize=t,this.nTokens=i,this.gridRows=s,this.gridCols=r,this.gridSize=s*r,this._buildHiddenMapping(),this._buildOutputMapping()}_buildHiddenMapping(){const s=Math.floor((this.gridRows-16)/2),r=Math.floor((this.gridCols-8*2)/2);this.hiddenToGrid=[],this.gridToHidden=new Int16Array(this.gridSize).fill(-1);for(let o=0;o<this.hiddenSize;o++){const e=Math.floor(o/8),a=o%8,h=s+e*2,l=r+a*2,n=[];for(let d=0;d<2;d++)for(let c=0;c<2;c++){const u=h+d,S=l+c;if(u>=0&&u<this.gridRows&&S>=0&&S<this.gridCols){const w=u*this.gridCols+S;n.push(w),this.gridToHidden[w]=o}}this.hiddenToGrid.push(n)}}_buildOutputMapping(){this.tokenToRow=new Int16Array(this.nTokens),this.rowToTokens=[];for(let i=0;i<16;i++)this.rowToTokens.push([]);for(let i=0;i<this.nTokens;i++){const s=Math.floor(i*16/this.nTokens);this.tokenToRow[i]=s,this.rowToTokens[s].push(i)}}getGridCells(t){return this.hiddenToGrid[t]||[]}getOutputRow(t){return this.tokenToRow[t]}getHiddenNeuron(t){return this.gridToHidden[t]}isMapped(t){return this.gridToHidden[t]>=0}getNeuronCenter(t){const s=Math.floor((this.gridRows-16)/2),r=Math.floor((this.gridCols-8*2)/2),o=Math.floor(t/8),e=t%8;return{row:s+o*2+.5,col:r+e*2+.5}}}const p={background:"#000",network:{nTokens:67,embedSize:500,hiddenSize:64,learningRate:.01,weightDecay:1,beta1:.9,beta2:.98,symmetric:!0,trainFraction:.4},training:{batchSize:64,epochsPerFrame:16,showGrokking:!0,useWorker:!0},grid:{rows:16,cols:16,neuronRows:8,neuronCols:8,baseSpacing:38,referenceSize:800},testAnimation:{testDuration:.8,inputToHidden:.2,hiddenToOutput:.2,holdAtPeak:.15,holdResult:.25,maxActiveNeurons:8},synapse:{trailLength:.25,headSize:5,trailWidth:2,glowSize:12,coreAlpha:.3},neuron:{minScale:.15,maxScale:1.2,growSpeed:25,shrinkSpeed:8,baseSize:8},colors:{neuronIdle:"#0a0",neuronActive:"#0f0",neuronBright:"#fff",text:"#0f0",testCase:"rgba(0, 255, 0, 0.3)"}};class q extends U{constructor(t){super(t),this.backgroundColor=p.background}init(){super.init(),console.log("[Day19] Creating FactoredNetwork...");const t=performance.now();try{this.network=new B(p.network),console.log(`[Day19] Network created in ${(performance.now()-t).toFixed(1)}ms`)}catch(n){console.error("[Day19] Failed to create network:",n);return}const{nTokens:i,symmetric:s,trainFraction:r}=p.network,o=E(i,s),e=_(o,r);this.trainData=e.train,this.testData=e.test,console.log(`Generated ${o.length} pairs (symmetric=${s}): ${this.trainData.length} train, ${this.testData.length} test`),this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.trainLoss=0,this.testLoss=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.neuronMapper=new Q(p.network.hiddenSize,p.network.nTokens,p.grid.rows,p.grid.cols),this.currentTestCase=null,this.testCaseIndex=0,this.testTime=0,this.testRunning=!1,this.currentHiddenActivations=null,this.currentOutputActivations=null,this.currentPrediction=null,this.activeHiddenNeurons=[],this.activeGridCells=[],this.nextTestCase=null,this.nextHiddenActivations=null,this.nextActiveNeurons=[],this.nextPrediction=null;const h=Math.min(this.width,this.height)/p.grid.referenceSize;if(this.scale=h*this.zoom,this.gridSpacing=p.grid.baseSpacing*this.scale,this.synapseAnimationTime=0,this.outputFlashes=new Map,this.gridFlashes=new Map,this.activatedGridNeurons=new Set,this.activatedOutputNeurons=new Set,this.inputSynapseTargets=[],this.outputSynapseTargets=[],this.grokMode=0,this.grokThreshold=.6,this.outputNeurons=[],this.outputNeuronsInitialized=!1,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainData.length>0){const n=this.trainData[0];this.network.forward(n.a,n.b)}this.gridOffsetX=0,this.gridOffsetY=0,this.zoom=1,this.targetZoom=1,this.gesture=new V(this.canvas,{onZoom:n=>{const d=n>0?1.1:.9;this.targetZoom=Math.max(.3,Math.min(3,this.targetZoom*d))},pinchZoomFactor:2}),this._onWheel=n=>{n.preventDefault(),n.stopPropagation();const d=n.deltaY>0?.9:1.1;this.targetZoom=Math.max(.3,Math.min(3,this.targetZoom*d))},this.canvas.addEventListener("wheel",this._onWheel,{passive:!1});const l=this.canvas.parentElement;l&&l.addEventListener("wheel",this._onWheel,{passive:!1}),this._onFullscreenChange=()=>{setTimeout(()=>{const n=this.canvas.parentElement;n&&!n.hasAttribute("data-wheel-attached")&&(n.addEventListener("wheel",this._onWheel,{passive:!1}),n.setAttribute("data-wheel-attached","true"))},100)},document.addEventListener("fullscreenchange",this._onFullscreenChange),this.useWorker=p.training.useWorker,this.workerReady=!1,this.workerTraining=!1,this.useWorker&&this.initWorker(),this.inputDots=[],this.outputDots=[],this.fsm=new j({initial:"intro",context:this,states:{intro:{enter:()=>this.startIntroAnimation(),update:n=>this.updateIntro(n)},training:{enter:()=>this.startTraining(),update:n=>this.updateTraining(n)}}}),this.trainingOpacity=0,this.synapseOpacity=0,this.canvas.addEventListener("click",()=>{this.restart()}),this.zoom=1,this.targetZoom=1,this.grokModeOverride=!1,this.originalTestData=null,window.addEventListener("keydown",n=>{(n.key==="g"||n.key==="G")&&(this.grokModeOverride=!this.grokModeOverride,this.grokModeOverride?(this.originalTestData=this.testData,this.testData=[...this.trainData],this.grokMode=1,console.log(`[DEBUG] Grok mode ON - test set = train set (${this.testData.length} examples)`),this.worker&&(this.worker.postMessage({type:"grokMode",enabled:!0}),this.worker.postMessage({type:"syncWeights"}))):(this.originalTestData&&(this.testData=this.originalTestData,this.originalTestData=null),this.grokMode=0,console.log(`[DEBUG] Grok mode OFF - original test set restored (${this.testData.length} examples)`),this.worker&&this.worker.postMessage({type:"grokMode",enabled:!1})))})}initWorker(){try{this.worker=new Worker(new URL("/assets/day19.worker-CiCYPVIj.js",import.meta.url),{type:"module"}),this.worker.onmessage=t=>{const{type:i}=t.data;switch(i){case"state":this.epoch=t.data.epoch,this.trainAccuracy=t.data.trainAccuracy,this.testAccuracy=t.data.testAccuracy,this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.workerTraining=!1,this.workerReady=!0;break;case"forward":this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.cachedOutput=new Float32Array(t.data.outputActivations),this.cachedPrediction=t.data.prediction;break;case"syncWeights":if(this.network&&t.data.weights){const s=t.data.weights;this.network.embed=s.embed,this.network.Whidden=s.Whidden,this.network.Wout=s.Wout,console.log("[Main] Synced weights from worker"),this._weightsSynced=!0}break}},this.worker.onerror=t=>{console.error("Worker error:",t),this.useWorker=!1,this.workerReady=!1},this.worker.postMessage({type:"init",data:{config:p.network}}),console.log("Web Worker initialized for training")}catch(t){console.warn("Failed to create Web Worker, falling back to main thread:",t),this.useWorker=!1}}startIntroAnimation(){const t=this.width/2,i=this.height/2,{rows:s,cols:r}=p.grid;this.pendingTweens=0,this.gridOffsetX=this.width/2-r*this.gridSpacing/2,this.gridOffsetY=this.height/2-s*this.gridSpacing/2,this.gridNeurons=[];for(let e=0;e<s;e++)for(let a=0;a<r;a++){const h=this.gridOffsetX+a*this.gridSpacing,l=this.gridOffsetY+e*this.gridSpacing,n=new z(t,i,4*this.scale);n.targetX=h,n.targetY=l,n.spawnScale=0,this.gridNeurons.push(n);const c=Math.sqrt(Math.pow(a-r/2,2)+Math.pow(e-s/2,2))*.04;this.pendingTweens++,R.to(n,{x:h,y:l,spawnScale:1},.4,W.easeOutBack,{delay:.1+c,onComplete:()=>this.onTweenComplete()})}const o=r*this.gridSpacing;t-o/2-100*this.scale,t+o/2+100*this.scale,this.inputDots=[];for(let e=0;e<14;e++){const a={x:t,y:i,spawnScale:0};this.inputDots.push(a),this.pendingTweens++,R.to(a,{spawnScale:1},.3,W.easeOutBack,{delay:.05+e*.01,onComplete:()=>this.onTweenComplete()})}this.outputDots=[];for(let e=0;e<7;e++){const a={x:t,y:i,spawnScale:0};this.outputDots.push(a),this.pendingTweens++,R.to(a,{spawnScale:1},.3,W.easeOutBack,{delay:.1+e*.01,onComplete:()=>this.onTweenComplete()})}}onTweenComplete(){this.pendingTweens--,this.pendingTweens<=0&&this.fsm.is("intro")&&this.fsm.setState("training")}updateIntro(t){}startTraining(){this.trainingOpacity=0,this.synapseOpacity=0,R.to(this,{trainingOpacity:1},.8,W.easeOutQuad),R.to(this,{synapseOpacity:1},1.5,W.easeInOutQuad,{delay:.5})}updateTraining(t){R.updateAll(t),this.trainNetwork()}restart(){this.network=new B(p.network);const{nTokens:t,symmetric:i,trainFraction:s}=p.network,r=E(t,i),o=_(r,s);this.trainData=o.train,this.testData=o.test,this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.grokMode=0,this.grokModeOverride=!1,this.outputNeuronsInitialized=!1,this.outputNeuronsKeys=null,this.gridNeurons=null,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainingOpacity=0,this.synapseOpacity=0,this.testTime=0,this.testRunning=!1,this.testCaseIndex=0,this.currentTestCase=null,this.currentHiddenActivations=null,this.currentOutputActivations=null,this.currentPrediction=null,this.activeHiddenNeurons=[],this.activeGridCells=[],this.predictionRow=-1,this.targetRow=-1,this.nextTestCase=null,this.nextHiddenActivations=null,this.nextActiveNeurons=[],this.nextPrediction=null,this.useWorker&&this.worker&&(this.workerReady=!1,this.workerTraining=!1,this.worker.postMessage({type:"reset",data:{config:p.network}})),this.zoom=1,this.targetZoom=1,R.killAll(),this.fsm.setState("intro")}update(t){super.update(t),this.zoom+=(this.targetZoom-this.zoom)*.15;const s=Math.min(this.width,this.height)/p.grid.referenceSize;this.scale=s*this.zoom,this.gridSpacing=p.grid.baseSpacing*this.scale,this.gridOffsetX=this.width/2-p.grid.cols*this.gridSpacing/2,this.gridOffsetY=this.height/2-p.grid.rows*this.gridSpacing/2,this.fsm.update(t),this.animTime+=t,this.updateTestCaseAnimation(t)}updateTestCaseAnimation(t){if(!this.fsm.is("training"))return;const i=p.testAnimation;if(!this.testRunning){this.startNewTestCase();return}this.testTime+=t,this.testTime>=i.testDuration&&this.startNewTestCase()}preloadNextTest(){if(this.testData.length===0)return;const t=(this.testCaseIndex+1)%this.testData.length;this.nextTestCase=this.testData[t];const{probs:i}=this.network.forward(this.nextTestCase.a,this.nextTestCase.b);this.nextHiddenActivations=new Float32Array(this.network._actualHiddenActivations);let s=0,r=i[0];for(let h=1;h<i.length;h++)i[h]>r&&(r=i[h],s=h);this.nextPrediction=s;const o=p.testAnimation.maxActiveNeurons,e=this.nextHiddenActivations,a=[];for(let h=0;h<e.length;h++)e[h]>.01&&a.push({idx:h,val:e[h]});a.sort((h,l)=>l.val-h.val),this.nextActiveNeurons=a.slice(0,o).map(h=>h.idx)}startNewTestCase(){if(this.testData.length!==0){if(this.nextTestCase)this.testCaseIndex=(this.testCaseIndex+1)%this.testData.length,this.currentTestCase=this.nextTestCase,this.currentHiddenActivations=this.nextHiddenActivations,this.currentPrediction=this.nextPrediction,this.activeHiddenNeurons=this.nextActiveNeurons,this.cachedPrediction=this.nextPrediction;else{this.testCaseIndex=0,this.currentTestCase=this.testData[0];const{probs:t}=this.network.forward(this.currentTestCase.a,this.currentTestCase.b);this.currentHiddenActivations=new Float32Array(this.network._actualHiddenActivations),this.cachedOutput=t;let i=0,s=t[0];for(let e=1;e<t.length;e++)t[e]>s&&(s=t[e],i=e);this.currentPrediction=i,this.cachedPrediction=i;const r=p.testAnimation.maxActiveNeurons,o=[];for(let e=0;e<this.currentHiddenActivations.length;e++)this.currentHiddenActivations[e]>.01&&o.push({idx:e,val:this.currentHiddenActivations[e]});o.sort((e,a)=>a.val-e.val),this.activeHiddenNeurons=o.slice(0,r).map(e=>e.idx)}this.activeGridCells=[];for(const t of this.activeHiddenNeurons){const i=this.neuronMapper.getGridCells(t);if(i.length>0){const s=i[Math.floor(Math.random()*i.length)];this.activeGridCells.push(s)}}this.predictionRow=this.currentPrediction!==null?this.neuronMapper.getOutputRow(this.currentPrediction):-1,this.targetRow=this.currentTestCase?this.neuronMapper.getOutputRow(this.currentTestCase.target):-1,this.testTime=0,this.testRunning=!0,this.outputNeuronsInitialized=!1,this.useWorker&&this.workerReady&&this.worker.postMessage({type:"forward",data:{a:this.currentTestCase.a,b:this.currentTestCase.b}}),this.preloadNextTest()}}trainNetwork(){const{epochsPerFrame:t,batchSize:i}=p.training,{nTokens:s}=p.network;if(this.useWorker&&this.workerReady&&!this.workerTraining){if(this.workerTraining=!0,this.worker.postMessage({type:"train",data:{epochsPerFrame:t,batchSize:i}}),this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokModeOverride){const r=this.trainAccuracy>=.95,e=r&&this.testAccuracy>=this.grokThreshold?1:0,a=this.grokMode>.5;this.grokMode+=(e-this.grokMode)*.05,!a&&this.grokMode>.5&&(this.currentTestCase=null,this.cachedOutput=null,this.cachedPrediction=null,this.useWorker&&this.workerReady&&!this._weightsSynced&&this.worker.postMessage({type:"syncWeights"})),r&&this.useWorker&&this.workerReady&&(!this._lastWeightSync||Date.now()-this._lastWeightSync>5e3)&&(this._lastWeightSync=Date.now(),this.worker.postMessage({type:"syncWeights"}))}return}if(!this.useWorker){this.network.resetGradients();for(let r=0;r<t;r++){for(let o=0;o<this.trainData.length;o++){const e=this.trainData[o],{cache:a}=this.network.forward(e.a,e.b);this.network.backward(e.target,a)}this.network.applyAdamW(this.trainData.length),this.epoch++}if(this.epoch%20===0){const r=this.trainData.slice(0,Math.min(100,this.trainData.length)),o=this.testData.slice(0,Math.min(100,this.testData.length));this.trainAccuracy=X(this.network,r),this.testAccuracy=X(this.network,o)}if(this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokkingDetected&&this.epoch>100){const r=this.accuracyHistory.slice(-50);if(r.length>=50){const o=r[0].test,e=r[r.length-1].test;this.trainAccuracy>.8&&e-o>.3&&(this.grokkingDetected=!0,this.grokkingEpoch=this.epoch)}}}}render(){const t=this.ctx,i=this.width,s=this.height;t.fillStyle="rgba(0, 0, 0, 0.2)",t.fillRect(0,0,i,s),this.updateOutputNeuronState(),this.drawSynapses(t),this.drawNeuronGrid(t),this.drawInputOutputNeurons(t),this.drawInputOutput(t),this.drawStats(t)}drawNeuronGrid(t){const{rows:i,cols:s}=p.grid,r=this.gridSpacing,o=this.fsm.is("intro"),e=this._lastSpacing&&Math.abs(this._lastSpacing-r)>1;if(this._lastSpacing=r,!this.gridNeurons||this.gridNeurons.length!==i*s||e&&!o){this.gridNeurons=[];for(let f=0;f<i;f++)for(let m=0;m<s;m++){const T=this.gridOffsetX+m*r,g=this.gridOffsetY+f*r;this.gridNeurons.push(new z(T,g,4*this.scale))}}const a=new Map;if(this.activeGridCells)for(let f=0;f<this.activeGridCells.length;f++)a.set(this.activeGridCells[f],f);const h=p.testAnimation,l=p.neuron,n=this.testTime||0,d=h.inputToHidden,c=d+h.hiddenToOutput,u=h.holdAtPeak,S=c+u,w=Math.min(1,n/d),k=n>S?(n-S)/h.holdResult:0;for(let f=0;f<i;f++)for(let m=0;m<s;m++){const T=f*s+m,g=this.gridNeurons[T];g.x=this.gridOffsetX+m*r,g.y=this.gridOffsetY+f*r;const y=this.neuronMapper.isMapped(T),C=a.get(T),M=C!==void 0;g.currentScale===void 0&&(g.currentScale=l.minScale);let v=l.minScale;if(o)v=l.minScale;else if(!y)v=l.minScale;else if(M&&this.testRunning){const A=C/this.activeGridCells.length*.3;if(Math.max(0,(w-A)/(1-A))>=.98)if(k>0){const O=(this.activeGridCells.length-1-C)/this.activeGridCells.length*.5,P=Math.max(0,(k-O)/(1-O));v=l.maxScale-(l.maxScale-l.minScale)*Math.min(1,P)}else v=l.maxScale;else v=l.minScale}else v=l.minScale;const b=v>g.currentScale?l.growSpeed:l.shrinkSpeed;g.currentScale+=(v-g.currentScale)*Math.min(1,b*.016),g.activation=(g.currentScale-l.minScale)/(l.maxScale-l.minScale),g.isActive=g.currentScale>l.minScale+.1,g.renderGrid(t,p.colors,1,g.activation,this.scale,this.grokMode,f,m,this.animTime,g.currentScale)}}updateOutputNeuronState(){if(!this.currentTestCase||!this.fsm.is("training"))return;const t=this.width/2,i=p.grid.cols*this.gridSpacing,s=t+i/2+50*this.scale,r=this.cachedOutput||this.currentOutputActivations,o=this.cachedPrediction??this.currentPrediction,e=16,a=this.gridSpacing,h=this.gridOffsetY;if(!this.outputNeurons||this.outputNeurons.length!==e){this.outputNeurons=[];for(let c=0;c<e;c++){const u=h+c*a;this.outputNeurons.push(new z(s,u,4*this.scale))}}const l=o!=null?this.neuronMapper.getOutputRow(o):-1,n=this.currentTestCase.target!==void 0?this.neuronMapper.getOutputRow(this.currentTestCase.target):-1,d=new Float32Array(e);if(r)for(let c=0;c<r.length;c++){const u=this.neuronMapper.getOutputRow(c);r[c]>d[u]&&(d[u]=r[c])}for(let c=0;c<e;c++){const u=this.outputNeurons[c];u.x=s,u.y=h+c*a,u.isTarget=c===n,u.isSelected=c===l,u.activation=d[c]}}drawInputOutputNeurons(t){if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0||!this.outputNeurons||this.outputNeurons.length===0)return;t.save(),t.globalAlpha=this.trainingOpacity;const i=16,s=p.testAnimation,r=this.testTime||0,o=s.inputToHidden,e=r>o?Math.min(1,(r-o)/s.hiddenToOutput):0,a=this.cachedPrediction??this.currentPrediction,h=a!=null?this.neuronMapper.getOutputRow(a):-1,l=this.targetRow;for(let n=0;n<i;n++){const d=this.outputNeurons[n];let c=0;this.testRunning&&e>0&&(n===h||n===l)&&(c=Math.max(0,(e-.3)/.7)>=.98?1:0),d.activation=c;const u=h===l,S=n===h,w=n===l;d.isError=!1,d.isCorrect=!1,c>.1&&(u&&S?d.isCorrect=!0:u||(S?d.isError=!0:w&&(d.isCorrect=!0))),d.renderOutput(t,p.colors,c,this.scale,this.grokMode)}t.restore()}drawTronSynapse(t,i,s,r,o,e,a="#0ff",h=!0){if(e<=0)return;const l=p.synapse,n=this.scale,d=1-Math.pow(1-Math.min(1,e),2),c=i+(r-i)*d,u=s+(o-s)*d,S=Math.max(0,d-l.trailLength),w=i+(r-i)*S,k=s+(o-s)*S,f=a==="#0ff",m=0,T=255,g=f?255:0;if(e<1){const y=t.createLinearGradient(w,k,c,u);y.addColorStop(0,`rgba(${m}, ${T}, ${g}, 0)`),y.addColorStop(.5,`rgba(${m}, ${T}, ${g}, 0.15)`),y.addColorStop(1,`rgba(${m}, ${T}, ${g}, 0.4)`),t.strokeStyle=y,t.lineWidth=l.glowSize*n*(h?1:.6),t.lineCap="round",t.beginPath(),t.moveTo(w,k),t.lineTo(c,u),t.stroke()}if(e<1){const y=t.createLinearGradient(w,k,c,u);y.addColorStop(0,`rgba(${m}, ${T}, ${g}, 0)`),y.addColorStop(.3,`rgba(${m}, ${T}, ${g}, 0.6)`),y.addColorStop(1,`rgba(${m}, ${T}, ${g}, 1)`),t.strokeStyle=y,t.lineWidth=l.trailWidth*n*(h?1:.7),t.beginPath(),t.moveTo(w,k),t.lineTo(c,u),t.stroke()}if(e>0){const y=Math.min(d,1),C=i+(r-i)*y,M=s+(o-s)*y;t.strokeStyle=`rgba(${m}, ${T}, ${g}, ${l.coreAlpha*(h?1:.5)})`,t.lineWidth=1*n,t.beginPath(),t.moveTo(i,s),t.lineTo(C,M),t.stroke()}if(e>0&&e<1){const y=t.createRadialGradient(c,u,0,c,u,l.headSize*2*n);y.addColorStop(0,"rgba(255, 255, 255, 0.9)"),y.addColorStop(.3,`rgba(${m}, ${T}, ${g}, 0.6)`),y.addColorStop(1,`rgba(${m}, ${T}, ${g}, 0)`),t.fillStyle=y,t.beginPath(),t.arc(c,u,l.headSize*2*n,0,Math.PI*2),t.fill(),t.fillStyle="#fff",t.beginPath(),t.arc(c,u,l.headSize*.5*n,0,Math.PI*2),t.fill()}}drawSynapses(t){if(!this.currentTestCase||!this.fsm.is("training")||!this.testRunning||this.synapseOpacity<=0)return;t.save(),t.globalAlpha=this.synapseOpacity;const i=this.width/2,s=this.height/2,r=p.grid.cols*this.gridSpacing,{cols:o}=p.grid,e=this.gridSpacing,a=p.testAnimation,h=this.testTime,l=a.inputToHidden,n=Math.min(1,h/l),d=h>l?Math.min(1,(h-l)/a.hiddenToOutput):0,c=i-r/2-100*this.scale,u=c,S=s-40*this.scale,w=c,k=s+40*this.scale,f=i+r/2+50*this.scale,m=this.gridSpacing,T=this.gridOffsetY;if(n>0&&this.activeGridCells.length>0)for(let g=0;g<this.activeGridCells.length;g++){const y=this.activeGridCells[g],C=Math.floor(y/o),M=y%o,v=this.gridOffsetX+M*e,b=this.gridOffsetY+C*e,A=g%2===0,D=A?u:w,O=A?S:k,P=g/this.activeGridCells.length*.3,$=Math.max(0,(n-P)/(1-P));this.drawTronSynapse(t,D,O,v,b,$,"#0ff",!0)}if(d>0&&this.activeGridCells.length>0){const g=this.cachedPrediction??this.currentPrediction,y=g!=null?this.neuronMapper.getOutputRow(g):-1,C=this.targetRow;for(let M=0;M<this.activeGridCells.length;M++){const v=this.activeGridCells[M],b=Math.floor(v/o),A=v%o,D=this.gridOffsetX+A*e,O=this.gridOffsetY+b*e;if(y>=0){const P=f,$=T+y*m,N=M/this.activeGridCells.length*.3,I=Math.max(0,(d-N)/(1-N));this.drawTronSynapse(t,D,O,P,$,I,"#0ff",!0)}if(C>=0&&C!==y){const P=f,$=T+C*m,N=M/this.activeGridCells.length*.3,I=Math.max(0,(d-N)/(1-N));this.drawTronSynapse(t,D,O,P,$,I,"#0f0",!1)}}}t.restore()}drawInputOutput(t){var v,b;if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const{text:i,neuronActive:s,neuronBright:r}=p.colors,o=this.currentTestCase.a??((v=this.currentTestCase.original)==null?void 0:v[0])??0,e=this.currentTestCase.b??((b=this.currentTestCase.original)==null?void 0:b[1])??0,a=this.currentTestCase.target,h=this.cachedPrediction??this.network.predict(o,e),l=h===a,n=this.width/2,d=this.height/2,c=p.grid.cols*this.gridSpacing;p.grid.rows*this.gridSpacing;const u=n-c/2-100*this.scale,S=n+c/2+150*this.scale,w=4*this.scale,k=18*this.scale,f=10,m=d-40*this.scale;this.drawNumberAsDots(t,o,u,m,w,k,f,s),t.fillStyle=i,t.font=`bold ${Math.round(32*this.scale)}px monospace`,t.textAlign="center",t.textBaseline="middle",t.fillText("+",u,d);const T=d+40*this.scale;this.drawNumberAsDots(t,e,u,T,w,k,f,s),this.drawNumberAsDots(t,a,S,d,w,k,f,r);const g=40*this.scale,C=40*this.scale+22*this.scale*6+60*this.scale+30*this.scale;t.textAlign="left",t.font=`bold ${Math.round(14*this.scale)}px monospace`,t.fillStyle=i;const M=o+e;t.fillText(`${o} + ${e} = ${M}`,g,C),t.font=`${Math.round(12*this.scale)}px monospace`,t.fillText(`mod ${p.network.nTokens} = ${a}`,g,C+18*this.scale),t.font=`bold ${Math.round(12*this.scale)}px monospace`,t.fillStyle=l?"#0ff":"#f00",t.fillText(`Predicted: ${h} ${l?"✓":"✗"}`,g,C+36*this.scale),t.restore()}drawNumberAsDots(t,i,s,r,o,e,a,h){const l=p.network.nTokens,n=Math.max(1,Math.ceil(Math.log2(l))),d=[];let c=i;for(let w=n-1;w>=0;w--){const k=c>>w&1;d.push(k)}const u=Math.ceil(n/a),S=r-(u-1)*e/2;t.globalAlpha=1;for(let w=0;w<n;w++){const k=d[w],f=Math.floor(w/a),m=w%a,g=(Math.min(a,n-f*a)-1)*e,y=s-g/2+m*e,C=S+f*e,M=new z(y,C,o);M.isActive=k===1,M.activation=k===1?1:0,M.render(t,p.colors)}}drawStats(t){if(!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const i=40*this.scale,s=40*this.scale,r=22*this.scale;if(t.fillStyle="#888",t.font=`${Math.round(14*this.scale)}px monospace`,t.textAlign="left",t.textBaseline="top",t.fillText(`Epoch: ${this.epoch}`,i,s),t.fillText(`Train: ${(this.trainAccuracy*100).toFixed(1)}%`,i,s+r),t.fillText(`Test: ${(this.testAccuracy*100).toFixed(1)}%`,i,s+r*2),this.grokMode>.5?(t.fillStyle="#f0f",t.fillText("✨ GROKKED!",i,s+r*3)):this.grokkingDetected&&(t.fillStyle="#0ff",t.fillText("✓ GROKKING!",i,s+r*3)),this.accuracyHistory.length>2){const o=150*this.scale,e=50*this.scale,a=i,h=s+r*6;t.fillStyle="rgba(0, 0, 0, 0.7)",t.fillRect(a-5,h-e-5,o+10,e+10),t.strokeStyle="rgba(0, 255, 0, 0.3)",t.lineWidth=1,t.strokeRect(a-5,h-e-5,o+10,e+10),t.strokeStyle="rgba(255, 255, 255, 0.15)",t.beginPath(),t.moveTo(a,h-e*.5),t.lineTo(a+o,h-e*.5),t.stroke();const l=Math.max(1,Math.floor(this.accuracyHistory.length/100));t.strokeStyle="#0f0",t.lineWidth=2.5*this.scale,t.shadowColor="#0f0",t.shadowBlur=4,t.beginPath();let n=!0;for(let d=0;d<this.accuracyHistory.length;d+=l){const c=this.accuracyHistory[d],u=a+d/this.accuracyHistory.length*o,S=h-c.train*e;n?(t.moveTo(u,S),n=!1):t.lineTo(u,S)}t.stroke(),t.strokeStyle="#0ff",t.shadowColor="#0ff",t.beginPath(),n=!0;for(let d=0;d<this.accuracyHistory.length;d+=l){const c=this.accuracyHistory[d],u=a+d/this.accuracyHistory.length*o,S=h-c.test*e;n?(t.moveTo(u,S),n=!1):t.lineTo(u,S)}t.stroke(),t.shadowBlur=0,t.font=`${Math.round(10*this.scale)}px monospace`,t.fillStyle="#0f0",t.fillText("Train",a,h+12*this.scale),t.fillStyle="#0ff",t.fillText("Test",a+50*this.scale,h+12*this.scale)}t.restore()}stop(){if(super.stop(),this.gesture&&this.gesture.destroy(),this._onWheel){this.canvas.removeEventListener("wheel",this._onWheel);const t=this.canvas.parentElement;t&&(t.removeEventListener("wheel",this._onWheel),t.removeAttribute("data-wheel-attached"))}this._onFullscreenChange&&document.removeEventListener("fullscreenchange",this._onFullscreenChange)}}function it(G){const t=new q(G);return t.start(),{stop:()=>t.stop(),game:t}}export{it as default};
