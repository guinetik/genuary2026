(function(){"use strict";class x{constructor(e){this.nTokens=e.nTokens||16,this.embedSize=e.embedSize||128,this.hiddenSize=e.hiddenSize||24,this.learningRate=e.learningRate||.001,this.weightDecay=e.weightDecay||1,this.beta1=e.beta1||.9,this.beta2=e.beta2||.98,this.epsilon=1e-8;const a=Math.sqrt(2/this.nTokens),t=Math.sqrt(2/this.embedSize),s=Math.sqrt(2/this.hiddenSize);this.embed=this.initMatrix(this.nTokens,this.embedSize,a),this.Whidden=this.initMatrix(this.embedSize,this.hiddenSize,t),this.Wout=this.initMatrix(this.hiddenSize,this.embedSize,s),this._actualHiddenActivations=new Float32Array(this.hiddenSize),this.hiddenActivations=new Float32Array(256),this.outputActivations=new Float32Array(this.nTokens),this.weights1=null,this.weights2=null,this.initAdamState(),this.adamT=0}initMatrix(e,a,t){const s=[];for(let h=0;h<e;h++){s[h]=new Float32Array(a);for(let r=0;r<a;r++)s[h][r]=(Math.random()*2-1)*t}return s}initAdamState(){this.m_embed=this.embed.map(e=>new Float32Array(e.length)),this.v_embed=this.embed.map(e=>new Float32Array(e.length)),this.m_Whidden=this.Whidden.map(e=>new Float32Array(e.length)),this.v_Whidden=this.Whidden.map(e=>new Float32Array(e.length)),this.m_Wout=this.Wout.map(e=>new Float32Array(e.length)),this.v_Wout=this.Wout.map(e=>new Float32Array(e.length)),this.grad_embed=this.embed.map(e=>new Float32Array(e.length)),this.grad_Whidden=this.Whidden.map(e=>new Float32Array(e.length)),this.grad_Wout=this.Wout.map(e=>new Float32Array(e.length)),this.gradCount=0}resetGradients(){for(let e=0;e<this.nTokens;e++)this.grad_embed[e].fill(0);for(let e=0;e<this.embedSize;e++)this.grad_Whidden[e].fill(0);for(let e=0;e<this.hiddenSize;e++)this.grad_Wout[e].fill(0);this.gradCount=0}forward(e,a){const t=this.embed[e],s=this.embed[a],h=new Float32Array(this.hiddenSize),r=new Float32Array(this.hiddenSize);for(let c=0;c<this.hiddenSize;c++){let p=0,g=0;for(let z=0;z<this.embedSize;z++)p+=t[z]*this.Whidden[z][c],g+=s[z]*this.Whidden[z][c];h[c]=p,r[c]=g}const n=new Float32Array(this.hiddenSize),i=new Float32Array(this.hiddenSize);for(let c=0;c<this.hiddenSize;c++)i[c]=h[c]+r[c],n[c]=Math.max(0,i[c]);this._actualHiddenActivations=n,this._updateGridActivations();const d=new Float32Array(this.embedSize);for(let c=0;c<this.embedSize;c++){let p=0;for(let g=0;g<this.hiddenSize;g++)p+=n[g]*this.Wout[g][c];d[c]=p}const b=new Float32Array(this.nTokens);for(let c=0;c<this.nTokens;c++){let p=0;for(let g=0;g<this.embedSize;g++)p+=d[g]*this.embed[c][g];b[c]=p}const u=this.softmax(b);return this.outputActivations=u,{probs:u,hidden:n,cache:{a:e,b:a,embedded_a:t,embedded_b:s,hidden_a:h,hidden_b:r,hidden_preact:i,hidden:n,out:d,logits:b,probs:u}}}softmax(e){let a=e[0];for(let r=1;r<e.length;r++)e[r]>a&&(a=e[r]);const t=new Float32Array(e.length);let s=0;for(let r=0;r<e.length;r++)t[r]=Math.exp(e[r]-a),s+=t[r];const h=new Float32Array(e.length);for(let r=0;r<e.length;r++)h[r]=t[r]/s;return h}backward(e,a){const{a:t,b:s,embedded_a:h,embedded_b:r,hidden_preact:n,hidden:i,out:d,probs:b}=a,u=new Float32Array(this.nTokens);for(let o=0;o<this.nTokens;o++)u[o]=b[o]-(o===e?1:0);const v=new Float32Array(this.embedSize);for(let o=0;o<this.embedSize;o++){let W=0;for(let m=0;m<this.nTokens;m++)W+=u[m]*this.embed[m][o],this.grad_embed[m][o]+=u[m]*d[o];v[o]=W}const c=new Float32Array(this.hiddenSize);for(let o=0;o<this.hiddenSize;o++){let W=0;for(let m=0;m<this.embedSize;m++)this.grad_Wout[o][m]+=i[o]*v[m],W+=v[m]*this.Wout[o][m];c[o]=W}const p=new Float32Array(this.hiddenSize);for(let o=0;o<this.hiddenSize;o++)p[o]=n[o]>0?c[o]:0;const g=new Float32Array(this.embedSize),z=new Float32Array(this.embedSize);for(let o=0;o<this.embedSize;o++){let W=0;for(let m=0;m<this.hiddenSize;m++)this.grad_Whidden[o][m]+=h[o]*p[m],this.grad_Whidden[o][m]+=r[o]*p[m],W+=p[m]*this.Whidden[o][m];g[o]=W,z[o]=W}for(let o=0;o<this.embedSize;o++)this.grad_embed[t][o]+=g[o],this.grad_embed[s][o]+=z[o];this.gradCount++}applyAdamW(e){if(this.gradCount===0)return;this.adamT++;const a=this.learningRate,t=this.weightDecay,s=1/e,h=1-Math.pow(this.beta1,this.adamT),r=1-Math.pow(this.beta2,this.adamT);for(let n=0;n<this.nTokens;n++)for(let i=0;i<this.embedSize;i++){const d=this.grad_embed[n][i]*s;this.m_embed[n][i]=this.beta1*this.m_embed[n][i]+(1-this.beta1)*d,this.v_embed[n][i]=this.beta2*this.v_embed[n][i]+(1-this.beta2)*d*d;const b=this.m_embed[n][i]/h,u=this.v_embed[n][i]/r;this.embed[n][i]-=a*(b/(Math.sqrt(u)+this.epsilon)+t*this.embed[n][i]),this.grad_embed[n][i]=0}for(let n=0;n<this.embedSize;n++)for(let i=0;i<this.hiddenSize;i++){const d=this.grad_Whidden[n][i]*s;this.m_Whidden[n][i]=this.beta1*this.m_Whidden[n][i]+(1-this.beta1)*d,this.v_Whidden[n][i]=this.beta2*this.v_Whidden[n][i]+(1-this.beta2)*d*d;const b=this.m_Whidden[n][i]/h,u=this.v_Whidden[n][i]/r;this.Whidden[n][i]-=a*(b/(Math.sqrt(u)+this.epsilon)+t*this.Whidden[n][i]),this.grad_Whidden[n][i]=0}for(let n=0;n<this.hiddenSize;n++)for(let i=0;i<this.embedSize;i++){const d=this.grad_Wout[n][i]*s;this.m_Wout[n][i]=this.beta1*this.m_Wout[n][i]+(1-this.beta1)*d,this.v_Wout[n][i]=this.beta2*this.v_Wout[n][i]+(1-this.beta2)*d*d;const b=this.m_Wout[n][i]/h,u=this.v_Wout[n][i]/r;this.Wout[n][i]-=a*(b/(Math.sqrt(u)+this.epsilon)+t*this.Wout[n][i]),this.grad_Wout[n][i]=0}this.gradCount=0}predict(e,a){const{probs:t}=this.forward(e,a);let s=0,h=t[0];for(let r=1;r<t.length;r++)t[r]>h&&(h=t[r],s=r);return s}_updateGridActivations(){const a=this._actualHiddenActivations;if(this.hiddenSize===256)for(let t=0;t<256;t++)this.hiddenActivations[t]=a[t];else if(this.hiddenSize<256)for(let t=0;t<256;t++)this.hiddenActivations[t]=a[t%this.hiddenSize];else{const t=this.hiddenSize/256;for(let s=0;s<256;s++)this.hiddenActivations[s]=a[Math.floor(s*t)]}}getGridActivations(){return new Float32Array(this.hiddenActivations)}}function j(f,e=!0){const a=[];for(let t=0;t<f;t++)for(let s=0;s<f;s++){if(e&&t>s)continue;const h=(t+s)%f;a.push({a:t,b:s,target:h,original:[t,s]})}return a}function D(f,e=.4){const a=[...f];for(let s=a.length-1;s>0;s--){const h=Math.floor(Math.random()*(s+1));[a[s],a[h]]=[a[h],a[s]]}const t=Math.floor(a.length*e);return{train:a.slice(0,t),test:a.slice(t)}}function M(f,e){let a=0;for(const t of e)f.predict(t.a,t.b)===t.target&&a++;return a/e.length}console.log("[Worker] Factored MLP module loaded");let l=null,_=[],S=[],y=null,A=0,k=0,w=0,T=!1;self.onmessage=function(f){const{type:e,data:a}=f.data;switch(console.log(`[Worker] Received: ${e}`),e){case"init":{try{const t=a.config;console.log("[Worker] Config:",t),l=new x(t);const s=j(t.nTokens,t.symmetric!==!1),h=D(s,t.trainFraction||.4);_=h.train,S=h.test,console.log(`[Worker] Data: ${_.length} train, ${S.length} test`),A=0,k=0,w=0,F(),console.log("[Worker] Init complete")}catch(t){console.error("[Worker] Init error:",t),self.postMessage({type:"error",error:t.message})}break}case"train":{if(!l||T)return;T=!0;const t=performance.now(),{epochsPerFrame:s,batchSize:h=64}=a;for(let n=0;n<s;n++){const i=[];for(let d=0;d<_.length;d++)i.push(d);for(let d=i.length-1;d>0;d--){const b=Math.floor(Math.random()*(d+1));[i[d],i[b]]=[i[b],i[d]]}l.resetGradients();for(let d=0;d<_.length;d++){const b=_[i[d]],{cache:u}=l.forward(b.a,b.b);l.backward(b.target,u)}l.applyAdamW(_.length),A++}k=M(l,_),w=M(l,S);const r=performance.now()-t;A%100===0&&console.log(`[Worker] Epoch ${A}: train=${(k*100).toFixed(1)}%, test=${(w*100).toFixed(1)}% (${r.toFixed(0)}ms)`),T=!1,F();break}case"forward":{if(!l)return;const{a:t,b:s}=a,{probs:h,hidden:r}=l.forward(t,s);self.postMessage({type:"forward",hiddenActivations:l.getGridActivations(),outputActivations:Array.from(h),prediction:l.predict(t,s)});break}case"syncWeights":{if(!l)return;const t=s=>s.map(h=>Array.from(h));self.postMessage({type:"syncWeights",weights:{embed:t(l.embed),Whidden:t(l.Whidden),Wout:t(l.Wout)},config:{nTokens:l.nTokens,embedSize:l.embedSize,hiddenSize:l.hiddenSize}});break}case"reset":{if(!l)return;const t=a.config;l=new x(t);const s=j(t.nTokens,t.symmetric!==!1),h=D(s,t.trainFraction||.4);_=h.train,S=h.test,y=null,A=0,k=0,w=0,F();break}case"grokMode":{f.data.enabled?(y=S,S=[..._],console.log(`[Worker] Grok mode ON - test set = train set (${S.length} examples)`)):(y&&(S=y,y=null),console.log(`[Worker] Grok mode OFF - original test set restored (${S.length} examples)`)),l&&(w=M(l,S),F());break}}};function F(){if(!l)return;const f=S[0]||_[0];f&&l.forward(f.a,f.b),self.postMessage({type:"state",epoch:A,trainAccuracy:k,testAccuracy:w,hiddenActivations:l.getGridActivations(),outputActivations:Array.from(l.outputActivations),hiddenSize:l.hiddenSize,nTokens:l.nTokens})}})();
