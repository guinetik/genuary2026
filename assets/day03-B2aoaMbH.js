import{G as M,P as d}from"./gcanvas.es-Dc5p5ZkO.js";const o={goldenAngle:137.5077640500378,numSeeds:1e3,baseRadiusRatio:.015,spacingRatio:.012,pulseSpeed:1.5,rotationSpeed:.15,waveSpeed:2,waveAmplitudeRatio:.03,hueSpeed:30,saturation:85,mouseRadiusRatio:.25,mouseForceRatio:.15,explosionForceRatio:.5,explosionDecay:.96,centerSizeRatio:.04},x=Math.PI*2,v=o.goldenAngle*Math.PI/180;class R extends M{constructor(t){super(t),this.backgroundColor="#000"}init(){super.init(),d.init(this.ctx),this.time=0,this.hueOffset=0,this.globalRotation=0,this.mouseX=0,this.mouseY=0,this.exploding=!1,this.explosionTime=0;const e=Math.min(this.width,this.height)*o.spacingRatio;this.seeds=[];for(let a=0;a<o.numSeeds;a++){const i=a*v,n=Math.sqrt(a);this.seeds.push({index:a,baseAngle:i,radiusFactor:n,angle:i,radius:n*e,vx:0,vy:0,sizeFactor:Math.max(.3,1-a*5e-4),phase:Math.random()*x})}this.canvas.addEventListener("mousemove",a=>{const i=this.canvas.getBoundingClientRect();this.mouseX=a.clientX-i.left-this.width/2,this.mouseY=a.clientY-i.top-this.height/2}),this.canvas.addEventListener("click",()=>{this.explode()}),this.canvas.addEventListener("mouseleave",()=>{this.mouseX=0,this.mouseY=0})}explode(){this.exploding=!0,this.explosionTime=this.time;const t=Math.min(this.width,this.height),e=t*o.explosionForceRatio,a=t*o.spacingRatio;for(const i of this.seeds){const n=i.radiusFactor*a,h=Math.cos(i.angle)*n,s=Math.sin(i.angle)*n,c=Math.sqrt(h*h+s*s)+1,r=e/Math.sqrt(c+50),l=t*.06;i.vx=h/c*r+(Math.random()-.5)*l,i.vy=s/c*r+(Math.random()-.5)*l}}update(t){super.update(t),this.time+=t,this.hueOffset+=o.hueSpeed*t,this.globalRotation+=o.rotationSpeed*t;const e=Math.min(this.width,this.height),a=e*o.spacingRatio,i=e*o.waveAmplitudeRatio,n=e*o.mouseRadiusRatio,h=e*o.mouseForceRatio;for(const s of this.seeds){const c=s.radiusFactor*a;let r=Math.cos(s.angle)*s.radius,l=Math.sin(s.angle)*s.radius;if(this.exploding){r+=s.vx*t,l+=s.vy*t,s.vx*=o.explosionDecay,s.vy*=o.explosionDecay;const g=Math.cos(s.baseAngle+this.globalRotation)*c,u=Math.sin(s.baseAngle+this.globalRotation)*c,m=g-r,p=u-l;s.vx+=m*2*t,s.vy+=p*2*t,s.angle=Math.atan2(l+s.vy*t,r+s.vx*t),s.radius=Math.sqrt((r+s.vx*t)**2+(l+s.vy*t)**2),this.time-this.explosionTime>3&&(this.exploding=!1)}else{s.angle=s.baseAngle+this.globalRotation;const g=Math.sin(this.time*o.pulseSpeed+s.index*.02)*.1+1,u=Math.sin(this.time*o.waveSpeed-c*.05)*i;s.radius=c*g+u*c/(e*.25);const m=Math.sqrt((r-this.mouseX)**2+(l-this.mouseY)**2);if(m<n){const p=(n-m)/n;s.radius+=p*h*(1-s.index/o.numSeeds),s.angle+=p*.3*Math.sin(this.time*5)}}}}render(){d.shapes.rect(0,0,this.width,this.height,"rgba(0, 0, 0, 0.15)");const t=this.width/2,e=this.height/2;this.drawConnections(t,e),this.drawSeeds(t,e),this.drawCenter(t,e)}drawConnections(t,e){this.ctx.beginPath();for(let a=1;a<Math.min(500,this.seeds.length);a++){const i=this.seeds[a],n=this.seeds[a-1],h=t+Math.cos(n.angle)*n.radius,s=e+Math.sin(n.angle)*n.radius,c=t+Math.cos(i.angle)*i.radius,r=e+Math.sin(i.angle)*i.radius;this.ctx.moveTo(h,s),this.ctx.lineTo(c,r)}d.colors.stroke(`hsla(${this.hueOffset%360}, 70%, 50%, 0.05)`,.5)}drawSeeds(t,e){const i=Math.min(this.width,this.height)*o.baseRadiusRatio;for(let n=this.seeds.length-1;n>=0;n--){const h=this.seeds[n],s=t+Math.cos(h.angle)*h.radius,c=e+Math.sin(h.angle)*h.radius,r=(h.index*.5+this.hueOffset)%360,l=50+Math.sin(this.time*3+h.phase)*15,g=Math.sin(this.time*4+h.index*.1)*.3+1,u=i*h.sizeFactor*g;if(!isFinite(u)||u<=0||!isFinite(s)||!isFinite(c))continue;d.effects.setBlendMode("lighter");const m=d.colors.radialGradient(s,c,0,s,c,u*2,[{offset:0,color:`hsla(${r}, ${o.saturation}%, ${l}%, 0.9)`},{offset:.5,color:`hsla(${r}, ${o.saturation}%, ${l-10}%, 0.4)`},{offset:1,color:`hsla(${r}, ${o.saturation}%, ${l-20}%, 0)`}]);d.shapes.fillCircle(s,c,u*2,m),d.effects.setBlendMode("source-over"),d.shapes.fillCircle(s,c,u*.5,`hsl(${r}, ${o.saturation}%, ${l+20}%)`)}}drawCenter(t,e){d.effects.setBlendMode("lighter");const a=Math.min(this.width,this.height),i=Math.sin(this.time*2)*.3+1,n=a*o.centerSizeRatio*i,h=d.colors.radialGradient(t,e,0,t,e,n,[{offset:0,color:`hsla(${this.hueOffset%360}, 100%, 80%, 0.8)`},{offset:.3,color:`hsla(${(this.hueOffset+30)%360}, 90%, 60%, 0.4)`},{offset:1,color:"transparent"}]);d.shapes.fillCircle(t,e,n,h),d.effects.setBlendMode("source-over")}}function S(f){const t=new R(f);return t.start(),{stop:()=>t.stop(),game:t}}export{S as default};
