import{G as D,i as v,o as g,E as b,P as m,u as A,m as M,v as P,w as x,A as O,x as B,y as E}from"./gcanvas.es-ChtmA8T6.js";class X extends E{constructor(t,e,o={}){super(o),this.radiusX=t,this.radiusY=e,this.width=t*2,this.height=e*2}draw(){super.draw(),this.color&&m.shapes.fillEllipse(0,0,this.radiusX,this.radiusY,0,this.color),this.stroke&&m.shapes.strokeEllipse(0,0,this.radiusX,this.radiusY,0,this.stroke,this.lineWidth)}}class _ extends E{constructor(t={}){super(t),this.baseWidth=t.baseWidth||8,this.height=t.height||18,this.flip=t.flip||!1}draw(){super.draw();const t=this.baseWidth/2,e=this.height,o=this.flip?[{x:-t,y:0},{x:0,y:-e},{x:t,y:0}]:[{x:-t,y:0},{x:0,y:-e},{x:t,y:0}];m.shapes.polygon(o,this.color,this.stroke,this.lineWidth)}}class C extends M{constructor(t,e={}){super(t,e),this.size=e.size||24,this.eyeAngle=0,this.mouthOpen=0,this.puff=1,this.spitEffect={active:!1,direction:0,timer:0},this._buildShapes()}_buildShapes(){this.body=new P({x:0,y:0}),this.head=new x(this.size,{color:"#9b59b6"}),this.body.add(this.head),this.leftHorn=new _({x:-12,y:-14,baseWidth:8,height:18,color:"#6c3483"}),this.rightHorn=new _({x:12,y:-14,baseWidth:8,height:18,flip:!0,color:"#6c3483"}),this.body.add(this.leftHorn),this.body.add(this.rightHorn);const t=-4,e=8;this.leftEyeWhite=new x(6,{x:-e,y:t,color:"#fff"}),this.rightEyeWhite=new x(6,{x:e,y:t,color:"#fff"}),this.body.add(this.leftEyeWhite),this.body.add(this.rightEyeWhite),this.leftPupil=new x(3,{x:-e,y:t,color:"#000"}),this.rightPupil=new x(3,{x:e,y:t,color:"#000"}),this.body.add(this.leftPupil),this.body.add(this.rightPupil),this.closedMouth=new O(8,.2,Math.PI-.2,{y:10,stroke:"rgba(0, 0, 0, 0.8)",lineWidth:3}),this.openMouth=new X(5,5,{y:12,color:"rgba(40, 10, 40, 0.9)",stroke:"rgba(0, 0, 0, 0.8)",lineWidth:3}),this.body.add(this.closedMouth),this.currentMouth="closed"}setEyeAngle(t){this.eyeAngle=t;const e=8,o=t*10;this.leftPupil.x=-e+o,this.rightPupil.x=e+o}setMouthOpen(t){if(this.mouthOpen=t,t>.1&&this.currentMouth==="closed"?(this.body.remove(this.closedMouth),this.body.add(this.openMouth),this.currentMouth="open"):t<=.1&&this.currentMouth==="open"&&(this.body.remove(this.openMouth),this.body.add(this.closedMouth),this.currentMouth="closed"),this.currentMouth==="open"){const e=3+t*4,o=2+t*6;this.openMouth.radiusX=e,this.openMouth.radiusY=o}}startSpitEffect(t){this.spitEffect.active=!0,this.spitEffect.direction=t,this.spitEffect.timer=.08}update(t){super.update(t),this.spitEffect.active&&(this.spitEffect.timer-=t,this.spitEffect.timer<=0&&(this.spitEffect.active=!1))}draw(){super.draw(),m.save(),m.ctx.scale(this.puff,this.puff),this.body.render(),m.restore(),this.spitEffect.active&&this._drawSpitLines()}_drawSpitLines(){const t=this.spitEffect.direction,e=10,o=this.spitEffect.timer/.08,s=m.ctx;s.strokeStyle=`rgba(255, 255, 255, ${o*.9})`,s.lineWidth=3,s.lineCap="round";for(let h=0;h<3;h++){const a=(h-1)*6,i=20+h*8;s.beginPath(),s.moveTo(t*12,e+a*.3),s.lineTo(t*(12+i),e+a),s.stroke()}}}class k extends M{constructor(t,e={}){super(t,e),this.text=e.text||"...",this.targetX=e.targetX||0,this.targetY=e.targetY||0,this.alpha=0,this._buildShapes()}_buildShapes(){this.cloud=new B(70,{color:"rgba(255, 255, 255, 0.95)"}),this.trailCircles=[new x(10,{color:"rgba(255, 255, 255, 0.9)"}),new x(7,{color:"rgba(255, 255, 255, 0.85)"}),new x(4,{color:"rgba(255, 255, 255, 0.8)"})]}draw(){if(super.draw(),this.alpha<=0)return;const t=m.ctx;t.globalAlpha=this.alpha;const e=this.targetX-this.x,o=this.targetY-this.y;for(let s=0;s<this.trailCircles.length;s++){const h=(s+1)/(this.trailCircles.length+1),a=e*h*.6,i=o*h*.6+30;t.save(),t.translate(a,i),this.trailCircles[s].render(),t.restore()}this.cloud.render(),t.fillStyle="#333",t.font="bold 10px 'Fira Code', monospace",t.textAlign="center",t.textBaseline="middle",t.fillText(this.text,0,0),t.globalAlpha=1}}const d={particleSize:20,baseParticles:1e3,baseArea:1920*1080,minParticles:500,maxParticles:3e3,gravity:0,container:{marginX:0,marginY:0},wall:{width:8},demon:{tempThreshold:.5,batchPercent:.02,minBatch:5,maxBatch:30},phases:{entropyDuration:10,exhaustedDuration:8,departureDuration:2,colorTransitionTime:2}};class W extends D{constructor(t){super(t),this.backgroundColor=null,this.demonArrived=!1,this.visuals={leftBgAlpha:0,rightBgAlpha:0,wallProgress:0},this.spitDirection=0,this.gobbleFromDirection=0,this.gobbleTargets=[],this.gobbleProgress=0,this.gobbleDuration=.3,this.gobbleStateTimer=0,this.phaseTimer=0,this.phaseState=new v({initial:"entropy",context:this,states:{entropy:{enter:()=>this._enterEntropy(),update:e=>this._updateEntropy(e)},arrival:{enter:()=>this._enterArrival(),update:e=>this._updateArrival(e)},sorting:{enter:()=>this._enterSorting(),update:e=>this._updateSorting(e)},exhausted:{enter:()=>this._enterExhausted(),update:e=>this._updateExhausted(e)},departure:{enter:()=>this._enterDeparture(),update:e=>this._updateDeparture(e)}}}),this.gobbleState=new v({initial:"idle",context:this,states:{idle:{enter:()=>{this.gobbleTargets=[],this.gobbleProgress=0,this.gobbleStateTimer=.02,this.demon&&this.demon.setMouthOpen(0)},update:e=>this._idleUpdate(e)},gobbling:{enter:()=>{const e=this.bounds.y+this.bounds.h/2;this.gobbleTargets.forEach((h,a)=>{const i=h.x-this.wallX,r=h.y-e;h._gobbleDist=Math.sqrt(i*i+r*r)}),this.gobbleTargets.sort((h,a)=>h._gobbleDist-a._gobbleDist);const o=.03;this.gobbleTargets.forEach((h,a)=>{h._gobbleDelay=a*o,h._arrived=!1});const s=(this.gobbleTargets.length-1)*o;if(this.gobbleDuration=s+.15,this.gobbleElapsed=0,this.demon){const h=1.3+this.gobbleTargets.length*.08;g.to(this.demon,{puff:h},this.gobbleDuration,b.easeOutQuad)}this.gobbleStateTimer=this.gobbleDuration},update:e=>this._gobblingUpdate(e)},holding:{enter:()=>{this.gobbleProgress=1,this.demon&&this.demon.setMouthOpen(0),this.gobbleStateTimer=.05},update:e=>this._holdingUpdate(e)},spitting:{enter:()=>{this.spitElapsed=0,this.spitIndex=0;const e=.03;this.spitDuration=this.gobbleTargets.length*e+.05,this.gobbleStateTimer=this.spitDuration,this.demon&&(g.to(this.demon,{puff:1},this.spitDuration,b.easeOutQuad),this.demon.setMouthOpen(1),this.demon.startSpitEffect(this.spitDirection))},update:e=>this._spittingUpdate(e)}}})}init(){super.init(),m.init(this.ctx),console.log("[Day16] Initializing Maxwell's Demon..."),this._updateBounds(),this.wallX=this.bounds.x+this.bounds.w/2;const e=this.width*this.height/d.baseArea;this.particleCount=Math.floor(Math.min(d.maxParticles,Math.max(d.minParticles,d.baseParticles*e))),console.log(`[Day16] Canvas: ${this.width}x${this.height}, particles: ${this.particleCount}`),this.fluid=new A(this,{maxParticles:this.particleCount,particleSize:d.particleSize,width:this.bounds.w,height:this.bounds.h,bounds:this.bounds,physics:"gas",debug:!1,gravity:d.gravity,heat:{enabled:!1},thermalEquilibrium:!1,heatTransfer:{enabled:!1},particleColor:{r:255,g:255,b:255,a:.9}}),this.fluid.spawn(this.particleCount),this._initParticles();const o=this.fluid.particles.filter(h=>h.custom.fixedTemp>.5).length,s=this.fluid.particles.length-o;console.log(`[Day16] Initial fixedTemps: ${o} hot, ${s} cold (${(o/this.fluid.particles.length*100).toFixed(1)}% hot)`),this.pipeline.add(this.fluid),this.demon=new C(this,{x:this.wallX,y:this.bounds.y+this.bounds.h/2,size:24,visible:!1}),this.pipeline.add(this.demon),this.thoughtBubble=new k(this,{x:this.wallX,y:this.bounds.y+this.bounds.h/2-100,targetX:this.wallX,targetY:this.bounds.y+this.bounds.h/2-30,text:""}),this.pipeline.add(this.thoughtBubble),this._enterEntropy(),console.log("[Day16] Init complete, starting entropy phase")}_initParticles(){for(const t of this.fluid.particles){const e=.1+Math.random()*.8;t.custom.temperature=e,t.custom.fixedTemp=e,t.custom.sorted=!1}}_updateBounds(){const{marginX:t,marginY:e}=d.container;this.bounds={x:t,y:e,w:this.width-t*2,h:this.height-e*2}}update(t){g.updateAll(t),this.phaseState.update(t),super.update(t),this._lockSortedTemperatures(),this._colorByTemperature(),this._enforceTemperatureSpeeds()}_enterEntropy(){console.log("[Day16] Entering ENTROPY phase"),this.phaseTimer=0,this.demonArrived=!1,this.thoughtBubble&&(this.thoughtBubble.alpha=0)}_updateEntropy(t){this.phaseTimer+=t,this.phaseTimer>=d.phases.entropyDuration&&this.phaseState.setState("arrival")}_enterArrival(){this.phaseTimer=0,this.demonArrived=!0,this.demon&&(this.demon.visible=!0,this.demon.scaleX=0,this.demon.scaleY=0,g.to(this.demon,{scaleX:1,scaleY:1},.5,b.easeOutBack)),g.to(this.visuals,{leftBgAlpha:.3},.4,b.easeOutQuad,{delay:.3}),g.to(this.visuals,{rightBgAlpha:.3},.4,b.easeOutQuad,{delay:.5}),g.to(this.visuals,{wallProgress:1},.6,b.easeInOutQuad,{delay:.7})}_updateArrival(t){this.phaseTimer+=t,this.visuals.wallProgress>=1&&this.phaseState.setState("sorting")}_enterSorting(){this.phaseTimer=0,this.gobbleState.setState("idle");let t=0,e=0,o=0,s=0;for(const h of this.fluid.particles){const a=(h.custom.fixedTemp??h.custom.temperature)>.5,i=h.x<this.wallX;i&&a?t++:i&&!a?e++:!i&&a?o++:s++}console.log(`[Day16] Sorting start (fixedTemp): LEFT: ${t} hot + ${e} cold | RIGHT: ${o} hot + ${s} cold`)}_updateSorting(t){this._enforceWall(),this.gobbleState.update(t),this.gobbleState.currentState==="idle"&&this.gobbleTargets.length===0&&this._checkAllSorted()&&(console.log("[Day16] All sorted! Transitioning to exhausted"),this.phaseState.setState("exhausted"))}_enterExhausted(){console.log("[Day16] EXHAUSTED - showing bubble"),this.phaseTimer=0,this.demon&&(this.demon.setEyeAngle(0),this.demon.setMouthOpen(0)),this.thoughtBubble&&(console.log("[Day16] Setting bubble text and alpha"),this.thoughtBubble.text="YOU ARE ALL FREE NOW",this.thoughtBubble.alpha=1)}_updateExhausted(t){this.phaseTimer+=t,this._enforceWall(),this.phaseTimer>=d.phases.exhaustedDuration&&this.phaseState.setState("departure")}_enterDeparture(){this.phaseTimer=0,this.thoughtBubble&&g.to(this.thoughtBubble,{alpha:0},.3,b.easeOutQuad),this.demon&&g.to(this.demon,{scaleX:0,scaleY:0},.5,b.easeInBack,{delay:.3,onComplete:()=>{this.demon.visible=!1}}),g.to(this.visuals,{leftBgAlpha:0},.8,b.easeOutQuad,{delay:.5}),g.to(this.visuals,{rightBgAlpha:0},.8,b.easeOutQuad,{delay:.5}),g.to(this.visuals,{wallProgress:0},.8,b.easeInQuad,{delay:.5})}_updateDeparture(t){this.phaseTimer+=t,this.phaseTimer>=d.phases.departureDuration&&(console.log("[Day16] Departure complete, returning to entropy"),this._randomizeParticleVelocities(),this.phaseState.setState("entropy"))}_checkAllSorted(){for(const t of this.fluid.particles)if(!t.custom.sorted)return!1;return!0}_randomizeParticleVelocities(){for(const t of this.fluid.particles){const e=50+Math.random()*150,o=Math.random()*Math.PI*2;t.vx=Math.cos(o)*e,t.vy=Math.sin(o)*e,t.custom.sorted=!1;const s=.1+Math.random()*.8;t.custom.temperature=s,t.custom.fixedTemp=s}}_enforceWall(){const t=this.wallX,e=d.wall.width/2;for(const o of this.fluid.particles){if(this.gobbleTargets.includes(o))continue;const s=o.x-t;Math.abs(s)<e+d.particleSize/2&&(s>0?(o.x=t+e+d.particleSize/2,o.vx=Math.abs(o.vx)*.8):(o.x=t-e-d.particleSize/2,o.vx=-Math.abs(o.vx)*.8))}}_idleUpdate(t){if(this.gobbleStateTimer-=t,this.gobbleStateTimer>0){this.demon&&(this.demon.eyeAngle*=.95,this.demon.setEyeAngle(this.demon.eyeAngle));return}const{tempThreshold:e,batchPercent:o,minBatch:s,maxBatch:h}=d.demon,a=this.fluid.particles.length,i=Math.min(h,Math.max(s,Math.floor(a*o))),r=[],l=[],u=[];for(const n of this.fluid.particles){const p=n.x-this.wallX,w=Math.abs(p),S=(n.custom.fixedTemp??n.custom.temperature??.5)>e,T=p>0;S&&T||!S&&!T?T?r.push({p:n,dist:w,isHot:S,onRight:!0}):l.push({p:n,dist:w,isHot:S,onRight:!1}):n.custom.sorted||u.push({p:n,dist:w,isHot:S,onRight:T})}r.sort((n,p)=>n.dist-p.dist),l.sort((n,p)=>n.dist-p.dist),u.sort((n,p)=>n.dist-p.dist);let c=[],f=0;if((r.length>0||l.length>0)&&((r.length>l.length||r.length===l.length&&Math.random()>.5)&&r.length>0?(c=r.slice(0,i),f=1):l.length>0?(c=l.slice(0,i),f=-1):(c=r.slice(0,i),f=1)),c.length===0&&u.length>0&&(c=u.slice(0,i),f=c[0].onRight?1:-1),c.length>0){this.gobbleTargets=c.map(p=>(p.p.custom.isHot=p.isHot,p.p)),this.gobbleFromDirection=f;const n=c.filter(p=>p.isHot).length;this.spitDirection=n>c.length/2?-1:1,this.demon&&this.demon.setEyeAngle(this.gobbleFromDirection*.5),this.gobbleState.setState("gobbling")}this.demon&&(this.demon.eyeAngle*=.95,this.demon.setEyeAngle(this.demon.eyeAngle))}_gobblingUpdate(t){this.gobbleStateTimer-=t,this.gobbleElapsed+=t;const e=Math.min(1,Math.max(0,1-this.gobbleStateTimer/this.gobbleDuration));if(this.gobbleProgress=e,this.demon){const i=this.gobbleTargets.filter(l=>l._arrived).length,r=Math.min(1,i*.15+e*.3);this.demon.setMouthOpen(r)}const o=this.bounds.y+this.bounds.h/2,s=this.wallX,h=o+14;for(const i of this.gobbleTargets){if(i._arrived){i.x=s,i.y=h,i.vx=0,i.vy=0;continue}if(this.gobbleElapsed<i._gobbleDelay)continue;const r=s-i.x,l=h-i.y,u=Math.sqrt(r*r+l*l);if(u>8){const c=this.gobbleElapsed-i._gobbleDelay,n=2500+Math.min(1,c/.12)*4e3;i.vx=r/u*n,i.vy=l/u*n}else i.x=s,i.y=h,i.vx=0,i.vy=0,i._arrived=!0}this.gobbleTargets.every(i=>i._arrived)&&(this.gobbleProgress=1,this.gobbleState.setState("holding"))}_holdingUpdate(t){this.gobbleStateTimer-=t;const o=1-this.gobbleStateTimer/.05;for(const s of this.gobbleTargets)s.x=-1e3,s.y=-1e3,s.vx=0,s.vy=0;this.demon&&(o<.4?this.demon.setEyeAngle(this.gobbleFromDirection*.5):o<.7?(this.demon.eyeAngle*=.7,this.demon.setEyeAngle(this.demon.eyeAngle)):this.demon.setEyeAngle(this.spitDirection*.5)),this.gobbleStateTimer<=0&&this.gobbleState.setState("spitting")}_spittingUpdate(t){this.gobbleStateTimer-=t,this.spitElapsed+=t;const e=.03,o=this.bounds.y+this.bounds.h/2,s=this.wallX,h=o+14;for(;this.spitIndex<this.gobbleTargets.length;){const a=this.spitIndex*e;if(this.spitElapsed<a)break;const i=this.gobbleTargets[this.spitIndex];i.x=s,i.y=h;const r=i.custom.isHot?-1:1,l=4e3+Math.random()*1e3,u=(Math.random()-.5)*.2;i.vx=r*l,i.vy=u*l*.3,i.custom.sorted=!0,i.custom.lockedTemp=i.custom.isHot?.9:.02,i.custom.temperature=i.custom.lockedTemp,this.demon&&(this.demon.startSpitEffect(r),this.demon.setEyeAngle(r*.5)),this.spitIndex++}if(this.demon){const a=this.gobbleTargets.length-this.spitIndex,i=Math.min(1,a*.15);this.demon.setMouthOpen(i)}this.gobbleStateTimer<=0&&this.gobbleState.setState("idle")}_lockSortedTemperatures(){for(const t of this.fluid.particles)t.custom.sorted&&t.custom.lockedTemp!==void 0&&(t.custom.temperature=t.custom.lockedTemp)}_enforceTemperatureSpeeds(){for(const s of this.fluid.particles){if(this.gobbleTargets.includes(s)||!s.custom.sorted)continue;const h=Math.sqrt(s.vx*s.vx+s.vy*s.vy);if(h<1||h>600)continue;const i=(s.custom.isHot?450:80)/h;s.vx+=(s.vx*i-s.vx)*.01,s.vy+=(s.vy*i-s.vy)*.01}}_colorByTemperature(){const t=this.phaseState.currentState;let e=1;t==="entropy"&&this.phaseTimer<d.phases.colorTransitionTime&&(e=this.phaseTimer/d.phases.colorTransitionTime);const o=t==="exhausted"||t==="departure";for(const s of this.fluid.particles){const h=s.custom.fixedTemp??s.custom.temperature,a=h>.5,i=Math.floor(255*h),r=Math.floor(80*(1-Math.abs(h-.5)*2)),l=Math.floor(255*(1-h)),u=a?255:0,c=0,f=a?0:255;o||s.custom.sorted?(s.color.r=u,s.color.g=c,s.color.b=f):t==="entropy"&&e<1?(s.color.r=Math.floor(u+(i-u)*e),s.color.g=Math.floor(c+(r-c)*e),s.color.b=Math.floor(f+(l-f)*e)):(s.color.r=i,s.color.g=r,s.color.b=l)}}render(){const t=this.ctx;t.fillStyle="rgba(0, 0, 0, 0.15)",t.fillRect(0,0,this.width,this.height);const{leftBgAlpha:e,rightBgAlpha:o,wallProgress:s}=this.visuals;if(e>0&&(t.fillStyle=`rgba(60, 20, 20, ${e*.3})`,t.fillRect(this.bounds.x,this.bounds.y,this.bounds.w/2,this.bounds.h)),o>0&&(t.fillStyle=`rgba(10, 15, 80, ${o*.3})`,t.fillRect(this.wallX,this.bounds.y,this.bounds.w/2,this.bounds.h)),s>0){t.fillStyle="#666";const h=this.bounds.h*s;t.fillRect(this.wallX-d.wall.width/2,this.bounds.y,d.wall.width,h)}this.pipeline.render(t)}}function I(y){console.log("[Day16] Module loaded, creating game...");const t=new W(y);function e(){y.width>0&&y.height>0?(console.log("[Day16] Canvas ready, starting game"),t.start()):(console.log("[Day16] Canvas not ready, retrying..."),requestAnimationFrame(e))}return e(),{stop:()=>t.stop(),game:t,handlesResize:!0}}export{I as default};
