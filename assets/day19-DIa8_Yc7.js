import{G as et,j as it,T as H,E as U}from"./gcanvas.es-Dc5p5ZkO.js";import{F as Z,s as x,g as tt,c as st}from"./grokking-mlp-NK8p3y84.js";if(typeof window<"u"){const B=document.createElement("script");B.src="https://unpkg.com/gpu.js@2.16.0/dist/gpu-browser.min.js",B.onload=()=>{window.GPU?console.log("GPU.js loaded from CDN"):console.warn("GPU.js loaded but GPU constructor not found, using CPU fallback")},B.onerror=()=>{console.warn("Failed to load GPU.js from CDN, using CPU fallback")},document.head.appendChild(B)}class j{constructor(t,o,e=4){this.x=t,this.y=o,this.targetX=t,this.targetY=o,this.baseSize=e,this.activation=0,this.isActive=!1,this.isSelected=!1,this.isTarget=!1,this.isError=!1,this.spawnScale=1}render(t,o){const{neuronIdle:e,neuronActive:n,neuronBright:r}=o;if(this.isActive){const s=this.baseSize,i=s*1.1,a=.2;t.fillStyle=`rgba(0, 255, 0, ${a})`,t.beginPath(),t.arc(this.x,this.y,i,0,Math.PI*2),t.fill();let h=n;(this.isSelected||this.isTarget)&&(h=r),t.fillStyle=h,t.globalAlpha=1,t.beginPath(),t.arc(this.x,this.y,s,0,Math.PI*2),t.fill(),t.globalAlpha=1}else t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,this.baseSize*.5,0,Math.PI*2),t.fill()}renderGrid(t,o,e=1,n=0,r=1,s=0,i=0,a=0,h=0){if(this.spawnScale<=.01)return;const{neuronActive:p,neuronBright:y}=o,v=Math.min(1,this.activation/e),k=Math.min(1,v+n*.5),A=n>.1,l=this.spawnScale,f=4*r*l,D=2*r*l,Y=(i*.1+a*.15+h*.1)%1,g=Math.floor((.5+.5*Math.sin(Y*6.28))*255),u=Math.floor((.5+.5*Math.sin(Y*6.28+2.09))*255),c=Math.floor((.5+.5*Math.sin(Y*6.28+4.18))*255);if(k<.05&&!A){if(s>.5){const m=.3+s*.2,M=Math.floor(g*m),W=Math.floor(u*m),X=Math.floor(c*m);t.fillStyle=`rgb(${M}, ${W}, ${X})`,t.beginPath(),t.arc(this.x,this.y,D*(1+s*.5),0,Math.PI*2),t.fill()}else if(s>.01){const m=(.1+s*.4)*l,M=Math.floor(255*(1-s)+u*s),W=Math.floor(0*(1-s)+g*s),X=Math.floor(0*(1-s)+c*s);t.fillStyle=`rgba(${W}, ${M}, ${X}, ${m})`,t.beginPath(),t.arc(this.x,this.y,D,0,Math.PI*2),t.fill()}else t.fillStyle=`rgba(0, 255, 0, ${.1*l})`,t.beginPath(),t.arc(this.x,this.y,D,0,Math.PI*2),t.fill();return}const b=(f+k*3*r+n*2*r)*l;let C,F;if(s>.5)if(A){const m=Math.min(255,g+Math.floor(n*100)),M=Math.min(255,u+Math.floor(n*100)),W=Math.min(255,c+Math.floor(n*100));C=`rgb(${m}, ${M}, ${W})`,F=`rgba(${g}, ${u}, ${c}, ${(.4+n*.5)*l})`}else C=`rgb(${g}, ${u}, ${c})`,F=`rgba(${g}, ${u}, ${c}, ${(.15+k*.3)*l})`;else if(A){const m=Math.floor(n*255),M=Math.floor(m*(1-s)+Math.min(255,g+100)*s),W=Math.floor(255*(1-s)+Math.min(255,u+100)*s),X=Math.floor(m*(1-s)+Math.min(255,c+100)*s);C=`rgb(${M}, ${W}, ${X})`;const O=Math.floor(0*(1-s)+g*s),P=Math.floor(255*(1-s)+u*s),R=Math.floor(255*(1-s)+c*s);F=`rgba(${O}, ${P}, ${R}, ${(.3+n*.4)*l})`}else if(k>.5)s>.01?(C=`rgb(${g}, ${u}, ${c})`,F=`rgba(${g}, ${u}, ${c}, ${(.1+k*.25)*l})`):(C=y,F=`rgba(0, 255, 0, ${(.1+k*.25)*l})`);else if(s>.01){const M=Math.floor(g*.7),W=Math.floor(u*.7),X=Math.floor(c*.7);C=`rgb(${M}, ${W}, ${X})`,F=`rgba(${g}, ${u}, ${c}, ${(.1+k*.25)*l})`}else C=p,F=`rgba(0, 255, 0, ${(.1+k*.25)*l})`;const I=1.6+n*.5;t.fillStyle=F,t.beginPath(),t.arc(this.x,this.y,b*I,0,Math.PI*2),t.fill(),t.fillStyle=C,t.beginPath(),t.arc(this.x,this.y,b,0,Math.PI*2),t.fill(),s<.5&&(k>.2||A)&&l>.5&&(t.fillStyle="#fff",t.beginPath(),t.arc(this.x,this.y,b*.3,0,Math.PI*2),t.fill())}renderOutput(t,o,e=0,n=1,r=0){if(this.spawnScale<=.01)return;const s=this.spawnScale,i=4*n*s,a=2*n*s,h=e,p=this.isError&&r<.5;if(h<.05){const l=this.isTarget||this.isSelected?.25:.1;t.fillStyle=p?`rgba(255, 0, 0, ${l*s})`:`rgba(0, 255, 0, ${l*s})`,t.beginPath(),t.arc(this.x,this.y,a,0,Math.PI*2),t.fill();return}const y=(i+h*5*n)*s;let v,k;if(p)v=`rgb(${Math.floor(200+h*55)}, ${Math.floor(h*50)}, ${Math.floor(h*50)})`,k=`rgba(255, 50, 50, ${h*.5*s})`;else if(this.isTarget&&this.isSelected){const l=Math.floor(200+h*55);v=`rgb(${Math.floor(h*200)}, ${l}, ${Math.floor(h*200)})`,k=`rgba(100, 255, 100, ${h*.5*s})`}else{const l=Math.floor(h*255);v=`rgb(${l}, 255, ${l})`,k=`rgba(0, 255, 255, ${h*.5*s})`}const A=1.5+h*.8;t.fillStyle=k,t.beginPath(),t.arc(this.x,this.y,y*A,0,Math.PI*2),t.fill(),t.fillStyle=v,t.beginPath(),t.arc(this.x,this.y,y,0,Math.PI*2),t.fill(),h>.3&&(t.fillStyle=`rgba(255, 255, 255, ${h})`,t.beginPath(),t.arc(this.x,this.y,y*.3,0,Math.PI*2),t.fill())}}const N={background:"#000",network:{nTokens:67,embedSize:500,hiddenSize:64,learningRate:.01,weightDecay:1,beta1:.9,beta2:.98,symmetric:!0,trainFraction:.4},training:{batchSize:64,epochsPerFrame:16,showGrokking:!0,useWorker:!0},grid:{rows:16,cols:16,baseSpacing:38,referenceSize:800},colors:{neuronIdle:"#0a0",neuronActive:"#0f0",neuronBright:"#fff",text:"#0f0",testCase:"rgba(0, 255, 0, 0.3)"}};class nt extends et{constructor(t){super(t),this.backgroundColor=N.background}init(){super.init(),console.log("[Day19] Creating FactoredNetwork...");const t=performance.now();try{this.network=new Z(N.network),console.log(`[Day19] Network created in ${(performance.now()-t).toFixed(1)}ms`)}catch(a){console.error("[Day19] Failed to create network:",a);return}const{nTokens:o,symmetric:e,trainFraction:n}=N.network,r=tt(o,e),s=x(r,n);this.trainData=s.train,this.testData=s.test,console.log(`Generated ${r.length} pairs (symmetric=${e}): ${this.trainData.length} train, ${this.testData.length} test`),this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.trainLoss=0,this.testLoss=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.currentTestCase=null,this.testCaseTime=0;const i=Math.min(this.width,this.height);if(this.scale=i/N.grid.referenceSize,this.gridSpacing=N.grid.baseSpacing*this.scale,this.synapseAnimationTime=0,this.outputFlashes=new Map,this.gridFlashes=new Map,this.synapseTrails=new Map,this.lastGridFlashIdx=-1,this.lastOutputFlashIdx=-1,this.lastOutputSourceFlashKey=null,this.activatedGridNeurons=new Set,this.activatedOutputNeurons=new Set,this.currentTestCaseId=null,this.grokMode=0,this.grokThreshold=.6,this.outputNeurons=[],this.outputNeuronsInitialized=!1,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainData.length>0){const a=this.trainData[0];this.network.forward(a.a,a.b)}this.gridOffsetX=0,this.gridOffsetY=0,this.useWorker=N.training.useWorker,this.workerReady=!1,this.workerTraining=!1,this.useWorker&&this.initWorker(),this.inputDots=[],this.outputDots=[],this.fsm=new it({initial:"intro",context:this,states:{intro:{enter:()=>this.startIntroAnimation(),update:a=>this.updateIntro(a)},training:{enter:()=>this.startTraining(),update:a=>this.updateTraining(a)}}}),this.trainingOpacity=0,this.synapseOpacity=0,this.canvas.addEventListener("click",()=>{this.restart()}),this.grokModeOverride=!1,this.originalTestData=null,window.addEventListener("keydown",a=>{(a.key==="g"||a.key==="G")&&(this.grokModeOverride=!this.grokModeOverride,this.grokModeOverride?(this.originalTestData=this.testData,this.testData=[...this.trainData],this.grokMode=1,console.log(`[DEBUG] Grok mode ON - test set = train set (${this.testData.length} examples)`),this.worker&&(this.worker.postMessage({type:"grokMode",enabled:!0}),this.worker.postMessage({type:"syncWeights"}))):(this.originalTestData&&(this.testData=this.originalTestData,this.originalTestData=null),this.grokMode=0,console.log(`[DEBUG] Grok mode OFF - original test set restored (${this.testData.length} examples)`),this.worker&&this.worker.postMessage({type:"grokMode",enabled:!1})))})}initWorker(){try{this.worker=new Worker(new URL("/assets/day19.worker-CzpW03Pq.js",import.meta.url),{type:"module"}),this.worker.onmessage=t=>{const{type:o}=t.data;switch(o){case"state":this.epoch=t.data.epoch,this.trainAccuracy=t.data.trainAccuracy,this.testAccuracy=t.data.testAccuracy,this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.workerTraining=!1,this.workerReady=!0;break;case"forward":this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.cachedOutput=new Float32Array(t.data.outputActivations),this.cachedPrediction=t.data.prediction;break;case"syncWeights":if(this.network&&t.data.weights){const e=t.data.weights,n=r=>r.map(s=>new Float32Array(s));this.network.embed=n(e.embed),this.network.Whidden=n(e.Whidden),this.network.Wout=n(e.Wout),console.log("[Main] Synced weights from worker - predictions now accurate!"),this._weightsSynced=!0}break}},this.worker.onerror=t=>{console.error("Worker error:",t),this.useWorker=!1,this.workerReady=!1},this.worker.postMessage({type:"init",data:{config:N.network}}),console.log("Web Worker initialized for training")}catch(t){console.warn("Failed to create Web Worker, falling back to main thread:",t),this.useWorker=!1}}startIntroAnimation(){const t=this.width/2,o=this.height/2,{rows:e,cols:n}=N.grid;this.pendingTweens=0,this.gridOffsetX=this.width/2-n*this.gridSpacing/2,this.gridOffsetY=this.height/2-e*this.gridSpacing/2,this.gridNeurons=[];for(let s=0;s<e;s++)for(let i=0;i<n;i++){const a=this.gridOffsetX+i*this.gridSpacing,h=this.gridOffsetY+s*this.gridSpacing,p=new j(t,o,4*this.scale);p.targetX=a,p.targetY=h,p.spawnScale=0,this.gridNeurons.push(p);const v=Math.sqrt(Math.pow(i-n/2,2)+Math.pow(s-e/2,2))*.04;this.pendingTweens++,H.to(p,{x:a,y:h,spawnScale:1},.4,U.easeOutBack,{delay:.1+v,onComplete:()=>this.onTweenComplete()})}const r=n*this.gridSpacing;t-r/2-100*this.scale,t+r/2+100*this.scale,this.inputDots=[];for(let s=0;s<14;s++){const i={x:t,y:o,spawnScale:0};this.inputDots.push(i),this.pendingTweens++,H.to(i,{spawnScale:1},.3,U.easeOutBack,{delay:.05+s*.01,onComplete:()=>this.onTweenComplete()})}this.outputDots=[];for(let s=0;s<7;s++){const i={x:t,y:o,spawnScale:0};this.outputDots.push(i),this.pendingTweens++,H.to(i,{spawnScale:1},.3,U.easeOutBack,{delay:.1+s*.01,onComplete:()=>this.onTweenComplete()})}}onTweenComplete(){this.pendingTweens--,this.pendingTweens<=0&&this.fsm.is("intro")&&this.fsm.setState("training")}updateIntro(t){}startTraining(){this.trainingOpacity=0,this.synapseOpacity=0,H.to(this,{trainingOpacity:1},.8,U.easeOutQuad),H.to(this,{synapseOpacity:1},1.5,U.easeInOutQuad,{delay:.5})}updateTraining(t){H.updateAll(t),this.trainNetwork(),this.synapseAnimationTime+=t}restart(){this.network=new Z(N.network);const{nTokens:t,symmetric:o,trainFraction:e}=N.network,n=tt(t,o),r=x(n,e);this.trainData=r.train,this.testData=r.test,this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.grokMode=0,this.grokModeOverride=!1,this.outputNeuronsInitialized=!1,this.outputNeuronsKeys=null,this.gridNeurons=null,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.synapseTrails=new Map,this.trainingOpacity=0,this.synapseOpacity=0,this.useWorker&&this.worker&&(this.workerReady=!1,this.workerTraining=!1,this.worker.postMessage({type:"reset",data:{config:N.network}})),H.killAll(),this.fsm.setState("intro")}update(t){super.update(t);const o=Math.min(this.width,this.height);if(this.scale=o/N.grid.referenceSize,this.gridSpacing=N.grid.baseSpacing*this.scale,this.gridOffsetX=this.width/2-N.grid.cols*this.gridSpacing/2,this.gridOffsetY=this.height/2-N.grid.rows*this.gridSpacing/2,this.fsm.update(t),this.animTime+=t,this.testCaseTime+=t,this.testCaseTime>2){this.testCaseTime=0;const e=Math.floor(Math.random()*this.testData.length);this.currentTestCase=this.testData[e],this.currentTestCaseId=e,this.outputNeuronsInitialized=!1,this.cachedOutput=null,this.cachedPrediction=null,this.activatedGridNeurons.clear(),this.activatedOutputNeurons.clear(),this.gridFlashes.clear(),this.outputFlashes.clear(),this.lastGridFlashIdx=-1,this.lastOutputFlashIdx=-1,this.lastOutputSourceFlashKey=null}if(this.currentTestCase){const{probs:e}=this.network.forward(this.currentTestCase.a,this.currentTestCase.b);this.cachedOutput=e,(!this.useWorker||!this.workerReady)&&(this.cachedPrediction=this.network.predict(this.currentTestCase.a,this.currentTestCase.b))}else this.trainData.length>0&&(this.currentTestCase=this.trainData[0]);this.currentTestCase&&this.useWorker&&this.workerReady&&(!this._lastForwardRequest||Date.now()-this._lastForwardRequest>100)&&(this._lastForwardRequest=Date.now(),this.worker.postMessage({type:"forward",data:{a:this.currentTestCase.a,b:this.currentTestCase.b}}))}trainNetwork(){const{epochsPerFrame:t,batchSize:o}=N.training,{nTokens:e}=N.network;if(this.useWorker&&this.workerReady&&!this.workerTraining){if(this.workerTraining=!0,this.worker.postMessage({type:"train",data:{epochsPerFrame:t,batchSize:o}}),this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokModeOverride){const n=this.trainAccuracy>=.95,s=n&&this.testAccuracy>=this.grokThreshold?1:0,i=this.grokMode>.5;this.grokMode+=(s-this.grokMode)*.05,!i&&this.grokMode>.5&&(this.currentTestCase=null,this.cachedOutput=null,this.cachedPrediction=null,this.useWorker&&this.workerReady&&!this._weightsSynced&&this.worker.postMessage({type:"syncWeights"})),n&&this.useWorker&&this.workerReady&&(!this._lastWeightSync||Date.now()-this._lastWeightSync>5e3)&&(this._lastWeightSync=Date.now(),this.worker.postMessage({type:"syncWeights"}))}return}if(!this.useWorker){this.network.resetGradients();for(let n=0;n<t;n++){for(let r=0;r<this.trainData.length;r++){const s=this.trainData[r],{cache:i}=this.network.forward(s.a,s.b);this.network.backward(s.target,i)}this.network.applyAdamW(this.trainData.length),this.epoch++}if(this.epoch%20===0){const n=this.trainData.slice(0,Math.min(100,this.trainData.length)),r=this.testData.slice(0,Math.min(100,this.testData.length));this.trainAccuracy=st(this.network,n),this.testAccuracy=st(this.network,r)}if(this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokkingDetected&&this.epoch>100){const n=this.accuracyHistory.slice(-50);if(n.length>=50){const r=n[0].test,s=n[n.length-1].test;this.trainAccuracy>.8&&s-r>.3&&(this.grokkingDetected=!0,this.grokkingEpoch=this.epoch)}}}}render(){const t=this.ctx,o=this.width,e=this.height;t.fillStyle="rgba(0, 0, 0, 0.2)",t.fillRect(0,0,o,e),this.updateOutputNeuronState(),this.drawSynapses(t),this.drawNeuronGrid(t),this.drawInputOutputNeurons(t),this.drawInputOutput(t),this.drawStats(t)}drawNeuronGrid(t){const{rows:o,cols:e}=N.grid,n=this.gridSpacing,r=this.network.hiddenActivations;if(!r||r.length===0)return;if(!this._normCache||this._normFrameCount%5===0){const a=[...r].sort((h,p)=>h-p);this._normCache=Math.max(a[Math.floor(a.length*.95)],.001),this._normFrameCount=0}this._normFrameCount++;const s=this._lastSpacing&&Math.abs(this._lastSpacing-n)>1;this._lastSpacing=n;const i=this.fsm.is("intro");if(!this.gridNeurons||this.gridNeurons.length!==o*e||s&&!i){this.gridNeurons=[];for(let a=0;a<o;a++)for(let h=0;h<e;h++){const p=this.gridOffsetX+h*n,y=this.gridOffsetY+a*n;this.gridNeurons.push(new j(p,y,4*this.scale))}}for(let a=0;a<o;a++)for(let h=0;h<e;h++){const p=a*e+h,y=this.gridNeurons[p];y.x=this.gridOffsetX+h*n,y.y=this.gridOffsetY+a*n;let v=0;if(this.gridFlashes&&this.gridFlashes.has(p)){const k=this.gridFlashes.get(p),A=this.synapseAnimationTime-k,l=.5;if(A<l){const f=A/l;v=1-f*f,this.activatedGridNeurons.add(p)}else this.gridFlashes.delete(p),this.activatedGridNeurons.delete(p)}i?(y.activation=0,y.isActive=!1):(y.activation=v,y.isActive=v>.1),y.renderGrid(t,N.colors,this._normCache,v,this.scale,this.grokMode,a,h,this.animTime)}}updateOutputNeuronState(){if(!this.currentTestCase||!this.cachedOutput||!this.fsm.is("training"))return;const t=this.width/2,o=this.height/2,e=N.grid.cols*this.gridSpacing,n=t+e/2+8*this.scale,r=this.cachedOutput,s=this.cachedPrediction,i=16,a=N.network.nTokens,h=f=>Math.floor(f*i/a),p=new Array(i).fill(0),y=new Array(i).fill(-1);for(let f=0;f<a;f++){const D=h(f);r[f]>p[D]&&(p[D]=r[f],y[D]=f)}const v=this.gridSpacing,k=o-(i-1)*v/2;if(!this.outputNeurons||this.outputNeurons.length!==i){this.outputNeurons=[];for(let f=0;f<i;f++){const D=k+f*v;this.outputNeurons.push(new j(n,D,4*this.scale))}}const A=s!=null?h(s):-1,l=this.currentTestCase.target!==void 0?h(this.currentTestCase.target):-1;for(let f=0;f<i;f++){const D=this.outputNeurons[f];D.x=n,D.y=k+f*v,D.isTarget=f===l,D.isSelected=f===A}}drawInputOutputNeurons(t){if(!this.currentTestCase||!this.cachedOutput||!this.fsm.is("training")||this.trainingOpacity<=0||!this.outputNeurons||this.outputNeurons.length===0)return;t.save(),t.globalAlpha=this.trainingOpacity;const o=16;for(let e=0;e<o;e++){const n=this.outputNeurons[e];let r=0;if(this.outputFlashes.has(e)){const i=this.outputFlashes.get(e),a=this.synapseAnimationTime-i,h=.5;if(a<h){const p=a/h;r=1-p*p,this.activatedOutputNeurons.add(e)}else this.outputFlashes.delete(e),this.activatedOutputNeurons.delete(e)}n.activation=r;const s=n.isTarget&&!n.isSelected||!n.isTarget&&n.isSelected;n.isError=r>.1&&s,n.renderOutput(t,N.colors,r,this.scale,this.grokMode)}t.restore()}drawSynapses(t){if(!this.currentTestCase||!this.fsm.is("training")||this.synapseOpacity<=0||!this.cachedOutput||!this.gridNeurons)return;t.save(),t.globalAlpha=this.synapseOpacity;const o=this.width/2,e=this.height/2,n=N.grid.cols*this.gridSpacing,{cols:r}=N.grid,s=this.gridSpacing,i=this.synapseAnimationTime,a=.4;for(const[g,u]of this.gridFlashes.entries())i-u>a&&(this.gridFlashes.delete(g),this.activatedGridNeurons.delete(g));for(const[g,u]of this.outputFlashes.entries())i-u>a&&(this.outputFlashes.delete(g),this.activatedOutputNeurons.delete(g));const h=this.network.hiddenActivations;h&&Math.max(...h,.001);const p=g=>{const c=(Math.floor(i*8)*17+g*31)%256,b=Math.floor(c/r),C=c%r;return{index:c,x:this.gridOffsetX+C*s,y:this.gridOffsetY+b*s}},y=o-n/2-100*this.scale,v=y,k=e-40*this.scale,A=y,l=e+40*this.scale;t.lineCap="round";const f=12,D=8;for(let g=0;g<f;g++){const u=(i*6+g*.083)%1,c=p(g),b=g%2===0,C=b?v:A,F=b?k:l,I=Math.min(1,u*3),m=1-Math.pow(1-I,3),M=C+(c.x-C)*m,W=F+(c.y-F)*m;let X=(1-u)*.6;t.strokeStyle="#0ff",t.lineWidth=Math.max(.5,1*this.scale),t.globalAlpha=this.synapseOpacity*X,t.beginPath(),t.moveTo(C,F),t.lineTo(M,W),t.stroke(),I<1&&X>.1&&(t.fillStyle=`rgba(0, 255, 255, ${X*.5})`,t.beginPath(),t.arc(M,W,2*this.scale,0,Math.PI*2),t.fill()),I>.9&&(this.gridFlashes.set(c.index,i),this.activatedGridNeurons.add(c.index))}const Y=[];if(this.outputNeurons&&this.outputNeurons.length>0)for(let g=0;g<this.outputNeurons.length;g++){const u=this.outputNeurons[g];(u.isSelected||u.isTarget)&&Y.push({position:g,x:u.x,y:u.y,isPrimary:u.isSelected})}if(Y.length>0){const g=Array.from(this.activatedGridNeurons).slice(-8).map(u=>{const c=Math.floor(u/r),b=u%r;return{index:u,x:this.gridOffsetX+b*s,y:this.gridOffsetY+c*s}});if(g.length===0)for(let u=0;u<4;u++)g.push(p(u));for(let u=0;u<D;u++){const c=(i*5+u*.125+.15)%1,b=g[u%g.length],C=Y[u%Y.length],F=Math.min(1,c*3),I=1-Math.pow(1-F,3),m=b.x+(C.x-b.x)*I,M=b.y+(C.y-b.y)*I;let W=(1-c)*.5;t.strokeStyle="#0ff",t.lineWidth=Math.max(.5,1*this.scale),t.globalAlpha=this.synapseOpacity*W,t.beginPath(),t.moveTo(b.x,b.y),t.lineTo(m,M),t.stroke(),F<1&&W>.1&&(t.fillStyle=`rgba(0, 255, 255, ${W*.5})`,t.beginPath(),t.arc(m,M,2*this.scale,0,Math.PI*2),t.fill()),F>.1&&F<.3&&this.gridFlashes.set(b.index,i),F>.9&&(this.outputFlashes.set(C.position,i),this.activatedOutputNeurons.add(C.position))}}t.restore()}drawSingleInputToHidden_OLD(t,o,e,n,r,s,i,a,h,p,y,v,k){if(!h)return;const A=[];for(let d=0;d<h.length;d++){const w=h[d],S=p[d]/y,T=Math.abs(w)*S;A.push({index:d,strength:T,weight:w,activation:S})}A.sort((d,w)=>w.strength-d.strength);const l=A.slice(0,20);if(l.length===0)return;const f=.5,D=l.length*f,Y=this.synapseAnimationTime%D/f,g=Math.floor(Y),u=Y%1,c=l[g%l.length];for(const d of l){const w=d.index,S=Math.floor(w/i),T=w%i,$=n+T*a,G=r+S*a;t.strokeStyle=k,t.globalAlpha=.05,t.lineWidth=.5,t.beginPath(),t.moveTo(o,e),t.lineTo($,G),t.stroke()}const b=c.index,C=Math.floor(b/i),F=b%i,I=n+F*a,m=r+C*a,M=Math.max(.5,Math.min(2,Math.abs(c.weight)*1.5)),W=Math.min(.8,c.activation*.9),X=.4,O=u,P=(u+X)%1;if(t.strokeStyle=k,t.globalAlpha=W,t.lineWidth=M,t.beginPath(),P>O){const d=o+(I-o)*O,w=e+(m-e)*O,S=o+(I-o)*P,T=e+(m-e)*P;t.moveTo(d,w),t.lineTo(S,T)}else{const d=o+(I-o)*O,w=e+(m-e)*O,S=o+(I-o)*P,T=e+(m-e)*P;t.moveTo(d,w),t.lineTo(I,m),t.moveTo(o,e),t.lineTo(S,T)}t.stroke(),t.globalAlpha=1;const R=P>=.95||P<O&&O>.9;R&&this.lastGridFlashIdx!==b?(this.gridFlashes.set(b,this.synapseAnimationTime),this.lastGridFlashIdx=b):!R&&this.lastGridFlashIdx===b&&(this.lastGridFlashIdx=-1)}drawInputToHiddenConnections(t,o,e,n,r,s,i,a,h,p,y,v,k,A,l,f,D){const Y=N.network.nTokens,g=Math.max(3,Math.ceil(Math.log2(Y+1))),u=[];let c=o;for(let d=g-1;d>=0;d--){const w=c>>d&1;u.push(w)}const b=Math.ceil(g/i),C=n-(b-1)*s/2,F=[];for(let d=0;d<g;d++)if(u[d]===1){const w=Math.floor(d/i),S=d%i,$=(Math.min(i,g-w*i)-1)*s,G=e-$/2+S*s,z=C+w*s;F.push({index:d,x:G,y:z})}if(F.length===0)return;const I=.5,m=F.length*I,M=this.synapseAnimationTime%m/I,W=Math.floor(M),X=M%1,O=F[W%F.length];for(const d of F){const w=[];for(let T=0;T<k.length;T++){const $=k[T],G=A[T]/l,z=Math.abs($)*G;w.push({index:T,strength:z,weight:$,activation:G})}w.sort((T,$)=>$.strength-T.strength);const S=w.slice(0,10);for(const T of S){const $=T.index,G=Math.floor($/y),z=$%y,_=a+z*v,K=h+G*v;t.strokeStyle=D,t.globalAlpha=.03,t.lineWidth=.5,t.beginPath(),t.moveTo(d.x,d.y),t.lineTo(_,K),t.stroke()}}const P=[];for(let d=0;d<k.length;d++){const w=k[d],S=A[d]/l,T=Math.abs(w)*S;P.push({index:d,strength:T,weight:w,activation:S})}P.sort((d,w)=>w.strength-d.strength);const R=P.slice(0,10);for(const d of R){const w=d.index,S=Math.floor(w/y),T=w%y,$=a+T*v,G=h+S*v,z=Math.max(.5,Math.min(2,Math.abs(d.weight)*1.5)),_=Math.min(.6,d.activation*.7),K=.4,E=X,L=(X+K)%1;if(t.strokeStyle=D,t.globalAlpha=_,t.lineWidth=z,t.beginPath(),L>E){const q=O.x+($-O.x)*E,Q=O.y+(G-O.y)*E,J=O.x+($-O.x)*L,V=O.y+(G-O.y)*L;t.moveTo(q,Q),t.lineTo(J,V)}else{const q=O.x+($-O.x)*E,Q=O.y+(G-O.y)*E,J=O.x+($-O.x)*L,V=O.y+(G-O.y)*L;t.moveTo(q,Q),t.lineTo($,G),t.moveTo(O.x,O.y),t.lineTo(J,V)}t.stroke()}t.globalAlpha=1}drawLayerConnectionsToGrid(t,o,e,n,r,s,i,a,h,p,y,v,k,A){const l=[];for(let d=0;d<h.length;d++){const w=h[d],S=p[d]/y,T=Math.abs(w)*S;l.push({index:d,strength:T,weight:w,activation:S})}l.sort((d,w)=>w.strength-d.strength);const f=l.slice(0,k);if(f.length===0)return;const D=.5,Y=f.length*D,g=this.synapseAnimationTime%Y/D,u=Math.floor(g),c=g%1,b=f[u%f.length];for(const d of f){const w=d.index,S=Math.floor(w/i),T=w%i,$=n+T*a,G=r+S*a;t.strokeStyle=A,t.globalAlpha=.05,t.lineWidth=.5,t.beginPath(),t.moveTo(o,e),t.lineTo($,G),t.stroke()}const C=b.index,F=Math.floor(C/i),I=C%i,m=n+I*a,M=r+F*a,W=Math.max(.5,Math.min(2,Math.abs(b.weight)*1.5)),X=Math.min(.8,b.activation*.9),O=.4,P=c,R=(c+O)%1;if(t.strokeStyle=A,t.globalAlpha=X,t.lineWidth=W,t.beginPath(),R>P){const d=o+(m-o)*P,w=e+(M-e)*P,S=o+(m-o)*R,T=e+(M-e)*R;t.moveTo(d,w),t.lineTo(S,T)}else{const d=o+(m-o)*P,w=e+(M-e)*P,S=o+(m-o)*R,T=e+(M-e)*R;t.moveTo(d,w),t.lineTo(m,M),t.moveTo(o,e),t.lineTo(S,T)}t.stroke(),t.globalAlpha=1}drawUnifiedOutputSynapses(t,o,e,n,r,s,i,a,h,p,y,v,k){const A=[];for(let P=0;P<i.length;P++){const R=i[P].index,d=h+P*p,w=this.network.weights2.map(S=>S[R]);for(let S=0;S<w.length;S++){const T=w[S],$=y[S]/v,G=Math.abs(T)*$;if(G>.01){const z=Math.floor(S/r),_=S%r,K=o+_*s,E=e+z*s;A.push({fromX:K,fromY:E,toX:a,toY:d,strength:G,weight:T,activation:$,outputIdx:P})}}}A.sort((P,R)=>R.strength-P.strength);const l=A.slice(0,30);if(l.length===0)return;const f=.3,D=l.length*f,Y=this.synapseAnimationTime%D/f,g=Math.floor(Y),u=Y%1;t.strokeStyle=k,t.globalAlpha=.03,t.lineWidth=.5;for(const P of l)t.beginPath(),t.moveTo(P.fromX,P.fromY),t.lineTo(P.toX,P.toY),t.stroke();const c=l[g%l.length],b=Math.max(.5,Math.min(2,Math.abs(c.weight)*1.5)),C=Math.min(.8,c.activation*.9),F=.4,I=u,m=Math.min(1,u+F);if(t.strokeStyle=k,t.globalAlpha=C,t.lineWidth=b,t.beginPath(),m>I){const P=c.fromX+(c.toX-c.fromX)*I,R=c.fromY+(c.toY-c.fromY)*I,d=c.fromX+(c.toX-c.fromX)*m,w=c.fromY+(c.toY-c.fromY)*m;t.moveTo(P,R),t.lineTo(d,w)}t.stroke(),t.globalAlpha=1;const M=this.getGridIndexFromPosition(c.fromX,c.fromY,o,e,s,r),W=`out-src-${g}`;I<.15&&this.lastOutputSourceFlashKey!==W&&M>=0?(this.gridFlashes.set(M,this.synapseAnimationTime),this.lastOutputSourceFlashKey=W):I>=.3&&this.lastOutputSourceFlashKey===W&&(this.lastOutputSourceFlashKey=null);const X=c.outputIdx,O=`${g}-${X}`;m>=.95&&this.lastOutputFlashIdx!==O?(this.outputFlashes.set(X,this.synapseAnimationTime),this.lastOutputFlashIdx=O):m<.5&&this.lastOutputFlashIdx===O&&(this.lastOutputFlashIdx=null)}getGridIndexFromPosition(t,o,e,n,r,s){const i=Math.round((t-e)/r),a=Math.round((o-n)/r);return i<0||a<0||i>=s||a>=N.grid.rows?-1:a*s+i}drawLayerConnectionsFromGrid(t,o,e,n,r,s,i,a,h,p,y,v,k,A){const l=[];for(let T=0;T<h.length;T++){const $=h[T],G=p[T]/y,z=Math.abs($)*G;l.push({index:T,strength:z,weight:$,activation:G})}l.sort((T,$)=>$.strength-T.strength);const f=l.slice(0,k);if(f.length===0)return;const D=.5,Y=f.length*D,g=this.synapseAnimationTime%Y/D,u=Math.floor(g),c=g%1;this.synapseTrails||(this.synapseTrails=new Map);const b=f[u%f.length],C=b.index,F=Math.floor(C/r),I=C%r,m=o+I*s,M=e+F*s,W=`${m},${M},${i},${a}`,X=1.5,O=[];for(const[T,$]of this.synapseTrails.entries()){const G=this.synapseAnimationTime-$.startTime,z=Math.max(0,1-G/X);if(z<=0){O.push(T);continue}t.strokeStyle=A,t.globalAlpha=z*.4,t.lineWidth=Math.max(.5,Math.min(1.5,Math.abs($.weight)*z)),t.beginPath(),t.moveTo($.fromX,$.fromY),t.lineTo($.toX,$.toY),t.stroke()}for(const T of O)this.synapseTrails.delete(T);const P=Math.max(.5,Math.min(2,Math.abs(b.weight)*1.5)),R=Math.min(.8,b.activation*.9),d=.4,w=c,S=Math.min(1,c+d);if(t.strokeStyle=A,t.globalAlpha=R,t.lineWidth=P,t.beginPath(),S>w){const T=m+(i-m)*w,$=M+(a-M)*w,G=m+(i-m)*S,z=M+(a-M)*S;t.moveTo(T,$),t.lineTo(G,z)}else{const T=m+(i-m)*w,$=M+(a-M)*w;t.moveTo(T,$),t.lineTo(i,a),t.moveTo(m,M);const G=m+(i-m)*S,z=M+(a-M)*S;t.lineTo(G,z)}t.stroke(),c>=.95&&!this.synapseTrails.has(W)&&this.synapseTrails.set(W,{startTime:this.synapseAnimationTime,fromX:m,fromY:M,toX:i,toY:a,weight:b.weight,activation:b.activation}),t.globalAlpha=1}drawInputOutput(t){var F,I;if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const{text:o,neuronActive:e,neuronBright:n}=N.colors,r=this.currentTestCase.a??((F=this.currentTestCase.original)==null?void 0:F[0])??0,s=this.currentTestCase.b??((I=this.currentTestCase.original)==null?void 0:I[1])??0,i=this.currentTestCase.target,a=this.cachedPrediction??this.network.predict(r,s),h=a===i,p=this.width/2,y=this.height/2,v=N.grid.cols*this.gridSpacing;N.grid.rows*this.gridSpacing;const k=p-v/2-100*this.scale,A=p+v/2+100*this.scale,l=4*this.scale,f=18*this.scale,D=10,Y=y-40*this.scale;this.drawNumberAsDots(t,r,k,Y,l,f,D,e),t.fillStyle=o,t.font=`bold ${Math.round(32*this.scale)}px monospace`,t.textAlign="center",t.textBaseline="middle",t.fillText("+",k,y);const g=y+40*this.scale;this.drawNumberAsDots(t,s,k,g,l,f,D,e),this.drawNumberAsDots(t,i,A,y,l,f,D,n);const u=40*this.scale,b=40*this.scale+22*this.scale*6+40*this.scale+30*this.scale;t.textAlign="left",t.font=`bold ${Math.round(14*this.scale)}px monospace`,t.fillStyle=o;const C=r+s;t.fillText(`${r} + ${s} = ${C}`,u,b),t.font=`${Math.round(12*this.scale)}px monospace`,t.fillText(`mod ${N.network.nTokens} = ${i}`,u,b+18*this.scale),t.font=`bold ${Math.round(12*this.scale)}px monospace`,t.fillStyle=h?"#0ff":"#f00",t.fillText(`Predicted: ${a} ${h?"✓":"✗"}`,u,b+36*this.scale),t.restore()}drawNumberAsDots(t,o,e,n,r,s,i,a){const h=N.network.nTokens,p=Math.max(1,Math.ceil(Math.log2(h))),y=[];let v=o;for(let l=p-1;l>=0;l--){const f=v>>l&1;y.push(f)}const k=Math.ceil(p/i),A=n-(k-1)*s/2;t.globalAlpha=1;for(let l=0;l<p;l++){const f=y[l],D=Math.floor(l/i),Y=l%i,u=(Math.min(i,p-D*i)-1)*s,c=e-u/2+Y*s,b=A+D*s,C=new j(c,b,r);C.isActive=f===1,C.activation=f===1?1:0,C.render(t,N.colors)}}drawStats(t){if(!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const o=40*this.scale,e=40*this.scale,n=22*this.scale;if(t.fillStyle="#888",t.font=`${Math.round(14*this.scale)}px monospace`,t.textAlign="left",t.textBaseline="top",t.fillText(`Epoch: ${this.epoch}`,o,e),t.fillText(`Train: ${(this.trainAccuracy*100).toFixed(1)}%`,o,e+n),t.fillText(`Test: ${(this.testAccuracy*100).toFixed(1)}%`,o,e+n*2),this.grokMode>.5?(t.fillStyle="#f0f",t.fillText("✨ GROKKED!",o,e+n*3)):this.grokkingDetected&&(t.fillStyle="#0ff",t.fillText("✓ GROKKING!",o,e+n*3)),this.accuracyHistory.length>2){const r=150*this.scale,s=40*this.scale,i=o,a=e+n*6,h=Math.max(1,Math.floor(this.accuracyHistory.length/100));t.strokeStyle="#0f0",t.lineWidth=1,t.beginPath();let p=!0;for(let y=0;y<this.accuracyHistory.length;y+=h){const v=this.accuracyHistory[y],k=i+y/this.accuracyHistory.length*r,A=a-v.train*s;p?(t.moveTo(k,A),p=!1):t.lineTo(k,A)}t.stroke(),t.strokeStyle="#0ff",t.beginPath(),p=!0;for(let y=0;y<this.accuracyHistory.length;y+=h){const v=this.accuracyHistory[y],k=i+y/this.accuracyHistory.length*r,A=a-v.test*s;p?(t.moveTo(k,A),p=!1):t.lineTo(k,A)}t.stroke()}t.restore()}}function rt(B){const t=new nt(B);return t.start(),{stop:()=>t.stop(),game:t}}export{rt as default};
