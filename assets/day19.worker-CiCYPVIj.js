(function(){"use strict";function j(c){for(let t=c.length-1;t>0;t--){const s=Math.floor(Math.random()*(t+1));[c[t],c[s]]=[c[s],c[t]]}return c}function R(c){const t=new Array(c);for(let s=0;s<c;s++)t[s]=s;return j(t)}class D{constructor(t){this.nTokens=t.nTokens||16,this.embedSize=t.embedSize||128,this.hiddenSize=t.hiddenSize||24,this.learningRate=t.learningRate||.001,this.weightDecay=t.weightDecay||1,this.beta1=t.beta1||.9,this.beta2=t.beta2||.98,this.epsilon=1e-8;const s=Math.sqrt(2/this.nTokens),e=Math.sqrt(2/this.embedSize),d=Math.sqrt(2/this.hiddenSize);this.embed=this.initMatrix(this.nTokens,this.embedSize,s),this.Whidden=this.initMatrix(this.embedSize,this.hiddenSize,e),this.Wout=this.initMatrix(this.hiddenSize,this.embedSize,d),this._actualHiddenActivations=new Float32Array(this.hiddenSize),this.hiddenActivations=new Float32Array(256),this.outputActivations=new Float32Array(this.nTokens),this.weights1=null,this.weights2=null,this.initAdamState(),this.adamT=0}initMatrix(t,s,e){const d=[];for(let a=0;a<t;a++){d[a]=new Float32Array(s);for(let h=0;h<s;h++)d[a][h]=(Math.random()*2-1)*e}return d}initAdamState(){this.m_embed=this.embed.map(t=>new Float32Array(t.length)),this.v_embed=this.embed.map(t=>new Float32Array(t.length)),this.m_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.v_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.m_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.v_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.grad_embed=this.embed.map(t=>new Float32Array(t.length)),this.grad_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.grad_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.gradCount=0}resetGradients(){for(let t=0;t<this.nTokens;t++)this.grad_embed[t].fill(0);for(let t=0;t<this.embedSize;t++)this.grad_Whidden[t].fill(0);for(let t=0;t<this.hiddenSize;t++)this.grad_Wout[t].fill(0);this.gradCount=0}forward(t,s){const e=this.embed[t],d=this.embed[s],a=new Float32Array(this.hiddenSize),h=new Float32Array(this.hiddenSize);for(let l=0;l<this.hiddenSize;l++){let S=0,p=0;for(let g=0;g<this.embedSize;g++)S+=e[g]*this.Whidden[g][l],p+=d[g]*this.Whidden[g][l];a[l]=S,h[l]=p}const i=new Float32Array(this.hiddenSize),n=new Float32Array(this.hiddenSize);for(let l=0;l<this.hiddenSize;l++)n[l]=a[l]+h[l],i[l]=Math.max(0,n[l]);this._actualHiddenActivations=i,this._updateGridActivations();const m=new Float32Array(this.embedSize);for(let l=0;l<this.hiddenSize;l++){const S=i[l],p=this.Wout[l];for(let g=0;g<this.embedSize;g++)m[g]+=S*p[g]}const u=new Float32Array(this.nTokens);for(let l=0;l<this.nTokens;l++){let S=0;for(let p=0;p<this.embedSize;p++)S+=m[p]*this.embed[l][p];u[l]=S}const f=this.softmax(u);return this.outputActivations=f,{probs:f,hidden:i,cache:{a:t,b:s,embedded_a:e,embedded_b:d,hidden_a:a,hidden_b:h,hidden_preact:n,hidden:i,out:m,logits:u,probs:f}}}softmax(t){let s=t[0];for(let h=1;h<t.length;h++)t[h]>s&&(s=t[h]);const e=new Float32Array(t.length);let d=0;for(let h=0;h<t.length;h++)e[h]=Math.exp(t[h]-s),d+=e[h];const a=new Float32Array(t.length);for(let h=0;h<t.length;h++)a[h]=e[h]/d;return a}backward(t,s){const{a:e,b:d,embedded_a:a,embedded_b:h,hidden_preact:i,hidden:n,out:m,probs:u}=s,f=new Float32Array(this.nTokens);for(let o=0;o<this.nTokens;o++)f[o]=u[o]-(o===t?1:0);for(let o=0;o<this.nTokens;o++){const W=f[o],b=this.grad_embed[o];for(let w=0;w<this.embedSize;w++)b[w]+=W*m[w]}const T=new Float32Array(this.embedSize);for(let o=0;o<this.nTokens;o++){const W=f[o],b=this.embed[o];for(let w=0;w<this.embedSize;w++)T[w]+=W*b[w]}const l=new Float32Array(this.hiddenSize);for(let o=0;o<this.hiddenSize;o++){let W=0;for(let b=0;b<this.embedSize;b++)this.grad_Wout[o][b]+=n[o]*T[b],W+=T[b]*this.Wout[o][b];l[o]=W}const S=new Float32Array(this.hiddenSize);for(let o=0;o<this.hiddenSize;o++)S[o]=i[o]>0?l[o]:0;const p=new Float32Array(this.embedSize),g=new Float32Array(this.embedSize);for(let o=0;o<this.embedSize;o++){let W=0;for(let b=0;b<this.hiddenSize;b++)this.grad_Whidden[o][b]+=a[o]*S[b],this.grad_Whidden[o][b]+=h[o]*S[b],W+=S[b]*this.Whidden[o][b];p[o]=W,g[o]=W}for(let o=0;o<this.embedSize;o++)this.grad_embed[e][o]+=p[o],this.grad_embed[d][o]+=g[o];this.gradCount++}applyAdamW(t){if(this.gradCount===0)return;this.adamT++;const s=this.learningRate,e=this.weightDecay,d=1/t,a=1-Math.pow(this.beta1,this.adamT),h=1-Math.pow(this.beta2,this.adamT);for(let i=0;i<this.nTokens;i++)for(let n=0;n<this.embedSize;n++){const m=this.grad_embed[i][n]*d;this.m_embed[i][n]=this.beta1*this.m_embed[i][n]+(1-this.beta1)*m,this.v_embed[i][n]=this.beta2*this.v_embed[i][n]+(1-this.beta2)*m*m;const u=this.m_embed[i][n]/a,f=this.v_embed[i][n]/h;this.embed[i][n]-=s*(u/(Math.sqrt(f)+this.epsilon)+e*this.embed[i][n]),this.grad_embed[i][n]=0}for(let i=0;i<this.embedSize;i++)for(let n=0;n<this.hiddenSize;n++){const m=this.grad_Whidden[i][n]*d;this.m_Whidden[i][n]=this.beta1*this.m_Whidden[i][n]+(1-this.beta1)*m,this.v_Whidden[i][n]=this.beta2*this.v_Whidden[i][n]+(1-this.beta2)*m*m;const u=this.m_Whidden[i][n]/a,f=this.v_Whidden[i][n]/h;this.Whidden[i][n]-=s*(u/(Math.sqrt(f)+this.epsilon)+e*this.Whidden[i][n]),this.grad_Whidden[i][n]=0}for(let i=0;i<this.hiddenSize;i++)for(let n=0;n<this.embedSize;n++){const m=this.grad_Wout[i][n]*d;this.m_Wout[i][n]=this.beta1*this.m_Wout[i][n]+(1-this.beta1)*m,this.v_Wout[i][n]=this.beta2*this.v_Wout[i][n]+(1-this.beta2)*m*m;const u=this.m_Wout[i][n]/a,f=this.v_Wout[i][n]/h;this.Wout[i][n]-=s*(u/(Math.sqrt(f)+this.epsilon)+e*this.Wout[i][n]),this.grad_Wout[i][n]=0}this.gradCount=0}predict(t,s){const{probs:e}=this.forward(t,s);let d=0,a=e[0];for(let h=1;h<e.length;h++)e[h]>a&&(a=e[h],d=h);return d}_updateGridActivations(){const s=this._actualHiddenActivations;if(this.hiddenSize===256)for(let e=0;e<256;e++)this.hiddenActivations[e]=s[e];else if(this.hiddenSize<256)for(let e=0;e<256;e++)this.hiddenActivations[e]=s[e%this.hiddenSize];else{const e=this.hiddenSize/256;for(let d=0;d<256;d++)this.hiddenActivations[d]=s[Math.floor(d*e)]}}getGridActivations(){return new Float32Array(this.hiddenActivations)}}function G(c,t=!0){const s=[];for(let e=0;e<c;e++)for(let d=0;d<c;d++){if(t&&e>d)continue;const a=(e+d)%c;s.push({a:e,b:d,target:a,original:[e,d]})}return s}function $(c,t=.4){const s=j([...c]),e=Math.floor(s.length*t);return{train:s.slice(0,e),test:s.slice(e)}}function M(c,t){let s=0;for(const e of t)c.predict(e.a,e.b)===e.target&&s++;return s/t.length}console.log("[Worker] Factored MLP module loaded");let r=null,z=[],_=[],k=null,A=0,F=0,y=0,x=!1;self.onmessage=function(c){const{type:t,data:s}=c.data;switch(console.log(`[Worker] Received: ${t}`),t){case"init":{try{const e=s.config;console.log("[Worker] Config:",e),r=new D(e);const d=G(e.nTokens,e.symmetric??!0),a=$(d,e.trainFraction||.4);z=a.train,_=a.test,console.log(`[Worker] Data: ${z.length} train, ${_.length} test`),A=0,F=0,y=0,v(),console.log("[Worker] Init complete")}catch(e){console.error("[Worker] Init error:",e),self.postMessage({type:"error",error:e.message})}break}case"train":{if(!r||x)return;x=!0;const e=performance.now(),{epochsPerFrame:d,batchSize:a=64}=s;for(let i=0;i<d;i++){const n=R(z.length);r.resetGradients();for(let m=0;m<z.length;m++){const u=z[n[m]],{cache:f}=r.forward(u.a,u.b);r.backward(u.target,f)}r.applyAdamW(z.length),A++}F=M(r,z),y=M(r,_);const h=performance.now()-e;A%100===0&&console.log(`[Worker] Epoch ${A}: train=${(F*100).toFixed(1)}%, test=${(y*100).toFixed(1)}% (${h.toFixed(0)}ms)`),x=!1,v();break}case"forward":{if(!r)return;const{a:e,b:d}=s,{probs:a,hidden:h}=r.forward(e,d);self.postMessage({type:"forward",hiddenActivations:r.getGridActivations(),outputActivations:a,prediction:r.predict(e,d)});break}case"syncWeights":{if(!r)return;self.postMessage({type:"syncWeights",weights:{embed:r.embed,Whidden:r.Whidden,Wout:r.Wout},config:{nTokens:r.nTokens,embedSize:r.embedSize,hiddenSize:r.hiddenSize}});break}case"reset":{if(!r)return;const e=s.config;r=new D(e);const d=G(e.nTokens,e.symmetric??!0),a=$(d,e.trainFraction||.4);z=a.train,_=a.test,k=null,A=0,F=0,y=0,v();break}case"grokMode":{c.data.enabled?(k=_,_=[...z],console.log(`[Worker] Grok mode ON - test set = train set (${_.length} examples)`)):(k&&(_=k,k=null),console.log(`[Worker] Grok mode OFF - original test set restored (${_.length} examples)`)),r&&(y=M(r,_),v());break}}};function v(){if(!r)return;const c=_[0]||z[0];c&&r.forward(c.a,c.b),self.postMessage({type:"state",epoch:A,trainAccuracy:F,testAccuracy:y,hiddenActivations:r.getGridActivations(),outputActivations:r.outputActivations,hiddenSize:r.hiddenSize,nTokens:r.nTokens})}})();
