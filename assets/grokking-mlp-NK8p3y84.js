class A{constructor(t){this.nTokens=t.nTokens||16,this.embedSize=t.embedSize||128,this.hiddenSize=t.hiddenSize||24,this.learningRate=t.learningRate||.001,this.weightDecay=t.weightDecay||1,this.beta1=t.beta1||.9,this.beta2=t.beta2||.98,this.epsilon=1e-8;const n=Math.sqrt(2/this.nTokens),e=Math.sqrt(2/this.embedSize),d=Math.sqrt(2/this.hiddenSize);this.embed=this.initMatrix(this.nTokens,this.embedSize,n),this.Whidden=this.initMatrix(this.embedSize,this.hiddenSize,e),this.Wout=this.initMatrix(this.hiddenSize,this.embedSize,d),this._actualHiddenActivations=new Float32Array(this.hiddenSize),this.hiddenActivations=new Float32Array(256),this.outputActivations=new Float32Array(this.nTokens),this.weights1=null,this.weights2=null,this.initAdamState(),this.adamT=0}initMatrix(t,n,e){const d=[];for(let o=0;o<t;o++){d[o]=new Float32Array(n);for(let a=0;a<n;a++)d[o][a]=(Math.random()*2-1)*e}return d}initAdamState(){this.m_embed=this.embed.map(t=>new Float32Array(t.length)),this.v_embed=this.embed.map(t=>new Float32Array(t.length)),this.m_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.v_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.m_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.v_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.grad_embed=this.embed.map(t=>new Float32Array(t.length)),this.grad_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.grad_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.gradCount=0}resetGradients(){for(let t=0;t<this.nTokens;t++)this.grad_embed[t].fill(0);for(let t=0;t<this.embedSize;t++)this.grad_Whidden[t].fill(0);for(let t=0;t<this.hiddenSize;t++)this.grad_Wout[t].fill(0);this.gradCount=0}forward(t,n){const e=this.embed[t],d=this.embed[n],o=new Float32Array(this.hiddenSize),a=new Float32Array(this.hiddenSize);for(let r=0;r<this.hiddenSize;r++){let u=0,c=0;for(let S=0;S<this.embedSize;S++)u+=e[S]*this.Whidden[S][r],c+=d[S]*this.Whidden[S][r];o[r]=u,a[r]=c}const i=new Float32Array(this.hiddenSize),s=new Float32Array(this.hiddenSize);for(let r=0;r<this.hiddenSize;r++)s[r]=o[r]+a[r],i[r]=Math.max(0,s[r]);this._actualHiddenActivations=i,this._updateGridActivations();const m=new Float32Array(this.embedSize);for(let r=0;r<this.embedSize;r++){let u=0;for(let c=0;c<this.hiddenSize;c++)u+=i[c]*this.Wout[c][r];m[r]=u}const _=new Float32Array(this.nTokens);for(let r=0;r<this.nTokens;r++){let u=0;for(let c=0;c<this.embedSize;c++)u+=m[c]*this.embed[r][c];_[r]=u}const b=this.softmax(_);return this.outputActivations=b,{probs:b,hidden:i,cache:{a:t,b:n,embedded_a:e,embedded_b:d,hidden_a:o,hidden_b:a,hidden_preact:s,hidden:i,out:m,logits:_,probs:b}}}softmax(t){let n=t[0];for(let a=1;a<t.length;a++)t[a]>n&&(n=t[a]);const e=new Float32Array(t.length);let d=0;for(let a=0;a<t.length;a++)e[a]=Math.exp(t[a]-n),d+=e[a];const o=new Float32Array(t.length);for(let a=0;a<t.length;a++)o[a]=e[a]/d;return o}backward(t,n){const{a:e,b:d,embedded_a:o,embedded_b:a,hidden_preact:i,hidden:s,out:m,probs:_}=n,b=new Float32Array(this.nTokens);for(let h=0;h<this.nTokens;h++)b[h]=_[h]-(h===t?1:0);const z=new Float32Array(this.embedSize);for(let h=0;h<this.embedSize;h++){let f=0;for(let l=0;l<this.nTokens;l++)f+=b[l]*this.embed[l][h],this.grad_embed[l][h]+=b[l]*m[h];z[h]=f}const r=new Float32Array(this.hiddenSize);for(let h=0;h<this.hiddenSize;h++){let f=0;for(let l=0;l<this.embedSize;l++)this.grad_Wout[h][l]+=s[h]*z[l],f+=z[l]*this.Wout[h][l];r[h]=f}const u=new Float32Array(this.hiddenSize);for(let h=0;h<this.hiddenSize;h++)u[h]=i[h]>0?r[h]:0;const c=new Float32Array(this.embedSize),S=new Float32Array(this.embedSize);for(let h=0;h<this.embedSize;h++){let f=0;for(let l=0;l<this.hiddenSize;l++)this.grad_Whidden[h][l]+=o[h]*u[l],this.grad_Whidden[h][l]+=a[h]*u[l],f+=u[l]*this.Whidden[h][l];c[h]=f,S[h]=f}for(let h=0;h<this.embedSize;h++)this.grad_embed[e][h]+=c[h],this.grad_embed[d][h]+=S[h];this.gradCount++}applyAdamW(t){if(this.gradCount===0)return;this.adamT++;const n=this.learningRate,e=this.weightDecay,d=1/t,o=1-Math.pow(this.beta1,this.adamT),a=1-Math.pow(this.beta2,this.adamT);for(let i=0;i<this.nTokens;i++)for(let s=0;s<this.embedSize;s++){const m=this.grad_embed[i][s]*d;this.m_embed[i][s]=this.beta1*this.m_embed[i][s]+(1-this.beta1)*m,this.v_embed[i][s]=this.beta2*this.v_embed[i][s]+(1-this.beta2)*m*m;const _=this.m_embed[i][s]/o,b=this.v_embed[i][s]/a;this.embed[i][s]-=n*(_/(Math.sqrt(b)+this.epsilon)+e*this.embed[i][s]),this.grad_embed[i][s]=0}for(let i=0;i<this.embedSize;i++)for(let s=0;s<this.hiddenSize;s++){const m=this.grad_Whidden[i][s]*d;this.m_Whidden[i][s]=this.beta1*this.m_Whidden[i][s]+(1-this.beta1)*m,this.v_Whidden[i][s]=this.beta2*this.v_Whidden[i][s]+(1-this.beta2)*m*m;const _=this.m_Whidden[i][s]/o,b=this.v_Whidden[i][s]/a;this.Whidden[i][s]-=n*(_/(Math.sqrt(b)+this.epsilon)+e*this.Whidden[i][s]),this.grad_Whidden[i][s]=0}for(let i=0;i<this.hiddenSize;i++)for(let s=0;s<this.embedSize;s++){const m=this.grad_Wout[i][s]*d;this.m_Wout[i][s]=this.beta1*this.m_Wout[i][s]+(1-this.beta1)*m,this.v_Wout[i][s]=this.beta2*this.v_Wout[i][s]+(1-this.beta2)*m*m;const _=this.m_Wout[i][s]/o,b=this.v_Wout[i][s]/a;this.Wout[i][s]-=n*(_/(Math.sqrt(b)+this.epsilon)+e*this.Wout[i][s]),this.grad_Wout[i][s]=0}this.gradCount=0}predict(t,n){const{probs:e}=this.forward(t,n);let d=0,o=e[0];for(let a=1;a<e.length;a++)e[a]>o&&(o=e[a],d=a);return d}_updateGridActivations(){const n=this._actualHiddenActivations;if(this.hiddenSize===256)for(let e=0;e<256;e++)this.hiddenActivations[e]=n[e];else if(this.hiddenSize<256)for(let e=0;e<256;e++)this.hiddenActivations[e]=n[e%this.hiddenSize];else{const e=this.hiddenSize/256;for(let d=0;d<256;d++)this.hiddenActivations[d]=n[Math.floor(d*e)]}}getGridActivations(){return new Float32Array(this.hiddenActivations)}}function W(g,t=!0){const n=[];for(let e=0;e<g;e++)for(let d=0;d<g;d++){if(t&&e>d)continue;const o=(e+d)%g;n.push({a:e,b:d,target:o,original:[e,d]})}return n}function w(g,t=.4){const n=[...g];for(let d=n.length-1;d>0;d--){const o=Math.floor(Math.random()*(d+1));[n[d],n[o]]=[n[o],n[d]]}const e=Math.floor(n.length*t);return{train:n.slice(0,e),test:n.slice(e)}}function p(g,t){let n=0;for(const e of t)g.predict(e.a,e.b)===e.target&&n++;return n/t.length}export{A as F,p as c,W as g,w as s};
