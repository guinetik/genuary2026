import{G as V,k as j,T as R,E as G}from"./index-Cw3cKsir.js";import{FactoredNetwork as B,generateAllPairs as X,splitData as E,calcAccuracy as _}from"./day19.grokking-BLQhquhM.js";import"./day19.utils-DeEDoNyc.js";class H{constructor(t,i,s=4){this.x=t,this.y=i,this.targetX=t,this.targetY=i,this.baseSize=s,this.activation=0,this.isActive=!1,this.isSelected=!1,this.isTarget=!1,this.isError=!1,this.isCorrect=!1,this.spawnScale=1}render(t,i){const{neuronIdle:s,neuronActive:r,neuronBright:o}=i;if(this.isActive){const e=this.baseSize,a=e*1.1,n=.2;t.fillStyle=`rgba(0, 255, 0, ${n})`,t.beginPath(),t.arc(this.x,this.y,a,0,Math.PI*2),t.fill();let h=r;(this.isSelected||this.isTarget)&&(h=o),t.fillStyle=h,t.globalAlpha=1,t.beginPath(),t.arc(this.x,this.y,e,0,Math.PI*2),t.fill(),t.globalAlpha=1}else t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,this.baseSize*.5,0,Math.PI*2),t.fill()}renderGrid(t,i,s=1,r=0,o=1,e=0,a=0,n=0,h=0,c=1){var D;if(this.spawnScale<=.01)return;const{neuronActive:d,neuronBright:l}=i,u=this.spawnScale,S=c,m=((D=p.neuron)==null?void 0:D.baseSize)*o*u*S,f=2*o*u,y=(a*.1+n*.15+h*.1)%1,T=Math.floor((.5+.5*Math.sin(y*6.28))*255),g=Math.floor((.5+.5*Math.sin(y*6.28+2.09))*255),k=Math.floor((.5+.5*Math.sin(y*6.28+4.18))*255);if(!(c>.4)){const O=Math.max(2,f);if(e>.5){const L=h*2%1*(16+4*2)-4,K=Math.abs(n-L),Y=Math.max(0,1-K/4),F=.3,z=F+Y*(1-F),U=O*(1+Y*.5);t.fillStyle=`rgb(${Math.floor(T*z)}, ${Math.floor(g*z)}, ${Math.floor(k*z)})`,t.beginPath(),t.arc(this.x,this.y,U,0,Math.PI*2),t.fill()}else t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,O,0,Math.PI*2),t.fill();return}const C=m;let M,b,A;e>.5?(M=T,b=g,A=k):e>.01?(M=Math.floor(T*e),b=Math.floor(255*(1-e)+g*e),A=Math.floor(255*(1-e)+k*e)):(M=0,b=255,A=255),t.fillStyle=`rgba(${M}, ${b}, ${A}, 0.15)`,t.beginPath(),t.arc(this.x,this.y,C*2.2,0,Math.PI*2),t.fill(),t.fillStyle=`rgba(${M}, ${b}, ${A}, 0.25)`,t.beginPath(),t.arc(this.x,this.y,C*1.5,0,Math.PI*2),t.fill(),t.fillStyle=`rgb(${M}, ${b}, ${A})`,t.beginPath(),t.arc(this.x,this.y,C,0,Math.PI*2),t.fill(),t.fillStyle="#fff",t.beginPath(),t.arc(this.x,this.y,C*.55,0,Math.PI*2),t.fill()}renderOutput(t,i,s=0,r=1,o=0){var f;if(this.spawnScale<=.01)return;const e=this.spawnScale,a=p.neuron;this.currentScale===void 0&&(this.currentScale=a.minScale);const n=s>.5?a.maxScale:a.minScale,h=n>this.currentScale?a.growSpeed:a.shrinkSpeed;this.currentScale+=(n-this.currentScale)*Math.min(1,h*.016);const c=this.currentScale,l=((f=p.neuron)==null?void 0:f.baseSize)*r*e*c,u=3*r*e,S=this.isError&&o<.5;if(c<.4){const y=this.isTarget||this.isSelected?.4:.2;t.fillStyle=`rgba(255, 255, 255, ${y})`,t.beginPath(),t.arc(this.x,this.y,Math.max(2,u),0,Math.PI*2),t.fill();return}let w,m;S?(w="#f44",m="rgba(255, 50, 50, 0.3)"):this.isCorrect?(w="#0f0",m="rgba(0, 255, 0, 0.3)"):(w="#fff",m="rgba(255, 255, 255, 0.2)"),t.fillStyle=m,t.beginPath(),t.arc(this.x,this.y,l*1.6,0,Math.PI*2),t.fill(),t.fillStyle=w,t.beginPath(),t.arc(this.x,this.y,l,0,Math.PI*2),t.fill(),t.fillStyle="rgba(100, 100, 100, 0.5)",t.beginPath(),t.arc(this.x,this.y,l*.4,0,Math.PI*2),t.fill()}}class Q{constructor(t,i,s=16,r=16){this.hiddenSize=t,this.nTokens=i,this.gridRows=s,this.gridCols=r,this.gridSize=s*r,this._buildHiddenMapping(),this._buildOutputMapping()}_buildHiddenMapping(){const s=Math.floor((this.gridRows-16)/2),r=Math.floor((this.gridCols-8*2)/2);this.hiddenToGrid=[],this.gridToHidden=new Int16Array(this.gridSize).fill(-1);for(let o=0;o<this.hiddenSize;o++){const e=Math.floor(o/8),a=o%8,n=s+e*2,h=r+a*2,c=[];for(let d=0;d<2;d++)for(let l=0;l<2;l++){const u=n+d,S=h+l;if(u>=0&&u<this.gridRows&&S>=0&&S<this.gridCols){const w=u*this.gridCols+S;c.push(w),this.gridToHidden[w]=o}}this.hiddenToGrid.push(c)}}_buildOutputMapping(){this.tokenToRow=new Int16Array(this.nTokens),this.rowToTokens=[];for(let i=0;i<16;i++)this.rowToTokens.push([]);for(let i=0;i<this.nTokens;i++){const s=Math.floor(i*16/this.nTokens);this.tokenToRow[i]=s,this.rowToTokens[s].push(i)}}getGridCells(t){return this.hiddenToGrid[t]||[]}getOutputRow(t){return this.tokenToRow[t]}getHiddenNeuron(t){return this.gridToHidden[t]}isMapped(t){return this.gridToHidden[t]>=0}getNeuronCenter(t){const s=Math.floor((this.gridRows-16)/2),r=Math.floor((this.gridCols-8*2)/2),o=Math.floor(t/8),e=t%8;return{row:s+o*2+.5,col:r+e*2+.5}}}const p={background:"#000",network:{nTokens:67,embedSize:500,hiddenSize:64,learningRate:.01,weightDecay:1,beta1:.9,beta2:.98,symmetric:!0,trainFraction:.4},training:{batchSize:64,epochsPerFrame:16,showGrokking:!0,useWorker:!0},grid:{rows:16,cols:16,neuronRows:8,neuronCols:8,baseSpacing:38,referenceSize:800},testAnimation:{testDuration:.8,inputToHidden:.2,hiddenToOutput:.2,holdAtPeak:.15,holdResult:.25,maxActiveNeurons:8},synapse:{trailLength:.25,headSize:5,trailWidth:2,glowSize:12,coreAlpha:.3},neuron:{minScale:.15,maxScale:1.2,growSpeed:25,shrinkSpeed:8,baseSize:8},colors:{neuronIdle:"#0a0",neuronActive:"#0f0",neuronBright:"#fff",text:"#0f0",testCase:"rgba(0, 255, 0, 0.3)"}};class q extends V{constructor(t){super(t),this.backgroundColor=p.background}init(){super.init(),console.log("[Day19] Creating FactoredNetwork...");const t=performance.now();try{this.network=new B(p.network),console.log(`[Day19] Network created in ${(performance.now()-t).toFixed(1)}ms`)}catch(n){console.error("[Day19] Failed to create network:",n);return}const{nTokens:i,symmetric:s,trainFraction:r}=p.network,o=X(i,s),e=E(o,r);this.trainData=e.train,this.testData=e.test,console.log(`Generated ${o.length} pairs (symmetric=${s}): ${this.trainData.length} train, ${this.testData.length} test`),this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.trainLoss=0,this.testLoss=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.neuronMapper=new Q(p.network.hiddenSize,p.network.nTokens,p.grid.rows,p.grid.cols),this.currentTestCase=null,this.testCaseIndex=0,this.testTime=0,this.testRunning=!1,this.currentHiddenActivations=null,this.currentOutputActivations=null,this.currentPrediction=null,this.activeHiddenNeurons=[],this.activeGridCells=[],this.nextTestCase=null,this.nextHiddenActivations=null,this.nextActiveNeurons=[],this.nextPrediction=null;const a=Math.min(this.width,this.height);if(this.scale=a/p.grid.referenceSize,this.gridSpacing=p.grid.baseSpacing*this.scale,this.synapseAnimationTime=0,this.outputFlashes=new Map,this.gridFlashes=new Map,this.activatedGridNeurons=new Set,this.activatedOutputNeurons=new Set,this.inputSynapseTargets=[],this.outputSynapseTargets=[],this.grokMode=0,this.grokThreshold=.6,this.outputNeurons=[],this.outputNeuronsInitialized=!1,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainData.length>0){const n=this.trainData[0];this.network.forward(n.a,n.b)}this.gridOffsetX=0,this.gridOffsetY=0,this.useWorker=p.training.useWorker,this.workerReady=!1,this.workerTraining=!1,this.useWorker&&this.initWorker(),this.inputDots=[],this.outputDots=[],this.fsm=new j({initial:"intro",context:this,states:{intro:{enter:()=>this.startIntroAnimation(),update:n=>this.updateIntro(n)},training:{enter:()=>this.startTraining(),update:n=>this.updateTraining(n)}}}),this.trainingOpacity=0,this.synapseOpacity=0,this.canvas.addEventListener("click",()=>{this.restart()}),this.grokModeOverride=!1,this.originalTestData=null,window.addEventListener("keydown",n=>{(n.key==="g"||n.key==="G")&&(this.grokModeOverride=!this.grokModeOverride,this.grokModeOverride?(this.originalTestData=this.testData,this.testData=[...this.trainData],this.grokMode=1,console.log(`[DEBUG] Grok mode ON - test set = train set (${this.testData.length} examples)`),this.worker&&(this.worker.postMessage({type:"grokMode",enabled:!0}),this.worker.postMessage({type:"syncWeights"}))):(this.originalTestData&&(this.testData=this.originalTestData,this.originalTestData=null),this.grokMode=0,console.log(`[DEBUG] Grok mode OFF - original test set restored (${this.testData.length} examples)`),this.worker&&this.worker.postMessage({type:"grokMode",enabled:!1})))})}initWorker(){try{this.worker=new Worker(new URL("/assets/day19.worker-CiCYPVIj.js",import.meta.url),{type:"module"}),this.worker.onmessage=t=>{const{type:i}=t.data;switch(i){case"state":this.epoch=t.data.epoch,this.trainAccuracy=t.data.trainAccuracy,this.testAccuracy=t.data.testAccuracy,this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.workerTraining=!1,this.workerReady=!0;break;case"forward":this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.cachedOutput=new Float32Array(t.data.outputActivations),this.cachedPrediction=t.data.prediction;break;case"syncWeights":if(this.network&&t.data.weights){const s=t.data.weights;this.network.embed=s.embed,this.network.Whidden=s.Whidden,this.network.Wout=s.Wout,console.log("[Main] Synced weights from worker"),this._weightsSynced=!0}break}},this.worker.onerror=t=>{console.error("Worker error:",t),this.useWorker=!1,this.workerReady=!1},this.worker.postMessage({type:"init",data:{config:p.network}}),console.log("Web Worker initialized for training")}catch(t){console.warn("Failed to create Web Worker, falling back to main thread:",t),this.useWorker=!1}}startIntroAnimation(){const t=this.width/2,i=this.height/2,{rows:s,cols:r}=p.grid;this.pendingTweens=0,this.gridOffsetX=this.width/2-r*this.gridSpacing/2,this.gridOffsetY=this.height/2-s*this.gridSpacing/2,this.gridNeurons=[];for(let e=0;e<s;e++)for(let a=0;a<r;a++){const n=this.gridOffsetX+a*this.gridSpacing,h=this.gridOffsetY+e*this.gridSpacing,c=new H(t,i,4*this.scale);c.targetX=n,c.targetY=h,c.spawnScale=0,this.gridNeurons.push(c);const l=Math.sqrt(Math.pow(a-r/2,2)+Math.pow(e-s/2,2))*.04;this.pendingTweens++,R.to(c,{x:n,y:h,spawnScale:1},.4,G.easeOutBack,{delay:.1+l,onComplete:()=>this.onTweenComplete()})}const o=r*this.gridSpacing;t-o/2-100*this.scale,t+o/2+100*this.scale,this.inputDots=[];for(let e=0;e<14;e++){const a={x:t,y:i,spawnScale:0};this.inputDots.push(a),this.pendingTweens++,R.to(a,{spawnScale:1},.3,G.easeOutBack,{delay:.05+e*.01,onComplete:()=>this.onTweenComplete()})}this.outputDots=[];for(let e=0;e<7;e++){const a={x:t,y:i,spawnScale:0};this.outputDots.push(a),this.pendingTweens++,R.to(a,{spawnScale:1},.3,G.easeOutBack,{delay:.1+e*.01,onComplete:()=>this.onTweenComplete()})}}onTweenComplete(){this.pendingTweens--,this.pendingTweens<=0&&this.fsm.is("intro")&&this.fsm.setState("training")}updateIntro(t){}startTraining(){this.trainingOpacity=0,this.synapseOpacity=0,R.to(this,{trainingOpacity:1},.8,G.easeOutQuad),R.to(this,{synapseOpacity:1},1.5,G.easeInOutQuad,{delay:.5})}updateTraining(t){R.updateAll(t),this.trainNetwork()}restart(){this.network=new B(p.network);const{nTokens:t,symmetric:i,trainFraction:s}=p.network,r=X(t,i),o=E(r,s);this.trainData=o.train,this.testData=o.test,this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.grokMode=0,this.grokModeOverride=!1,this.outputNeuronsInitialized=!1,this.outputNeuronsKeys=null,this.gridNeurons=null,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainingOpacity=0,this.synapseOpacity=0,this.testTime=0,this.testRunning=!1,this.testCaseIndex=0,this.currentTestCase=null,this.currentHiddenActivations=null,this.currentOutputActivations=null,this.currentPrediction=null,this.activeHiddenNeurons=[],this.activeGridCells=[],this.predictionRow=-1,this.targetRow=-1,this.nextTestCase=null,this.nextHiddenActivations=null,this.nextActiveNeurons=[],this.nextPrediction=null,this.useWorker&&this.worker&&(this.workerReady=!1,this.workerTraining=!1,this.worker.postMessage({type:"reset",data:{config:p.network}})),R.killAll(),this.fsm.setState("intro")}update(t){super.update(t);const i=Math.min(this.width,this.height);this.scale=i/p.grid.referenceSize,this.gridSpacing=p.grid.baseSpacing*this.scale,this.gridOffsetX=this.width/2-p.grid.cols*this.gridSpacing/2,this.gridOffsetY=this.height/2-p.grid.rows*this.gridSpacing/2,this.fsm.update(t),this.animTime+=t,this.updateTestCaseAnimation(t)}updateTestCaseAnimation(t){if(!this.fsm.is("training"))return;const i=p.testAnimation;if(!this.testRunning){this.startNewTestCase();return}this.testTime+=t,this.testTime>=i.testDuration&&this.startNewTestCase()}preloadNextTest(){if(this.testData.length===0)return;const t=(this.testCaseIndex+1)%this.testData.length;this.nextTestCase=this.testData[t];const{probs:i}=this.network.forward(this.nextTestCase.a,this.nextTestCase.b);this.nextHiddenActivations=new Float32Array(this.network._actualHiddenActivations);let s=0,r=i[0];for(let n=1;n<i.length;n++)i[n]>r&&(r=i[n],s=n);this.nextPrediction=s;const o=p.testAnimation.maxActiveNeurons,e=this.nextHiddenActivations,a=[];for(let n=0;n<e.length;n++)e[n]>.01&&a.push({idx:n,val:e[n]});a.sort((n,h)=>h.val-n.val),this.nextActiveNeurons=a.slice(0,o).map(n=>n.idx)}startNewTestCase(){if(this.testData.length!==0){if(this.nextTestCase)this.testCaseIndex=(this.testCaseIndex+1)%this.testData.length,this.currentTestCase=this.nextTestCase,this.currentHiddenActivations=this.nextHiddenActivations,this.currentPrediction=this.nextPrediction,this.activeHiddenNeurons=this.nextActiveNeurons,this.cachedPrediction=this.nextPrediction;else{this.testCaseIndex=0,this.currentTestCase=this.testData[0];const{probs:t}=this.network.forward(this.currentTestCase.a,this.currentTestCase.b);this.currentHiddenActivations=new Float32Array(this.network._actualHiddenActivations),this.cachedOutput=t;let i=0,s=t[0];for(let e=1;e<t.length;e++)t[e]>s&&(s=t[e],i=e);this.currentPrediction=i,this.cachedPrediction=i;const r=p.testAnimation.maxActiveNeurons,o=[];for(let e=0;e<this.currentHiddenActivations.length;e++)this.currentHiddenActivations[e]>.01&&o.push({idx:e,val:this.currentHiddenActivations[e]});o.sort((e,a)=>a.val-e.val),this.activeHiddenNeurons=o.slice(0,r).map(e=>e.idx)}this.activeGridCells=[];for(const t of this.activeHiddenNeurons){const i=this.neuronMapper.getGridCells(t);if(i.length>0){const s=i[Math.floor(Math.random()*i.length)];this.activeGridCells.push(s)}}this.predictionRow=this.currentPrediction!==null?this.neuronMapper.getOutputRow(this.currentPrediction):-1,this.targetRow=this.currentTestCase?this.neuronMapper.getOutputRow(this.currentTestCase.target):-1,this.testTime=0,this.testRunning=!0,this.outputNeuronsInitialized=!1,this.useWorker&&this.workerReady&&this.worker.postMessage({type:"forward",data:{a:this.currentTestCase.a,b:this.currentTestCase.b}}),this.preloadNextTest()}}trainNetwork(){const{epochsPerFrame:t,batchSize:i}=p.training,{nTokens:s}=p.network;if(this.useWorker&&this.workerReady&&!this.workerTraining){if(this.workerTraining=!0,this.worker.postMessage({type:"train",data:{epochsPerFrame:t,batchSize:i}}),this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokModeOverride){const r=this.trainAccuracy>=.95,e=r&&this.testAccuracy>=this.grokThreshold?1:0,a=this.grokMode>.5;this.grokMode+=(e-this.grokMode)*.05,!a&&this.grokMode>.5&&(this.currentTestCase=null,this.cachedOutput=null,this.cachedPrediction=null,this.useWorker&&this.workerReady&&!this._weightsSynced&&this.worker.postMessage({type:"syncWeights"})),r&&this.useWorker&&this.workerReady&&(!this._lastWeightSync||Date.now()-this._lastWeightSync>5e3)&&(this._lastWeightSync=Date.now(),this.worker.postMessage({type:"syncWeights"}))}return}if(!this.useWorker){this.network.resetGradients();for(let r=0;r<t;r++){for(let o=0;o<this.trainData.length;o++){const e=this.trainData[o],{cache:a}=this.network.forward(e.a,e.b);this.network.backward(e.target,a)}this.network.applyAdamW(this.trainData.length),this.epoch++}if(this.epoch%20===0){const r=this.trainData.slice(0,Math.min(100,this.trainData.length)),o=this.testData.slice(0,Math.min(100,this.testData.length));this.trainAccuracy=_(this.network,r),this.testAccuracy=_(this.network,o)}if(this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokkingDetected&&this.epoch>100){const r=this.accuracyHistory.slice(-50);if(r.length>=50){const o=r[0].test,e=r[r.length-1].test;this.trainAccuracy>.8&&e-o>.3&&(this.grokkingDetected=!0,this.grokkingEpoch=this.epoch)}}}}render(){const t=this.ctx,i=this.width,s=this.height;t.fillStyle="rgba(0, 0, 0, 0.2)",t.fillRect(0,0,i,s),this.updateOutputNeuronState(),this.drawSynapses(t),this.drawNeuronGrid(t),this.drawInputOutputNeurons(t),this.drawInputOutput(t),this.drawStats(t)}drawNeuronGrid(t){const{rows:i,cols:s}=p.grid,r=this.gridSpacing,o=this.fsm.is("intro"),e=this._lastSpacing&&Math.abs(this._lastSpacing-r)>1;if(this._lastSpacing=r,!this.gridNeurons||this.gridNeurons.length!==i*s||e&&!o){this.gridNeurons=[];for(let f=0;f<i;f++)for(let y=0;y<s;y++){const T=this.gridOffsetX+y*r,g=this.gridOffsetY+f*r;this.gridNeurons.push(new H(T,g,4*this.scale))}}const a=new Map;if(this.activeGridCells)for(let f=0;f<this.activeGridCells.length;f++)a.set(this.activeGridCells[f],f);const n=p.testAnimation,h=p.neuron,c=this.testTime||0,d=n.inputToHidden,l=d+n.hiddenToOutput,u=n.holdAtPeak,S=l+u,w=Math.min(1,c/d),m=c>S?(c-S)/n.holdResult:0;for(let f=0;f<i;f++)for(let y=0;y<s;y++){const T=f*s+y,g=this.gridNeurons[T];g.x=this.gridOffsetX+y*r,g.y=this.gridOffsetY+f*r;const k=this.neuronMapper.isMapped(T),v=a.get(T),C=v!==void 0;g.currentScale===void 0&&(g.currentScale=h.minScale);let M=h.minScale;if(o)M=h.minScale;else if(!k)M=h.minScale;else if(C&&this.testRunning){const A=v/this.activeGridCells.length*.3;if(Math.max(0,(w-A)/(1-A))>=.98)if(m>0){const O=(this.activeGridCells.length-1-v)/this.activeGridCells.length*.5,P=Math.max(0,(m-O)/(1-O));M=h.maxScale-(h.maxScale-h.minScale)*Math.min(1,P)}else M=h.maxScale;else M=h.minScale}else M=h.minScale;const b=M>g.currentScale?h.growSpeed:h.shrinkSpeed;g.currentScale+=(M-g.currentScale)*Math.min(1,b*.016),g.activation=(g.currentScale-h.minScale)/(h.maxScale-h.minScale),g.isActive=g.currentScale>h.minScale+.1,g.renderGrid(t,p.colors,1,g.activation,this.scale,this.grokMode,f,y,this.animTime,g.currentScale)}}updateOutputNeuronState(){if(!this.currentTestCase||!this.fsm.is("training"))return;const t=this.width/2,i=p.grid.cols*this.gridSpacing,s=t+i/2+50*this.scale,r=this.cachedOutput||this.currentOutputActivations,o=this.cachedPrediction??this.currentPrediction,e=16,a=this.gridSpacing,n=this.gridOffsetY;if(!this.outputNeurons||this.outputNeurons.length!==e){this.outputNeurons=[];for(let l=0;l<e;l++){const u=n+l*a;this.outputNeurons.push(new H(s,u,4*this.scale))}}const h=o!=null?this.neuronMapper.getOutputRow(o):-1,c=this.currentTestCase.target!==void 0?this.neuronMapper.getOutputRow(this.currentTestCase.target):-1,d=new Float32Array(e);if(r)for(let l=0;l<r.length;l++){const u=this.neuronMapper.getOutputRow(l);r[l]>d[u]&&(d[u]=r[l])}for(let l=0;l<e;l++){const u=this.outputNeurons[l];u.x=s,u.y=n+l*a,u.isTarget=l===c,u.isSelected=l===h,u.activation=d[l]}}drawInputOutputNeurons(t){if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0||!this.outputNeurons||this.outputNeurons.length===0)return;t.save(),t.globalAlpha=this.trainingOpacity;const i=16,s=p.testAnimation,r=this.testTime||0,o=s.inputToHidden,e=r>o?Math.min(1,(r-o)/s.hiddenToOutput):0,a=this.cachedPrediction??this.currentPrediction,n=a!=null?this.neuronMapper.getOutputRow(a):-1,h=this.targetRow;for(let c=0;c<i;c++){const d=this.outputNeurons[c];let l=0;this.testRunning&&e>0&&(c===n||c===h)&&(l=Math.max(0,(e-.3)/.7)>=.98?1:0),d.activation=l;const u=n===h,S=c===n,w=c===h;d.isError=!1,d.isCorrect=!1,l>.1&&(u&&S?d.isCorrect=!0:u||(S?d.isError=!0:w&&(d.isCorrect=!0))),d.renderOutput(t,p.colors,l,this.scale,this.grokMode)}t.restore()}drawTronSynapse(t,i,s,r,o,e,a="#0ff",n=!0){if(e<=0)return;const h=p.synapse,c=this.scale,d=1-Math.pow(1-Math.min(1,e),2),l=i+(r-i)*d,u=s+(o-s)*d,S=Math.max(0,d-h.trailLength),w=i+(r-i)*S,m=s+(o-s)*S,f=a==="#0ff",y=0,T=255,g=f?255:0;if(e<1){const k=t.createLinearGradient(w,m,l,u);k.addColorStop(0,`rgba(${y}, ${T}, ${g}, 0)`),k.addColorStop(.5,`rgba(${y}, ${T}, ${g}, 0.15)`),k.addColorStop(1,`rgba(${y}, ${T}, ${g}, 0.4)`),t.strokeStyle=k,t.lineWidth=h.glowSize*c*(n?1:.6),t.lineCap="round",t.beginPath(),t.moveTo(w,m),t.lineTo(l,u),t.stroke()}if(e<1){const k=t.createLinearGradient(w,m,l,u);k.addColorStop(0,`rgba(${y}, ${T}, ${g}, 0)`),k.addColorStop(.3,`rgba(${y}, ${T}, ${g}, 0.6)`),k.addColorStop(1,`rgba(${y}, ${T}, ${g}, 1)`),t.strokeStyle=k,t.lineWidth=h.trailWidth*c*(n?1:.7),t.beginPath(),t.moveTo(w,m),t.lineTo(l,u),t.stroke()}if(e>0){const k=Math.min(d,1),v=i+(r-i)*k,C=s+(o-s)*k;t.strokeStyle=`rgba(${y}, ${T}, ${g}, ${h.coreAlpha*(n?1:.5)})`,t.lineWidth=1*c,t.beginPath(),t.moveTo(i,s),t.lineTo(v,C),t.stroke()}if(e>0&&e<1){const k=t.createRadialGradient(l,u,0,l,u,h.headSize*2*c);k.addColorStop(0,"rgba(255, 255, 255, 0.9)"),k.addColorStop(.3,`rgba(${y}, ${T}, ${g}, 0.6)`),k.addColorStop(1,`rgba(${y}, ${T}, ${g}, 0)`),t.fillStyle=k,t.beginPath(),t.arc(l,u,h.headSize*2*c,0,Math.PI*2),t.fill(),t.fillStyle="#fff",t.beginPath(),t.arc(l,u,h.headSize*.5*c,0,Math.PI*2),t.fill()}}drawSynapses(t){if(!this.currentTestCase||!this.fsm.is("training")||!this.testRunning||this.synapseOpacity<=0)return;t.save(),t.globalAlpha=this.synapseOpacity;const i=this.width/2,s=this.height/2,r=p.grid.cols*this.gridSpacing,{cols:o}=p.grid,e=this.gridSpacing,a=p.testAnimation,n=this.testTime,h=a.inputToHidden,c=Math.min(1,n/h),d=n>h?Math.min(1,(n-h)/a.hiddenToOutput):0,l=i-r/2-100*this.scale,u=l,S=s-40*this.scale,w=l,m=s+40*this.scale,f=i+r/2+50*this.scale,y=this.gridSpacing,T=this.gridOffsetY;if(c>0&&this.activeGridCells.length>0)for(let g=0;g<this.activeGridCells.length;g++){const k=this.activeGridCells[g],v=Math.floor(k/o),C=k%o,M=this.gridOffsetX+C*e,b=this.gridOffsetY+v*e,A=g%2===0,D=A?u:w,O=A?S:m,P=g/this.activeGridCells.length*.3,$=Math.max(0,(c-P)/(1-P));this.drawTronSynapse(t,D,O,M,b,$,"#0ff",!0)}if(d>0&&this.activeGridCells.length>0){const g=this.cachedPrediction??this.currentPrediction,k=g!=null?this.neuronMapper.getOutputRow(g):-1,v=this.targetRow;for(let C=0;C<this.activeGridCells.length;C++){const M=this.activeGridCells[C],b=Math.floor(M/o),A=M%o,D=this.gridOffsetX+A*e,O=this.gridOffsetY+b*e;if(k>=0){const P=f,$=T+k*y,N=C/this.activeGridCells.length*.3,W=Math.max(0,(d-N)/(1-N));this.drawTronSynapse(t,D,O,P,$,W,"#0ff",!0)}if(v>=0&&v!==k){const P=f,$=T+v*y,N=C/this.activeGridCells.length*.3,W=Math.max(0,(d-N)/(1-N));this.drawTronSynapse(t,D,O,P,$,W,"#0f0",!1)}}}t.restore()}drawInputOutput(t){var M,b;if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const{text:i,neuronActive:s,neuronBright:r}=p.colors,o=this.currentTestCase.a??((M=this.currentTestCase.original)==null?void 0:M[0])??0,e=this.currentTestCase.b??((b=this.currentTestCase.original)==null?void 0:b[1])??0,a=this.currentTestCase.target,n=this.cachedPrediction??this.network.predict(o,e),h=n===a,c=this.width/2,d=this.height/2,l=p.grid.cols*this.gridSpacing;p.grid.rows*this.gridSpacing;const u=c-l/2-100*this.scale,S=c+l/2+150*this.scale,w=4*this.scale,m=18*this.scale,f=10,y=d-40*this.scale;this.drawNumberAsDots(t,o,u,y,w,m,f,s),t.fillStyle=i,t.font=`bold ${Math.round(32*this.scale)}px monospace`,t.textAlign="center",t.textBaseline="middle",t.fillText("+",u,d);const T=d+40*this.scale;this.drawNumberAsDots(t,e,u,T,w,m,f,s),this.drawNumberAsDots(t,a,S,d,w,m,f,r);const g=40*this.scale,v=40*this.scale+22*this.scale*6+60*this.scale+30*this.scale;t.textAlign="left",t.font=`bold ${Math.round(14*this.scale)}px monospace`,t.fillStyle=i;const C=o+e;t.fillText(`${o} + ${e} = ${C}`,g,v),t.font=`${Math.round(12*this.scale)}px monospace`,t.fillText(`mod ${p.network.nTokens} = ${a}`,g,v+18*this.scale),t.font=`bold ${Math.round(12*this.scale)}px monospace`,t.fillStyle=h?"#0ff":"#f00",t.fillText(`Predicted: ${n} ${h?"✓":"✗"}`,g,v+36*this.scale),t.restore()}drawNumberAsDots(t,i,s,r,o,e,a,n){const h=p.network.nTokens,c=Math.max(1,Math.ceil(Math.log2(h))),d=[];let l=i;for(let w=c-1;w>=0;w--){const m=l>>w&1;d.push(m)}const u=Math.ceil(c/a),S=r-(u-1)*e/2;t.globalAlpha=1;for(let w=0;w<c;w++){const m=d[w],f=Math.floor(w/a),y=w%a,g=(Math.min(a,c-f*a)-1)*e,k=s-g/2+y*e,v=S+f*e,C=new H(k,v,o);C.isActive=m===1,C.activation=m===1?1:0,C.render(t,p.colors)}}drawStats(t){if(!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const i=40*this.scale,s=40*this.scale,r=22*this.scale;if(t.fillStyle="#888",t.font=`${Math.round(14*this.scale)}px monospace`,t.textAlign="left",t.textBaseline="top",t.fillText(`Epoch: ${this.epoch}`,i,s),t.fillText(`Train: ${(this.trainAccuracy*100).toFixed(1)}%`,i,s+r),t.fillText(`Test: ${(this.testAccuracy*100).toFixed(1)}%`,i,s+r*2),this.grokMode>.5?(t.fillStyle="#f0f",t.fillText("✨ GROKKED!",i,s+r*3)):this.grokkingDetected&&(t.fillStyle="#0ff",t.fillText("✓ GROKKING!",i,s+r*3)),this.accuracyHistory.length>2){const o=150*this.scale,e=50*this.scale,a=i,n=s+r*6;t.fillStyle="rgba(0, 0, 0, 0.7)",t.fillRect(a-5,n-e-5,o+10,e+10),t.strokeStyle="rgba(0, 255, 0, 0.3)",t.lineWidth=1,t.strokeRect(a-5,n-e-5,o+10,e+10),t.strokeStyle="rgba(255, 255, 255, 0.15)",t.beginPath(),t.moveTo(a,n-e*.5),t.lineTo(a+o,n-e*.5),t.stroke();const h=Math.max(1,Math.floor(this.accuracyHistory.length/100));t.strokeStyle="#0f0",t.lineWidth=2.5*this.scale,t.shadowColor="#0f0",t.shadowBlur=4,t.beginPath();let c=!0;for(let d=0;d<this.accuracyHistory.length;d+=h){const l=this.accuracyHistory[d],u=a+d/this.accuracyHistory.length*o,S=n-l.train*e;c?(t.moveTo(u,S),c=!1):t.lineTo(u,S)}t.stroke(),t.strokeStyle="#0ff",t.shadowColor="#0ff",t.beginPath(),c=!0;for(let d=0;d<this.accuracyHistory.length;d+=h){const l=this.accuracyHistory[d],u=a+d/this.accuracyHistory.length*o,S=n-l.test*e;c?(t.moveTo(u,S),c=!1):t.lineTo(u,S)}t.stroke(),t.shadowBlur=0,t.font=`${Math.round(10*this.scale)}px monospace`,t.fillStyle="#0f0",t.fillText("Train",a,n+12*this.scale),t.fillStyle="#0ff",t.fillText("Test",a+50*this.scale,n+12*this.scale)}t.restore()}}function et(I){const t=new q(I);return t.start(),{stop:()=>t.stop(),game:t}}export{et as default};
