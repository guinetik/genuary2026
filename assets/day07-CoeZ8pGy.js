import{G as P,P as C}from"./gcanvas.es-CMQjSjBY.js";const l={render:{scaleFactor:2,dithering:.6},animation:{zoomSpeed:.08,zoomMin:.5,zoomMax:4,rotationSpeed:.05,colorCycleSpeed:15,pulseSpeed:.5},mouse:{radius:.2,warpStrength:30}},A=[{name:"SIERPINSKI MIRROR",desc:"(x & y) interlocked",fn:(i,t,e)=>{const s=Math.floor(e*15),n=128,o=(i+s)%n,a=(t+s)%n,h=(o&a)===0,r=n-1-o,d=n-1-a,f=(r&d)===0;return h||f}},{name:"XOR PULSE",desc:"(x ^ y) + pulse",fn:(i,t,e)=>{const s=Math.sin(e*3)*40,n=100+Math.sin(e*1.5)*50;return((i^t)+s&255)<n}},{name:"NESTED BREATHING",desc:"(x^y) & ((x>>s)^(y>>s))",fn:(i,t,e)=>{const s=1+Math.floor((Math.sin(e*.8)+1)*2);return((i^t)&(i>>s^t>>s))===0}},{name:"RULE 90 FLOW",desc:"(x^y) & ((x>>2)^(y>>2)) + drift",fn:(i,t,e)=>{const s=Math.floor(e*30),n=i+s,o=t+s;return((n^o)&(n>>2^o>>2))===0}},{name:"BOOLEAN WEAVE",desc:"(x&y) ^ (x|y) + wave",fn:(i,t,e)=>{const s=Math.sin(e*2+(i+t)*.01)*30;return((i&t^(i|t))+s&255)<128}},{name:"MODULAR DANCE",desc:"(x^y) % n, n varies",fn:(i,t,e)=>{const s=11+Math.floor(Math.sin(e*.5)*6),n=s/2+Math.sin(e*2)*2;return(i^t)%s<n}},{name:"NAND LATTICE",desc:"~(x&y) & ~(x|y)",fn:(i,t,e)=>{const s=Math.floor(e*20),n=i+s,o=t+s,a=~(n&o),h=~(n|o);return((a^h)&63)<32}},{name:"FRACTAL MORPH",desc:"(x|y) & (x^y) blend",fn:(i,t,e)=>{const s=(Math.sin(e)+1)/2,n=(i|t)&(i^t)&255,o=(i&t|i^t)&255;return n*s+o*(1-s)<100}},{name:"QUAD SIERPINSKI",desc:"4-way tiled",fn:(i,t,e)=>{const s=Math.floor(e*20),n=128,o=((i+s)%n+n)%n,a=((t+s)%n+n)%n,h=n/2,r=o<h?o:n-1-o,d=a<h?a:n-1-a;return(r&d)===0}},{name:"WAVE XOR",desc:"(x^y) + sin(x) + cos(y)",fn:(i,t,e)=>{const s=Math.sin(e*2+i*.02)*30,n=Math.cos(e*1.5+t*.02)*30;return((i^t)+s+n&255)<128}}];class W extends P{constructor(t){super(t),this.backgroundColor="#000"}init(){super.init(),C.init(this.ctx),this.container=this.canvas.parentElement,this.container&&this.enableFluidSize(this.container),this.time=0,this.formulaIndex=0,this.zoom=1,this.zoomDir=1,this.rotation=0,this.hueOffset=0,this.mouseX=-1,this.mouseY=-1,this.mouseActive=!1,this.handleResize(),this.canvas.addEventListener("click",()=>{this.formulaIndex=(this.formulaIndex+1)%A.length}),this.canvas.addEventListener("mousemove",t=>{const e=this.canvas.getBoundingClientRect();this.mouseX=(t.clientX-e.left)/e.width,this.mouseY=(t.clientY-e.top)/e.height,this.mouseActive=!0}),this.canvas.addEventListener("mouseleave",()=>{this.mouseActive=!1})}handleResize(){this._lastCanvasW=this.width,this._lastCanvasH=this.height,this.renderWidth=Math.max(1,Math.floor(this.width/l.render.scaleFactor)),this.renderHeight=Math.max(1,Math.floor(this.height/l.render.scaleFactor)),this.imageData=C.img.createImageData(this.renderWidth,this.renderHeight)}update(t){super.update(t),this.time+=t,(this.width!==this._lastCanvasW||this.height!==this._lastCanvasH)&&this.handleResize(),this.zoom+=l.animation.zoomSpeed*this.zoomDir*t,this.zoom>l.animation.zoomMax?this.zoomDir=-1:this.zoom<l.animation.zoomMin&&(this.zoomDir=1),this.rotation+=l.animation.rotationSpeed*t,this.hueOffset+=l.animation.colorCycleSpeed*t}render(){const t=this.ctx,e=this.width,s=this.height;this.renderFractal(),t.putImageData(this.imageData,0,0),t.imageSmoothingEnabled=!1,t.drawImage(t.canvas,0,0,this.renderWidth,this.renderHeight,0,0,e,s),this.drawOverlay(t,e,s)}renderFractal(){const t=this.imageData.data,e=this.renderWidth,s=this.renderHeight,n=A[this.formulaIndex],o=this.time,a=e/2,h=s/2,r=Math.min(e,s)*this.zoom,d=Math.cos(this.rotation),f=Math.sin(this.rotation),g=Math.sin(o*l.animation.pulseSpeed*Math.PI*2)*.5+.5,c=this.mouseX*e,D=this.mouseY*s,I=Math.min(e,s)*l.mouse.radius,b=l.render.dithering;for(let p=0;p<s;p++)for(let F=0;F<e;F++){const M=(p*e+F)*4;let v=(F-a)/r,S=(p-h)/r;const O=v*d-S*f,L=v*f+S*d;if(this.mouseActive){const x=F-c,u=p-D,m=Math.sqrt(x*x+u*u);if(m<I&&m>0){const y=(1-m/I)*l.mouse.warpStrength;v+=x/m*y/r,S+=u/m*y/r}}const E=256,R=Math.floor((O+2)*E)&65535,w=Math.floor((L+2)*E)&65535;if(n.fn(R,w,o)){const x=((R^w)&255)/255,u=.5+x*.5*g,m=(120+this.hueOffset+x*30)%360,[y,T,N]=this.hslToRgb(m/360,.9,.3+u*.4),z=(Math.random()-.5)*b;t[M]=Math.max(0,Math.min(255,y+z)),t[M+1]=Math.max(0,Math.min(255,T+z)),t[M+2]=Math.max(0,Math.min(255,N+z))}else{const u=5+(R+w&15)/15*10,m=(Math.random()-.5)*b;t[M]=Math.max(0,Math.min(255,u*.2+m)),t[M+1]=Math.max(0,Math.min(255,u*.5+m)),t[M+2]=Math.max(0,Math.min(255,u*.3+m))}t[M+3]=255}}drawOverlay(t,e,s){const n=A[this.formulaIndex];t.fillStyle="rgba(0, 0, 0, 0.7)",t.fillRect(10,10,220,50),t.font='16px "Fira Code", monospace',t.fillStyle="#fff",t.textAlign="left",t.textBaseline="top",t.fillText(n.name,20,18),t.font='12px "Fira Code", monospace',t.fillStyle="rgba(255, 255, 255, 0.7)",t.fillText(n.desc,20,40),t.font='10px "Fira Code", monospace',t.fillStyle="rgba(255, 255, 255, 0.4)",t.textAlign="right",t.fillText("click to change formula",e-15,s-15)}hslToRgb(t,e,s){let n,o,a;if(e===0)n=o=a=s;else{const h=(f,g,c)=>(c<0&&(c+=1),c>1&&(c-=1),c<.16666666666666666?f+(g-f)*6*c:c<.5?g:c<.6666666666666666?f+(g-f)*(.6666666666666666-c)*6:f),r=s<.5?s*(1+e):s+e-s*e,d=2*s-r;n=h(d,r,t+1/3),o=h(d,r,t),a=h(d,r,t-1/3)}return[Math.round(n*255),Math.round(o*255),Math.round(a*255)]}}function B(i){const t=new W(i);return t.start(),{stop:()=>t.stop(),game:t}}export{B as default};
