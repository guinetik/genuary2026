import{G as z,j as H,T as N,E as F}from"./gcanvas.es-DYEWWlgH.js";import{FactoredNetwork as I,generateAllPairs as G,splitData as _,calcAccuracy as B}from"./day19.grokking-BLQhquhM.js";import"./day19.utils-DeEDoNyc.js";class P{constructor(t,h,e=4){this.x=t,this.y=h,this.targetX=t,this.targetY=h,this.baseSize=e,this.activation=0,this.isActive=!1,this.isSelected=!1,this.isTarget=!1,this.isError=!1,this.spawnScale=1}render(t,h){const{neuronIdle:e,neuronActive:i,neuronBright:n}=h;if(this.isActive){const s=this.baseSize,r=s*1.1,c=.2;t.fillStyle=`rgba(0, 255, 0, ${c})`,t.beginPath(),t.arc(this.x,this.y,r,0,Math.PI*2),t.fill();let a=i;(this.isSelected||this.isTarget)&&(a=n),t.fillStyle=a,t.globalAlpha=1,t.beginPath(),t.arc(this.x,this.y,s,0,Math.PI*2),t.fill(),t.globalAlpha=1}else t.fillStyle="rgba(0, 255, 0, 0.1)",t.beginPath(),t.arc(this.x,this.y,this.baseSize*.5,0,Math.PI*2),t.fill()}renderGrid(t,h,e=1,i=0,n=1,s=0,r=0,c=0,a=0){if(this.spawnScale<=.01)return;const{neuronActive:u,neuronBright:g}=h,w=Math.min(1,this.activation/e),o=Math.min(1,w+i*.5),y=i>.1,l=this.spawnScale,O=4*n*l,$=2*n*l,d=(r*.1+c*.15+a*.1)%1,m=Math.floor((.5+.5*Math.sin(d*6.28))*255),k=Math.floor((.5+.5*Math.sin(d*6.28+2.09))*255),f=Math.floor((.5+.5*Math.sin(d*6.28+4.18))*255);if(o<.05&&!y){if(s>.5){const M=.3+s*.2,D=Math.floor(m*M),A=Math.floor(k*M),C=Math.floor(f*M);t.fillStyle=`rgb(${D}, ${A}, ${C})`,t.beginPath(),t.arc(this.x,this.y,$*(1+s*.5),0,Math.PI*2),t.fill()}else if(s>.01){const M=(.1+s*.4)*l,D=Math.floor(255*(1-s)+k*s),A=Math.floor(0*(1-s)+m*s),C=Math.floor(0*(1-s)+f*s);t.fillStyle=`rgba(${A}, ${D}, ${C}, ${M})`,t.beginPath(),t.arc(this.x,this.y,$,0,Math.PI*2),t.fill()}else t.fillStyle=`rgba(0, 255, 0, ${.1*l})`,t.beginPath(),t.arc(this.x,this.y,$,0,Math.PI*2),t.fill();return}const T=(O+o*3*n+i*2*n)*l;let b,S;if(s>.5)if(y){const M=Math.min(255,m+Math.floor(i*100)),D=Math.min(255,k+Math.floor(i*100)),A=Math.min(255,f+Math.floor(i*100));b=`rgb(${M}, ${D}, ${A})`,S=`rgba(${m}, ${k}, ${f}, ${(.4+i*.5)*l})`}else b=`rgb(${m}, ${k}, ${f})`,S=`rgba(${m}, ${k}, ${f}, ${(.15+o*.3)*l})`;else if(y){const M=Math.floor(i*255),D=Math.floor(M*(1-s)+Math.min(255,m+100)*s),A=Math.floor(255*(1-s)+Math.min(255,k+100)*s),C=Math.floor(M*(1-s)+Math.min(255,f+100)*s);b=`rgb(${D}, ${A}, ${C})`;const Y=Math.floor(0*(1-s)+m*s),X=Math.floor(255*(1-s)+k*s),R=Math.floor(255*(1-s)+f*s);S=`rgba(${Y}, ${X}, ${R}, ${(.3+i*.4)*l})`}else if(o>.5)s>.01?(b=`rgb(${m}, ${k}, ${f})`,S=`rgba(${m}, ${k}, ${f}, ${(.1+o*.25)*l})`):(b=g,S=`rgba(0, 255, 0, ${(.1+o*.25)*l})`);else if(s>.01){const D=Math.floor(m*.7),A=Math.floor(k*.7),C=Math.floor(f*.7);b=`rgb(${D}, ${A}, ${C})`,S=`rgba(${m}, ${k}, ${f}, ${(.1+o*.25)*l})`}else b=u,S=`rgba(0, 255, 0, ${(.1+o*.25)*l})`;const v=1.6+i*.5;t.fillStyle=S,t.beginPath(),t.arc(this.x,this.y,T*v,0,Math.PI*2),t.fill(),t.fillStyle=b,t.beginPath(),t.arc(this.x,this.y,T,0,Math.PI*2),t.fill(),s<.5&&(o>.2||y)&&l>.5&&(t.fillStyle="#fff",t.beginPath(),t.arc(this.x,this.y,T*.3,0,Math.PI*2),t.fill())}renderOutput(t,h,e=0,i=1,n=0){if(this.spawnScale<=.01)return;const s=this.spawnScale,r=4*i*s,c=2*i*s,a=e,u=this.isError&&n<.5;if(a<.05){const l=this.isTarget||this.isSelected?.25:.1;t.fillStyle=u?`rgba(255, 0, 0, ${l*s})`:`rgba(0, 255, 0, ${l*s})`,t.beginPath(),t.arc(this.x,this.y,c,0,Math.PI*2),t.fill();return}const g=(r+a*5*i)*s;let w,o;if(u)w=`rgb(${Math.floor(200+a*55)}, ${Math.floor(a*50)}, ${Math.floor(a*50)})`,o=`rgba(255, 50, 50, ${a*.5*s})`;else if(this.isTarget&&this.isSelected){const l=Math.floor(200+a*55);w=`rgb(${Math.floor(a*200)}, ${l}, ${Math.floor(a*200)})`,o=`rgba(100, 255, 100, ${a*.5*s})`}else{const l=Math.floor(a*255);w=`rgb(${l}, 255, ${l})`,o=`rgba(0, 255, 255, ${a*.5*s})`}const y=1.5+a*.8;t.fillStyle=o,t.beginPath(),t.arc(this.x,this.y,g*y,0,Math.PI*2),t.fill(),t.fillStyle=w,t.beginPath(),t.arc(this.x,this.y,g,0,Math.PI*2),t.fill(),a>.3&&(t.fillStyle=`rgba(255, 255, 255, ${a})`,t.beginPath(),t.arc(this.x,this.y,g*.3,0,Math.PI*2),t.fill())}}const p={background:"#000",network:{nTokens:67,embedSize:500,hiddenSize:64,learningRate:.01,weightDecay:1,beta1:.9,beta2:.98,symmetric:!0,trainFraction:.4},training:{batchSize:64,epochsPerFrame:16,showGrokking:!0,useWorker:!0},grid:{rows:16,cols:16,baseSpacing:38,referenceSize:800},timing:{flashDuration:.5,activationDuration:.4,traceLength:.4,connectionCycle:.5},colors:{neuronIdle:"#0a0",neuronActive:"#0f0",neuronBright:"#fff",text:"#0f0",testCase:"rgba(0, 255, 0, 0.3)"}};class E extends z{constructor(t){super(t),this.backgroundColor=p.background}init(){super.init(),console.log("[Day19] Creating FactoredNetwork...");const t=performance.now();try{this.network=new I(p.network),console.log(`[Day19] Network created in ${(performance.now()-t).toFixed(1)}ms`)}catch(c){console.error("[Day19] Failed to create network:",c);return}const{nTokens:h,symmetric:e,trainFraction:i}=p.network,n=G(h,e),s=_(n,i);this.trainData=s.train,this.testData=s.test,console.log(`Generated ${n.length} pairs (symmetric=${e}): ${this.trainData.length} train, ${this.testData.length} test`),this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.trainLoss=0,this.testLoss=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.currentTestCase=null,this.testCaseTime=0;const r=Math.min(this.width,this.height);if(this.scale=r/p.grid.referenceSize,this.gridSpacing=p.grid.baseSpacing*this.scale,this.synapseAnimationTime=0,this.outputFlashes=new Map,this.gridFlashes=new Map,this.lastGridFlashIdx=-1,this.lastOutputFlashIdx=-1,this.lastOutputSourceFlashKey=null,this.activatedGridNeurons=new Set,this.activatedOutputNeurons=new Set,this.currentTestCaseId=null,this.grokMode=0,this.grokThreshold=.6,this.outputNeurons=[],this.outputNeuronsInitialized=!1,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainData.length>0){const c=this.trainData[0];this.network.forward(c.a,c.b)}this.gridOffsetX=0,this.gridOffsetY=0,this.useWorker=p.training.useWorker,this.workerReady=!1,this.workerTraining=!1,this.useWorker&&this.initWorker(),this.inputDots=[],this.outputDots=[],this.fsm=new H({initial:"intro",context:this,states:{intro:{enter:()=>this.startIntroAnimation(),update:c=>this.updateIntro(c)},training:{enter:()=>this.startTraining(),update:c=>this.updateTraining(c)}}}),this.trainingOpacity=0,this.synapseOpacity=0,this.canvas.addEventListener("click",()=>{this.restart()}),this.grokModeOverride=!1,this.originalTestData=null,window.addEventListener("keydown",c=>{(c.key==="g"||c.key==="G")&&(this.grokModeOverride=!this.grokModeOverride,this.grokModeOverride?(this.originalTestData=this.testData,this.testData=[...this.trainData],this.grokMode=1,console.log(`[DEBUG] Grok mode ON - test set = train set (${this.testData.length} examples)`),this.worker&&(this.worker.postMessage({type:"grokMode",enabled:!0}),this.worker.postMessage({type:"syncWeights"}))):(this.originalTestData&&(this.testData=this.originalTestData,this.originalTestData=null),this.grokMode=0,console.log(`[DEBUG] Grok mode OFF - original test set restored (${this.testData.length} examples)`),this.worker&&this.worker.postMessage({type:"grokMode",enabled:!1})))})}initWorker(){try{this.worker=new Worker(new URL("/assets/day19.worker-CiCYPVIj.js",import.meta.url),{type:"module"}),this.worker.onmessage=t=>{const{type:h}=t.data;switch(h){case"state":this.epoch=t.data.epoch,this.trainAccuracy=t.data.trainAccuracy,this.testAccuracy=t.data.testAccuracy,this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.workerTraining=!1,this.workerReady=!0;break;case"forward":this.network&&(this.network.hiddenActivations=new Float32Array(t.data.hiddenActivations),this.network.outputActivations=new Float32Array(t.data.outputActivations)),this.cachedOutput=new Float32Array(t.data.outputActivations),this.cachedPrediction=t.data.prediction;break;case"syncWeights":if(this.network&&t.data.weights){const e=t.data.weights;this.network.embed=e.embed,this.network.Whidden=e.Whidden,this.network.Wout=e.Wout,console.log("[Main] Synced weights from worker"),this._weightsSynced=!0}break}},this.worker.onerror=t=>{console.error("Worker error:",t),this.useWorker=!1,this.workerReady=!1},this.worker.postMessage({type:"init",data:{config:p.network}}),console.log("Web Worker initialized for training")}catch(t){console.warn("Failed to create Web Worker, falling back to main thread:",t),this.useWorker=!1}}startIntroAnimation(){const t=this.width/2,h=this.height/2,{rows:e,cols:i}=p.grid;this.pendingTweens=0,this.gridOffsetX=this.width/2-i*this.gridSpacing/2,this.gridOffsetY=this.height/2-e*this.gridSpacing/2,this.gridNeurons=[];for(let s=0;s<e;s++)for(let r=0;r<i;r++){const c=this.gridOffsetX+r*this.gridSpacing,a=this.gridOffsetY+s*this.gridSpacing,u=new P(t,h,4*this.scale);u.targetX=c,u.targetY=a,u.spawnScale=0,this.gridNeurons.push(u);const w=Math.sqrt(Math.pow(r-i/2,2)+Math.pow(s-e/2,2))*.04;this.pendingTweens++,N.to(u,{x:c,y:a,spawnScale:1},.4,F.easeOutBack,{delay:.1+w,onComplete:()=>this.onTweenComplete()})}const n=i*this.gridSpacing;t-n/2-100*this.scale,t+n/2+100*this.scale,this.inputDots=[];for(let s=0;s<14;s++){const r={x:t,y:h,spawnScale:0};this.inputDots.push(r),this.pendingTweens++,N.to(r,{spawnScale:1},.3,F.easeOutBack,{delay:.05+s*.01,onComplete:()=>this.onTweenComplete()})}this.outputDots=[];for(let s=0;s<7;s++){const r={x:t,y:h,spawnScale:0};this.outputDots.push(r),this.pendingTweens++,N.to(r,{spawnScale:1},.3,F.easeOutBack,{delay:.1+s*.01,onComplete:()=>this.onTweenComplete()})}}onTweenComplete(){this.pendingTweens--,this.pendingTweens<=0&&this.fsm.is("intro")&&this.fsm.setState("training")}updateIntro(t){}startTraining(){this.trainingOpacity=0,this.synapseOpacity=0,N.to(this,{trainingOpacity:1},.8,F.easeOutQuad),N.to(this,{synapseOpacity:1},1.5,F.easeInOutQuad,{delay:.5})}updateTraining(t){N.updateAll(t),this.trainNetwork(),this.synapseAnimationTime+=t}restart(){this.network=new I(p.network);const{nTokens:t,symmetric:h,trainFraction:e}=p.network,i=G(t,h),n=_(i,e);this.trainData=n.train,this.testData=n.test,this.epoch=0,this.trainAccuracy=0,this.testAccuracy=0,this.grokkingDetected=!1,this.grokkingEpoch=-1,this.accuracyHistory=[],this.grokMode=0,this.grokModeOverride=!1,this.outputNeuronsInitialized=!1,this.outputNeuronsKeys=null,this.gridNeurons=null,this.animTime=0,this.cachedOutput=null,this.cachedPrediction=null,this.trainingOpacity=0,this.synapseOpacity=0,this.useWorker&&this.worker&&(this.workerReady=!1,this.workerTraining=!1,this.worker.postMessage({type:"reset",data:{config:p.network}})),N.killAll(),this.fsm.setState("intro")}update(t){super.update(t);const h=Math.min(this.width,this.height);if(this.scale=h/p.grid.referenceSize,this.gridSpacing=p.grid.baseSpacing*this.scale,this.gridOffsetX=this.width/2-p.grid.cols*this.gridSpacing/2,this.gridOffsetY=this.height/2-p.grid.rows*this.gridSpacing/2,this.fsm.update(t),this.animTime+=t,this.testCaseTime+=t,this.testCaseTime>2){this.testCaseTime=0;const e=Math.floor(Math.random()*this.testData.length);this.currentTestCase=this.testData[e],this.currentTestCaseId=e,this.outputNeuronsInitialized=!1,this.cachedOutput=null,this.cachedPrediction=null,this.activatedGridNeurons.clear(),this.activatedOutputNeurons.clear(),this.gridFlashes.clear(),this.outputFlashes.clear(),this.lastGridFlashIdx=-1,this.lastOutputFlashIdx=-1,this.lastOutputSourceFlashKey=null}if(this.currentTestCase){const{probs:e}=this.network.forward(this.currentTestCase.a,this.currentTestCase.b);this.cachedOutput=e,(!this.useWorker||!this.workerReady)&&(this.cachedPrediction=this.network.predict(this.currentTestCase.a,this.currentTestCase.b))}else this.trainData.length>0&&(this.currentTestCase=this.trainData[0]);this.currentTestCase&&this.useWorker&&this.workerReady&&(!this._lastForwardRequest||Date.now()-this._lastForwardRequest>100)&&(this._lastForwardRequest=Date.now(),this.worker.postMessage({type:"forward",data:{a:this.currentTestCase.a,b:this.currentTestCase.b}}))}trainNetwork(){const{epochsPerFrame:t,batchSize:h}=p.training,{nTokens:e}=p.network;if(this.useWorker&&this.workerReady&&!this.workerTraining){if(this.workerTraining=!0,this.worker.postMessage({type:"train",data:{epochsPerFrame:t,batchSize:h}}),this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokModeOverride){const i=this.trainAccuracy>=.95,s=i&&this.testAccuracy>=this.grokThreshold?1:0,r=this.grokMode>.5;this.grokMode+=(s-this.grokMode)*.05,!r&&this.grokMode>.5&&(this.currentTestCase=null,this.cachedOutput=null,this.cachedPrediction=null,this.useWorker&&this.workerReady&&!this._weightsSynced&&this.worker.postMessage({type:"syncWeights"})),i&&this.useWorker&&this.workerReady&&(!this._lastWeightSync||Date.now()-this._lastWeightSync>5e3)&&(this._lastWeightSync=Date.now(),this.worker.postMessage({type:"syncWeights"}))}return}if(!this.useWorker){this.network.resetGradients();for(let i=0;i<t;i++){for(let n=0;n<this.trainData.length;n++){const s=this.trainData[n],{cache:r}=this.network.forward(s.a,s.b);this.network.backward(s.target,r)}this.network.applyAdamW(this.trainData.length),this.epoch++}if(this.epoch%20===0){const i=this.trainData.slice(0,Math.min(100,this.trainData.length)),n=this.testData.slice(0,Math.min(100,this.testData.length));this.trainAccuracy=B(this.network,i),this.testAccuracy=B(this.network,n)}if(this.accuracyHistory.push({epoch:this.epoch,train:this.trainAccuracy,test:this.testAccuracy}),this.accuracyHistory.length>500&&this.accuracyHistory.shift(),!this.grokkingDetected&&this.epoch>100){const i=this.accuracyHistory.slice(-50);if(i.length>=50){const n=i[0].test,s=i[i.length-1].test;this.trainAccuracy>.8&&s-n>.3&&(this.grokkingDetected=!0,this.grokkingEpoch=this.epoch)}}}}render(){const t=this.ctx,h=this.width,e=this.height;t.fillStyle="rgba(0, 0, 0, 0.2)",t.fillRect(0,0,h,e),this.updateOutputNeuronState(),this.drawSynapses(t),this.drawNeuronGrid(t),this.drawInputOutputNeurons(t),this.drawInputOutput(t),this.drawStats(t)}drawNeuronGrid(t){const{rows:h,cols:e}=p.grid,i=this.gridSpacing,n=this.network.hiddenActivations;if(!n||n.length===0)return;let s=0;for(let a=0;a<n.length;a++)n[a]>s&&(s=n[a]);s=Math.max(s,.001),this._normCache=this._normCache?this._normCache*.9+s*.1:s;const r=this._lastSpacing&&Math.abs(this._lastSpacing-i)>1;this._lastSpacing=i;const c=this.fsm.is("intro");if(!this.gridNeurons||this.gridNeurons.length!==h*e||r&&!c){this.gridNeurons=[];for(let a=0;a<h;a++)for(let u=0;u<e;u++){const g=this.gridOffsetX+u*i,w=this.gridOffsetY+a*i;this.gridNeurons.push(new P(g,w,4*this.scale))}}for(let a=0;a<h;a++)for(let u=0;u<e;u++){const g=a*e+u,w=this.gridNeurons[g];w.x=this.gridOffsetX+u*i,w.y=this.gridOffsetY+a*i;let o=0;if(this.gridFlashes&&this.gridFlashes.has(g)){const y=this.gridFlashes.get(g),l=this.synapseAnimationTime-y;if(l<p.timing.flashDuration){const O=l/p.timing.flashDuration;o=1-O*O,this.activatedGridNeurons.add(g)}else this.gridFlashes.delete(g),this.activatedGridNeurons.delete(g)}c?(w.activation=0,w.isActive=!1):(w.activation=o,w.isActive=o>.1),w.renderGrid(t,p.colors,this._normCache,o,this.scale,this.grokMode,a,u,this.animTime)}}updateOutputNeuronState(){if(!this.currentTestCase||!this.cachedOutput||!this.fsm.is("training"))return;const t=this.width/2,h=this.height/2,e=p.grid.cols*this.gridSpacing,i=t+e/2+8*this.scale,n=this.cachedOutput,s=this.cachedPrediction,r=16,c=p.network.nTokens;this._rowActivations||(this._rowActivations=new Float32Array(r)),this._rowTokens||(this._rowTokens=new Int16Array(r)),this._rowActivations.fill(0),this._rowTokens.fill(-1);for(let o=0;o<c;o++){const y=Math.floor(o*r/c);n[o]>this._rowActivations[y]&&(this._rowActivations[y]=n[o],this._rowTokens[y]=o)}const a=this.gridSpacing,u=h-(r-1)*a/2;if(!this.outputNeurons||this.outputNeurons.length!==r){this.outputNeurons=[];for(let o=0;o<r;o++){const y=u+o*a;this.outputNeurons.push(new P(i,y,4*this.scale))}}const g=s!=null?Math.floor(s*r/c):-1,w=this.currentTestCase.target!==void 0?Math.floor(this.currentTestCase.target*r/c):-1;for(let o=0;o<r;o++){const y=this.outputNeurons[o];y.x=i,y.y=u+o*a,y.isTarget=o===w,y.isSelected=o===g}}drawInputOutputNeurons(t){if(!this.currentTestCase||!this.cachedOutput||!this.fsm.is("training")||this.trainingOpacity<=0||!this.outputNeurons||this.outputNeurons.length===0)return;t.save(),t.globalAlpha=this.trainingOpacity;const h=16;for(let e=0;e<h;e++){const i=this.outputNeurons[e];let n=0;if(this.outputFlashes.has(e)){const r=this.outputFlashes.get(e),c=this.synapseAnimationTime-r;if(c<p.timing.flashDuration){const a=c/p.timing.flashDuration;n=1-a*a,this.activatedOutputNeurons.add(e)}else this.outputFlashes.delete(e),this.activatedOutputNeurons.delete(e)}i.activation=n;const s=i.isTarget&&!i.isSelected||!i.isTarget&&i.isSelected;i.isError=n>.1&&s,i.renderOutput(t,p.colors,n,this.scale,this.grokMode)}t.restore()}drawSynapses(t){if(!this.currentTestCase||!this.fsm.is("training")||this.synapseOpacity<=0||!this.cachedOutput||!this.gridNeurons)return;t.save(),t.globalAlpha=this.synapseOpacity;const h=this.width/2,e=this.height/2,i=p.grid.cols*this.gridSpacing,{cols:n}=p.grid,s=this.gridSpacing,r=this.synapseAnimationTime;for(const[d,m]of this.gridFlashes.entries())r-m>p.timing.activationDuration&&(this.gridFlashes.delete(d),this.activatedGridNeurons.delete(d));for(const[d,m]of this.outputFlashes.entries())r-m>p.timing.activationDuration&&(this.outputFlashes.delete(d),this.activatedOutputNeurons.delete(d));const c=this.network.hiddenActivations;c&&Math.max(...c,.001);const a=d=>{const k=(Math.floor(r*8)*17+d*31)%256,f=Math.floor(k/n),T=k%n;return{index:k,x:this.gridOffsetX+T*s,y:this.gridOffsetY+f*s}},u=h-i/2-100*this.scale,g=u,w=e-40*this.scale,o=u,y=e+40*this.scale;t.lineCap="round";const l=12,O=8;for(let d=0;d<l;d++){const m=(r*6+d*.083)%1,k=a(d),f=d%2===0,T=f?g:o,b=f?w:y,S=Math.min(1,m*3),v=1-Math.pow(1-S,3),M=T+(k.x-T)*v,D=b+(k.y-b)*v;let A=(1-m)*.6;t.strokeStyle="#0ff",t.lineWidth=Math.max(.5,1*this.scale),t.globalAlpha=this.synapseOpacity*A,t.beginPath(),t.moveTo(T,b),t.lineTo(M,D),t.stroke(),S<1&&A>.1&&(t.fillStyle=`rgba(0, 255, 255, ${A*.5})`,t.beginPath(),t.arc(M,D,2*this.scale,0,Math.PI*2),t.fill()),S>.9&&(this.gridFlashes.set(k.index,r),this.activatedGridNeurons.add(k.index))}const $=[];if(this.outputNeurons&&this.outputNeurons.length>0)for(let d=0;d<this.outputNeurons.length;d++){const m=this.outputNeurons[d];(m.isSelected||m.isTarget)&&$.push({position:d,x:m.x,y:m.y,isPrimary:m.isSelected})}if($.length>0){if(!this._sourcesBuffer){this._sourcesBuffer=[];for(let f=0;f<8;f++)this._sourcesBuffer.push({index:0,x:0,y:0})}let d=0;for(const f of this.activatedGridNeurons){if(d>=8)break;const T=Math.floor(f/n),b=f%n;this._sourcesBuffer[d].index=f,this._sourcesBuffer[d].x=this.gridOffsetX+b*s,this._sourcesBuffer[d].y=this.gridOffsetY+T*s,d++}if(d===0)for(let f=0;f<4;f++){const T=a(f);this._sourcesBuffer[d].index=T.index,this._sourcesBuffer[d].x=T.x,this._sourcesBuffer[d].y=T.y,d++}const m=this._sourcesBuffer,k=d;for(let f=0;f<O;f++){const T=(r*5+f*.125+.15)%1,b=m[f%k],S=$[f%$.length],v=Math.min(1,T*3),M=1-Math.pow(1-v,3),D=b.x+(S.x-b.x)*M,A=b.y+(S.y-b.y)*M;let C=(1-T)*.5;t.strokeStyle="#0ff",t.lineWidth=Math.max(.5,1*this.scale),t.globalAlpha=this.synapseOpacity*C,t.beginPath(),t.moveTo(b.x,b.y),t.lineTo(D,A),t.stroke(),v<1&&C>.1&&(t.fillStyle=`rgba(0, 255, 255, ${C*.5})`,t.beginPath(),t.arc(D,A,2*this.scale,0,Math.PI*2),t.fill()),v>.1&&v<.3&&this.gridFlashes.set(b.index,r),v>.9&&(this.outputFlashes.set(S.position,r),this.activatedOutputNeurons.add(S.position))}}t.restore()}drawInputOutput(t){var S,v;if(!this.currentTestCase||!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const{text:h,neuronActive:e,neuronBright:i}=p.colors,n=this.currentTestCase.a??((S=this.currentTestCase.original)==null?void 0:S[0])??0,s=this.currentTestCase.b??((v=this.currentTestCase.original)==null?void 0:v[1])??0,r=this.currentTestCase.target,c=this.cachedPrediction??this.network.predict(n,s),a=c===r,u=this.width/2,g=this.height/2,w=p.grid.cols*this.gridSpacing;p.grid.rows*this.gridSpacing;const o=u-w/2-100*this.scale,y=u+w/2+100*this.scale,l=4*this.scale,O=18*this.scale,$=10,d=g-40*this.scale;this.drawNumberAsDots(t,n,o,d,l,O,$,e),t.fillStyle=h,t.font=`bold ${Math.round(32*this.scale)}px monospace`,t.textAlign="center",t.textBaseline="middle",t.fillText("+",o,g);const m=g+40*this.scale;this.drawNumberAsDots(t,s,o,m,l,O,$,e),this.drawNumberAsDots(t,r,y,g,l,O,$,i);const k=40*this.scale,T=40*this.scale+22*this.scale*6+40*this.scale+30*this.scale;t.textAlign="left",t.font=`bold ${Math.round(14*this.scale)}px monospace`,t.fillStyle=h;const b=n+s;t.fillText(`${n} + ${s} = ${b}`,k,T),t.font=`${Math.round(12*this.scale)}px monospace`,t.fillText(`mod ${p.network.nTokens} = ${r}`,k,T+18*this.scale),t.font=`bold ${Math.round(12*this.scale)}px monospace`,t.fillStyle=a?"#0ff":"#f00",t.fillText(`Predicted: ${c} ${a?"✓":"✗"}`,k,T+36*this.scale),t.restore()}drawNumberAsDots(t,h,e,i,n,s,r,c){const a=p.network.nTokens,u=Math.max(1,Math.ceil(Math.log2(a))),g=[];let w=h;for(let l=u-1;l>=0;l--){const O=w>>l&1;g.push(O)}const o=Math.ceil(u/r),y=i-(o-1)*s/2;t.globalAlpha=1;for(let l=0;l<u;l++){const O=g[l],$=Math.floor(l/r),d=l%r,k=(Math.min(r,u-$*r)-1)*s,f=e-k/2+d*s,T=y+$*s,b=new P(f,T,n);b.isActive=O===1,b.activation=O===1?1:0,b.render(t,p.colors)}}drawStats(t){if(!this.fsm.is("training")||this.trainingOpacity<=0)return;t.save(),t.globalAlpha=this.trainingOpacity;const h=40*this.scale,e=40*this.scale,i=22*this.scale;if(t.fillStyle="#888",t.font=`${Math.round(14*this.scale)}px monospace`,t.textAlign="left",t.textBaseline="top",t.fillText(`Epoch: ${this.epoch}`,h,e),t.fillText(`Train: ${(this.trainAccuracy*100).toFixed(1)}%`,h,e+i),t.fillText(`Test: ${(this.testAccuracy*100).toFixed(1)}%`,h,e+i*2),this.grokMode>.5?(t.fillStyle="#f0f",t.fillText("✨ GROKKED!",h,e+i*3)):this.grokkingDetected&&(t.fillStyle="#0ff",t.fillText("✓ GROKKING!",h,e+i*3)),this.accuracyHistory.length>2){const n=150*this.scale,s=40*this.scale,r=h,c=e+i*6,a=Math.max(1,Math.floor(this.accuracyHistory.length/100));t.strokeStyle="#0f0",t.lineWidth=1,t.beginPath();let u=!0;for(let g=0;g<this.accuracyHistory.length;g+=a){const w=this.accuracyHistory[g],o=r+g/this.accuracyHistory.length*n,y=c-w.train*s;u?(t.moveTo(o,y),u=!1):t.lineTo(o,y)}t.stroke(),t.strokeStyle="#0ff",t.beginPath(),u=!0;for(let g=0;g<this.accuracyHistory.length;g+=a){const w=this.accuracyHistory[g],o=r+g/this.accuracyHistory.length*n,y=c-w.test*s;u?(t.moveTo(o,y),u=!1):t.lineTo(o,y)}t.stroke()}t.restore()}}function j(W){const t=new E(W);return t.start(),{stop:()=>t.stop(),game:t}}export{j as default};
