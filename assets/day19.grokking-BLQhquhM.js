import{shuffle as W}from"./day19.utils-DeEDoNyc.js";class p{constructor(t){this.nTokens=t.nTokens||16,this.embedSize=t.embedSize||128,this.hiddenSize=t.hiddenSize||24,this.learningRate=t.learningRate||.001,this.weightDecay=t.weightDecay||1,this.beta1=t.beta1||.9,this.beta2=t.beta2||.98,this.epsilon=1e-8;const n=Math.sqrt(2/this.nTokens),e=Math.sqrt(2/this.embedSize),a=Math.sqrt(2/this.hiddenSize);this.embed=this.initMatrix(this.nTokens,this.embedSize,n),this.Whidden=this.initMatrix(this.embedSize,this.hiddenSize,e),this.Wout=this.initMatrix(this.hiddenSize,this.embedSize,a),this._actualHiddenActivations=new Float32Array(this.hiddenSize),this.hiddenActivations=new Float32Array(256),this.outputActivations=new Float32Array(this.nTokens),this.weights1=null,this.weights2=null,this.initAdamState(),this.adamT=0}initMatrix(t,n,e){const a=[];for(let o=0;o<t;o++){a[o]=new Float32Array(n);for(let d=0;d<n;d++)a[o][d]=(Math.random()*2-1)*e}return a}initAdamState(){this.m_embed=this.embed.map(t=>new Float32Array(t.length)),this.v_embed=this.embed.map(t=>new Float32Array(t.length)),this.m_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.v_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.m_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.v_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.grad_embed=this.embed.map(t=>new Float32Array(t.length)),this.grad_Whidden=this.Whidden.map(t=>new Float32Array(t.length)),this.grad_Wout=this.Wout.map(t=>new Float32Array(t.length)),this.gradCount=0}resetGradients(){for(let t=0;t<this.nTokens;t++)this.grad_embed[t].fill(0);for(let t=0;t<this.embedSize;t++)this.grad_Whidden[t].fill(0);for(let t=0;t<this.hiddenSize;t++)this.grad_Wout[t].fill(0);this.gradCount=0}forward(t,n){const e=this.embed[t],a=this.embed[n],o=new Float32Array(this.hiddenSize),d=new Float32Array(this.hiddenSize);for(let r=0;r<this.hiddenSize;r++){let u=0,_=0;for(let m=0;m<this.embedSize;m++)u+=e[m]*this.Whidden[m][r],_+=a[m]*this.Whidden[m][r];o[r]=u,d[r]=_}const i=new Float32Array(this.hiddenSize),h=new Float32Array(this.hiddenSize);for(let r=0;r<this.hiddenSize;r++)h[r]=o[r]+d[r],i[r]=Math.max(0,h[r]);this._actualHiddenActivations=i,this._updateGridActivations();const c=new Float32Array(this.embedSize);for(let r=0;r<this.hiddenSize;r++){const u=i[r],_=this.Wout[r];for(let m=0;m<this.embedSize;m++)c[m]+=u*_[m]}const S=new Float32Array(this.nTokens);for(let r=0;r<this.nTokens;r++){let u=0;for(let _=0;_<this.embedSize;_++)u+=c[_]*this.embed[r][_];S[r]=u}const b=this.softmax(S);return this.outputActivations=b,{probs:b,hidden:i,cache:{a:t,b:n,embedded_a:e,embedded_b:a,hidden_a:o,hidden_b:d,hidden_preact:h,hidden:i,out:c,logits:S,probs:b}}}softmax(t){let n=t[0];for(let d=1;d<t.length;d++)t[d]>n&&(n=t[d]);const e=new Float32Array(t.length);let a=0;for(let d=0;d<t.length;d++)e[d]=Math.exp(t[d]-n),a+=e[d];const o=new Float32Array(t.length);for(let d=0;d<t.length;d++)o[d]=e[d]/a;return o}backward(t,n){const{a:e,b:a,embedded_a:o,embedded_b:d,hidden_preact:i,hidden:h,out:c,probs:S}=n,b=new Float32Array(this.nTokens);for(let s=0;s<this.nTokens;s++)b[s]=S[s]-(s===t?1:0);for(let s=0;s<this.nTokens;s++){const f=b[s],l=this.grad_embed[s];for(let z=0;z<this.embedSize;z++)l[z]+=f*c[z]}const A=new Float32Array(this.embedSize);for(let s=0;s<this.nTokens;s++){const f=b[s],l=this.embed[s];for(let z=0;z<this.embedSize;z++)A[z]+=f*l[z]}const r=new Float32Array(this.hiddenSize);for(let s=0;s<this.hiddenSize;s++){let f=0;for(let l=0;l<this.embedSize;l++)this.grad_Wout[s][l]+=h[s]*A[l],f+=A[l]*this.Wout[s][l];r[s]=f}const u=new Float32Array(this.hiddenSize);for(let s=0;s<this.hiddenSize;s++)u[s]=i[s]>0?r[s]:0;const _=new Float32Array(this.embedSize),m=new Float32Array(this.embedSize);for(let s=0;s<this.embedSize;s++){let f=0;for(let l=0;l<this.hiddenSize;l++)this.grad_Whidden[s][l]+=o[s]*u[l],this.grad_Whidden[s][l]+=d[s]*u[l],f+=u[l]*this.Whidden[s][l];_[s]=f,m[s]=f}for(let s=0;s<this.embedSize;s++)this.grad_embed[e][s]+=_[s],this.grad_embed[a][s]+=m[s];this.gradCount++}applyAdamW(t){if(this.gradCount===0)return;this.adamT++;const n=this.learningRate,e=this.weightDecay,a=1/t,o=1-Math.pow(this.beta1,this.adamT),d=1-Math.pow(this.beta2,this.adamT);for(let i=0;i<this.nTokens;i++)for(let h=0;h<this.embedSize;h++){const c=this.grad_embed[i][h]*a;this.m_embed[i][h]=this.beta1*this.m_embed[i][h]+(1-this.beta1)*c,this.v_embed[i][h]=this.beta2*this.v_embed[i][h]+(1-this.beta2)*c*c;const S=this.m_embed[i][h]/o,b=this.v_embed[i][h]/d;this.embed[i][h]-=n*(S/(Math.sqrt(b)+this.epsilon)+e*this.embed[i][h]),this.grad_embed[i][h]=0}for(let i=0;i<this.embedSize;i++)for(let h=0;h<this.hiddenSize;h++){const c=this.grad_Whidden[i][h]*a;this.m_Whidden[i][h]=this.beta1*this.m_Whidden[i][h]+(1-this.beta1)*c,this.v_Whidden[i][h]=this.beta2*this.v_Whidden[i][h]+(1-this.beta2)*c*c;const S=this.m_Whidden[i][h]/o,b=this.v_Whidden[i][h]/d;this.Whidden[i][h]-=n*(S/(Math.sqrt(b)+this.epsilon)+e*this.Whidden[i][h]),this.grad_Whidden[i][h]=0}for(let i=0;i<this.hiddenSize;i++)for(let h=0;h<this.embedSize;h++){const c=this.grad_Wout[i][h]*a;this.m_Wout[i][h]=this.beta1*this.m_Wout[i][h]+(1-this.beta1)*c,this.v_Wout[i][h]=this.beta2*this.v_Wout[i][h]+(1-this.beta2)*c*c;const S=this.m_Wout[i][h]/o,b=this.v_Wout[i][h]/d;this.Wout[i][h]-=n*(S/(Math.sqrt(b)+this.epsilon)+e*this.Wout[i][h]),this.grad_Wout[i][h]=0}this.gradCount=0}predict(t,n){const{probs:e}=this.forward(t,n);let a=0,o=e[0];for(let d=1;d<e.length;d++)e[d]>o&&(o=e[d],a=d);return a}_updateGridActivations(){const n=this._actualHiddenActivations;if(this.hiddenSize===256)for(let e=0;e<256;e++)this.hiddenActivations[e]=n[e];else if(this.hiddenSize<256)for(let e=0;e<256;e++)this.hiddenActivations[e]=n[e%this.hiddenSize];else{const e=this.hiddenSize/256;for(let a=0;a<256;a++)this.hiddenActivations[a]=n[Math.floor(a*e)]}}getGridActivations(){return new Float32Array(this.hiddenActivations)}}function y(g,t=!0){const n=[];for(let e=0;e<g;e++)for(let a=0;a<g;a++){if(t&&e>a)continue;const o=(e+a)%g;n.push({a:e,b:a,target:o,original:[e,a]})}return n}function F(g,t=.4){const n=W([...g]),e=Math.floor(n.length*t);return{train:n.slice(0,e),test:n.slice(e)}}function v(g,t){let n=0;for(const e of t)g.predict(e.a,e.b)===e.target&&n++;return n/t.length}export{p as FactoredNetwork,v as calcAccuracy,y as generateAllPairs,F as splitData};
