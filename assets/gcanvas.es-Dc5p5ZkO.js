var ts=Object.defineProperty,Le=f=>{throw TypeError(f)},es=(f,t,e)=>t in f?ts(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,I=(f,t,e)=>es(f,typeof t!="symbol"?t+"":t,e),we=(f,t,e)=>t.has(f)||Le("Cannot "+e),x=(f,t,e)=>(we(f,t,"read from private field"),e?e.call(f):t.get(f)),O=(f,t,e)=>t.has(f)?Le("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(f):t.set(f,e),N=(f,t,e,s)=>(we(f,t,"write to private field"),t.set(f,e),e),J=(f,t,e)=>(we(f,t,"access private method"),e),lt,Me,he,Y,V,Se,Lt,Ce,yt,it,qt,wt,Jt,Qt,te,ee,se,ie,ne,zt,Xt,le,ce,L,Et,U,Re,oe,$,Wt,Nt,j,ct,Zt;class Te{constructor(t={}){this.children=[],this.sortByZIndex=t.sortByZIndex||!0,this._zOrderDirty=!1}add(t){return this.children.includes(t)?(console.warn("Object is already in this collection"),t):(this.children.push(t),t.parent=this._owner||this,this.sortByZIndex&&(this._zOrderDirty=!0,(t.zIndex===void 0||t.zIndex===null)&&(t.zIndex=this.children.length-1)),t)}remove(t){const e=this.children.indexOf(t);return e!==-1?(this.children.splice(e,1),t.parent=null,!0):!1}clear(){this.children.forEach(t=>{t.parent=null}),this.children=[]}bringToFront(t){const e=this.children.indexOf(t);if(e===-1){this.add(t);return}if(this.sortByZIndex){let s=!0;for(const i of this.children)if(i!==t&&(i.zIndex||0)>=(t.zIndex||0)){s=!1;break}s||(t.zIndex=Number.MAX_SAFE_INTEGER,this._zOrderDirty=!0,this._normalizeZIndices())}else e!==this.children.length-1&&(this.children.splice(e,1),this.children.push(t))}sendToBack(t){const e=this.children.indexOf(t);if(e===-1){this.children.unshift(t),t.parent=this._owner||this;return}if(this.sortByZIndex){let s=!0;for(const i of this.children)if(i!==t&&(i.zIndex||0)<=(t.zIndex||0)){s=!1;break}s||(t.zIndex=Number.MIN_SAFE_INTEGER,this._zOrderDirty=!0,this._normalizeZIndices())}else e!==0&&(this.children.splice(e,1),this.children.unshift(t))}bringForward(t){const e=this.children.indexOf(t);if(!(e===-1||e===this.children.length-1))if(this.sortByZIndex){const s=[...this.children].sort((n,r)=>(n.zIndex||0)-(r.zIndex||0)),i=s.indexOf(t);if(i<s.length-1){const n=s[i+1],r=n.zIndex||0,o=t.zIndex||0;r-o>1?t.zIndex=o+Math.floor((r-o)/2):(t.zIndex=r,n.zIndex=o),this._zOrderDirty=!0,this._normalizeZIndices()}}else{const s=this.children[e+1];this.children[e+1]=t,this.children[e]=s}}sendBackward(t){const e=this.children.indexOf(t);if(!(e<=0))if(this.sortByZIndex){const s=[...this.children].sort((n,r)=>(n.zIndex||0)-(r.zIndex||0)),i=s.indexOf(t);if(i>0){const n=s[i-1],r=n.zIndex||0,o=t.zIndex||0;o-r>1?t.zIndex=r+Math.floor((o-r)/2):(t.zIndex=r,n.zIndex=o),this._zOrderDirty=!0,this._normalizeZIndices()}}else{const s=this.children[e-1];this.children[e-1]=t,this.children[e]=s}}_normalizeZIndices(){if(this.children.length<=1)return;this.children.some(e=>(e.zIndex||0)>1e3||(e.zIndex||0)<-1e3)&&([...this.children].sort((s,i)=>(s.zIndex||0)-(i.zIndex||0)).forEach((s,i)=>{s.zIndex=i*10}),this._zOrderDirty=!0)}getSortedChildren(){return this.sortByZIndex&&this._zOrderDirty&&(this.children.sort((t,e)=>(t.zIndex||0)-(e.zIndex||0)),this._zOrderDirty=!1),this.children}}const Pt=class Mt{static calculate(t,e,s,i=10,n=0,r=0){const o=e.width||0,a=e.height||0,l=s.width||0,c=s.height||0,u=s.x||0,h=s.y||0;let d,g,m,p;switch(t){case Mt.TOP_LEFT:d=u-l/2+i+o/2,g=h-c/2+i+a/2,m="left",p="top";break;case Mt.TOP_CENTER:d=u,g=h-c/2+i+a/2,m="center",p="top";break;case Mt.TOP_RIGHT:d=u+l/2-i-o/2,g=h-c/2+i+a/2,m="right",p="top";break;case Mt.CENTER_LEFT:d=u-l/2+i+o/2,g=h,m="left",p="middle";break;case Mt.CENTER:d=u,g=h,m="center",p="middle";break;case Mt.CENTER_RIGHT:d=u+l/2-i-o/2,g=h,m="right",p="middle";break;case Mt.BOTTOM_LEFT:d=u-l/2+i+o/2,g=h+c/2-i-a/2,m="left",p="bottom";break;case Mt.BOTTOM_CENTER:d=u,g=h+c/2-i-a/2,m="center",p="bottom";break;case Mt.BOTTOM_RIGHT:d=u+l/2-i-o/2,g=h+c/2-i-a/2,m="right",p="bottom";break;default:d=u-l/2+i+o/2,g=h-c/2+i+a/2,m="left",p="top"}return d+=n,g+=r,{x:d,y:g,align:m,baseline:p}}static calculateAbsolute(t,e,s,i=10,n=0,r=0){const o={width:s.width,height:s.height,x:s.width/2,y:s.height/2};return Mt.calculate(t,e,o,i,n,r)}};I(Pt,"TOP_LEFT","top-left");I(Pt,"TOP_CENTER","top-center");I(Pt,"TOP_RIGHT","top-right");I(Pt,"CENTER_LEFT","center-left");I(Pt,"CENTER","center");I(Pt,"CENTER_RIGHT","center-right");I(Pt,"BOTTOM_LEFT","bottom-left");I(Pt,"BOTTOM_CENTER","bottom-center");I(Pt,"BOTTOM_RIGHT","bottom-right");let ze=Pt;class ai{constructor(t={}){this.rotationX=t.rotationX??0,this.rotationY=t.rotationY??0,this.rotationZ=t.rotationZ??0,this.x=t.x??0,this.y=t.y??0,this.z=t.z??0,this._initialRotationX=this.rotationX,this._initialRotationY=this.rotationY,this._initialRotationZ=this.rotationZ,this._initialX=this.x,this._initialY=this.y,this._initialZ=this.z,this.perspective=t.perspective??800,this.sensitivity=t.sensitivity??.005,this.minRotationX=t.minRotationX??-1.5,this.maxRotationX=t.maxRotationX??1.5,this.clampX=t.clampX??!0,this.autoRotate=t.autoRotate??!1,this.autoRotateSpeed=t.autoRotateSpeed??.5,this.autoRotateAxis=t.autoRotateAxis??"y",this.inertia=t.inertia??!1,this.friction=t.friction??.92,this.velocityScale=t.velocityScale??1,this._velocityX=0,this._velocityY=0,this._lastDeltaX=0,this._lastDeltaY=0,this._lastMoveTime=0,this._isDragging=!1,this._lastMouseX=0,this._lastMouseY=0,this._canvas=null,this._boundHandlers=null,this._followTarget=null,this._followOffset={x:0,y:0,z:0},this._followLookAt=!0,this._followLerp=.1,this._targetX=null,this._targetY=null,this._targetZ=null,this._targetRotationX=null,this._targetRotationY=null,this._positionLerp=.05}project(t,e,s){if(t-=this.x,e-=this.y,s-=this.z,this.rotationZ!==0){const m=Math.cos(this.rotationZ),p=Math.sin(this.rotationZ),v=t,_=e;t=v*m-_*p,e=v*p+_*m}const i=Math.cos(this.rotationY),n=Math.sin(this.rotationY),r=t*i-s*n,o=t*n+s*i,a=Math.cos(this.rotationX),l=Math.sin(this.rotationX),c=e*a-o*l,u=e*l+o*a,h=this.perspective/(this.perspective+u),d=r*h,g=c*h;return{x:d,y:g,z:u,scale:h}}projectAll(t){return t.map(e=>this.project(e.x,e.y,e.z))}update(t){var e,s,i;if(this._followTarget){const n=this._followTarget,r=(n.x??0)+this._followOffset.x,o=(n.y??0)+this._followOffset.y,a=(n.z??0)+this._followOffset.z;if(this.x+=(r-this.x)*this._followLerp,this.y+=(o-this.y)*this._followLerp,this.z+=(a-this.z)*this._followLerp,this._followLookAt){const l=((e=this._followLookAtTarget)==null?void 0:e.x)??0,c=((s=this._followLookAtTarget)==null?void 0:s.y)??0,u=((i=this._followLookAtTarget)==null?void 0:i.z)??0,h=l-this.x,d=c-this.y,g=u-this.z,m=Math.sqrt(h*h+g*g),p=Math.atan2(h,g),v=Math.atan2(-d,m);this.rotationY+=this._angleDiff(this.rotationY,p)*this._followLerp,this.rotationX+=(v-this.rotationX)*this._followLerp}}else if(this._targetX!==null){const n=this._positionLerp;this.x+=(this._targetX-this.x)*n,this.y+=(this._targetY-this.y)*n,this.z+=(this._targetZ-this.z)*n,this._targetRotationX!==null&&(this.rotationX+=(this._targetRotationX-this.rotationX)*n),this._targetRotationY!==null&&(this.rotationY+=this._angleDiff(this.rotationY,this._targetRotationY)*n),Math.abs(this._targetX-this.x)+Math.abs(this._targetY-this.y)+Math.abs(this._targetZ-this.z)<.1&&(this.x=this._targetX,this.y=this._targetY,this.z=this._targetZ,this._targetX=null,this._targetY=null,this._targetZ=null,this._targetRotationX=null,this._targetRotationY=null)}if(this.inertia&&!this._isDragging&&!this._followTarget&&(Math.abs(this._velocityX)>1e-4||Math.abs(this._velocityY)>1e-4)&&(this.rotationY+=this._velocityY,this.rotationX+=this._velocityX,this.clampX&&(this.rotationX=Math.max(this.minRotationX,Math.min(this.maxRotationX,this.rotationX))),this._velocityX*=this.friction,this._velocityY*=this.friction,Math.abs(this._velocityX)<1e-4&&(this._velocityX=0),Math.abs(this._velocityY)<1e-4&&(this._velocityY=0)),this.autoRotate&&!this._isDragging&&!this._followTarget&&!(Math.abs(this._velocityX)>.001||Math.abs(this._velocityY)>.001)){const r=this.autoRotateSpeed*t;switch(this.autoRotateAxis){case"x":this.rotationX+=r;break;case"y":this.rotationY+=r;break;case"z":this.rotationZ+=r;break}}}_angleDiff(t,e){let s=e-t;for(;s>Math.PI;)s-=Math.PI*2;for(;s<-Math.PI;)s+=Math.PI*2;return s}enableMouseControl(t,e={}){this._canvas&&this.disableMouseControl(),this._canvas=t;const s=e.invertX?-1:1,i=e.invertY?-1:1;return this._boundHandlers={mousedown:n=>{this._isDragging=!0,this._lastMouseX=n.clientX,this._lastMouseY=n.clientY,this._lastMoveTime=performance.now(),this._velocityX=0,this._velocityY=0},mousemove:n=>{if(!this._isDragging)return;const r=n.clientX-this._lastMouseX,o=n.clientY-this._lastMouseY,a=r*this.sensitivity*s,l=o*this.sensitivity*i;this.rotationY+=a,this.rotationX+=l,this.clampX&&(this.rotationX=Math.max(this.minRotationX,Math.min(this.maxRotationX,this.rotationX))),this.inertia&&(this._lastDeltaX=l,this._lastDeltaY=a,this._lastMoveTime=performance.now()),this._lastMouseX=n.clientX,this._lastMouseY=n.clientY},mouseup:()=>{this.inertia&&this._isDragging&&performance.now()-this._lastMoveTime<50&&(this._velocityX=this._lastDeltaX*this.velocityScale,this._velocityY=this._lastDeltaY*this.velocityScale),this._isDragging=!1},mouseleave:()=>{this.inertia&&this._isDragging&&performance.now()-this._lastMoveTime<50&&(this._velocityX=this._lastDeltaX*this.velocityScale,this._velocityY=this._lastDeltaY*this.velocityScale),this._isDragging=!1},touchstart:n=>{n.touches.length===1&&(this._isDragging=!0,this._lastMouseX=n.touches[0].clientX,this._lastMouseY=n.touches[0].clientY,this._lastMoveTime=performance.now(),this._velocityX=0,this._velocityY=0)},touchmove:n=>{if(!this._isDragging||n.touches.length!==1)return;n.preventDefault();const r=n.touches[0].clientX-this._lastMouseX,o=n.touches[0].clientY-this._lastMouseY,a=r*this.sensitivity*s,l=o*this.sensitivity*i;this.rotationY+=a,this.rotationX+=l,this.clampX&&(this.rotationX=Math.max(this.minRotationX,Math.min(this.maxRotationX,this.rotationX))),this.inertia&&(this._lastDeltaX=l,this._lastDeltaY=a,this._lastMoveTime=performance.now()),this._lastMouseX=n.touches[0].clientX,this._lastMouseY=n.touches[0].clientY},touchend:()=>{this.inertia&&this._isDragging&&performance.now()-this._lastMoveTime<50&&(this._velocityX=this._lastDeltaX*this.velocityScale,this._velocityY=this._lastDeltaY*this.velocityScale),this._isDragging=!1},dblclick:()=>{this.reset()}},t.addEventListener("mousedown",this._boundHandlers.mousedown),t.addEventListener("mousemove",this._boundHandlers.mousemove),t.addEventListener("mouseup",this._boundHandlers.mouseup),t.addEventListener("mouseleave",this._boundHandlers.mouseleave),t.addEventListener("touchstart",this._boundHandlers.touchstart),t.addEventListener("touchmove",this._boundHandlers.touchmove,{passive:!1}),t.addEventListener("touchend",this._boundHandlers.touchend),t.addEventListener("dblclick",this._boundHandlers.dblclick),this}disableMouseControl(){return this._canvas&&this._boundHandlers&&(this._canvas.removeEventListener("mousedown",this._boundHandlers.mousedown),this._canvas.removeEventListener("mousemove",this._boundHandlers.mousemove),this._canvas.removeEventListener("mouseup",this._boundHandlers.mouseup),this._canvas.removeEventListener("mouseleave",this._boundHandlers.mouseleave),this._canvas.removeEventListener("touchstart",this._boundHandlers.touchstart),this._canvas.removeEventListener("touchmove",this._boundHandlers.touchmove),this._canvas.removeEventListener("touchend",this._boundHandlers.touchend),this._canvas.removeEventListener("dblclick",this._boundHandlers.dblclick)),this._canvas=null,this._boundHandlers=null,this}reset(){return this.rotationX=this._initialRotationX,this.rotationY=this._initialRotationY,this.rotationZ=this._initialRotationZ,this.x=this._initialX,this.y=this._initialY,this.z=this._initialZ,this._velocityX=0,this._velocityY=0,this._followTarget=null,this._targetX=null,this._targetY=null,this._targetZ=null,this}stopInertia(){return this._velocityX=0,this._velocityY=0,this}setPosition(t,e,s){return this.x=t,this.y=e,this.z=s,this}moveTo(t,e,s,i={}){return this._targetX=t,this._targetY=e,this._targetZ=s,this._targetRotationX=i.rotationX??null,this._targetRotationY=i.rotationY??null,this._positionLerp=i.lerp??.05,this}follow(t,e={}){return this._followTarget=t,this._followOffset={x:e.offsetX??0,y:e.offsetY??0,z:e.offsetZ??0},this._followLookAt=e.lookAt??!0,this._followLookAtTarget=e.lookAtTarget??null,this._followLerp=e.lerp??.1,this}unfollow(t=!1){return this._followTarget=null,t&&this.moveTo(this._initialX,this._initialY,this._initialZ,{rotationX:this._initialRotationX,rotationY:this._initialRotationY,lerp:.05}),this}isFollowing(){return this._followTarget!==null}setRotation(t,e,s=0){return this.rotationX=t,this.rotationY=e,this.rotationZ=s,this}rotate(t,e,s=0){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=s,this.clampX&&(this.rotationX=Math.max(this.minRotationX,Math.min(this.maxRotationX,this.rotationX))),this}isDragging(){return this._isDragging}lookAt(t,e,s){const i=t-this.x,n=e-this.y,r=s-this.z,o=Math.sqrt(i*i+r*r);return this.rotationY=Math.atan2(i,r),this.rotationX=Math.atan2(-n,o),this}}class li{constructor(t={}){this.angle=t.angle??0,this._targetAngle=this.angle,this.rotationStep=t.rotationStep??Math.PI/2,this.animationDuration=t.animationDuration??.4,this.easingType=t.easing??"easeInOutCubic",this._animating=!1,this._animationProgress=0,this._startAngle=0,this._onRotationStart=null,this._onRotationEnd=null}rotateRight(){return this._animating?this:(this._startRotation(this._targetAngle+this.rotationStep),this)}rotateLeft(){return this._animating?this:(this._startRotation(this._targetAngle-this.rotationStep),this)}rotateTo(t){return this._animating?this:(this._startRotation(t),this)}setAngle(t){return this.angle=t,this._targetAngle=t,this._animating=!1,this}_startRotation(t){this._startAngle=this.angle,this._targetAngle=t,this._animationProgress=0,this._animating=!0,this._onRotationStart&&this._onRotationStart(this._startAngle,this._targetAngle)}update(t){if(this._animating)if(this._animationProgress+=t/this.animationDuration,this._animationProgress>=1)this._animationProgress=1,this.angle=this._targetAngle,this._animating=!1,this._onRotationEnd&&this._onRotationEnd(this.angle);else{const e=this._ease(this._animationProgress);this.angle=this._startAngle+(this._targetAngle-this._startAngle)*e}}_ease(t){switch(this.easingType){case"linear":return t;case"easeInQuad":return t*t;case"easeOutQuad":return t*(2-t);case"easeInOutQuad":return t<.5?2*t*t:-1+(4-2*t)*t;case"easeInCubic":return t*t*t;case"easeOutCubic":return--t*t*t+1;case"easeInOutCubic":return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1;case"easeOutBack":const e=1.70158;return 1+(e+1)*Math.pow(t-1,3)+e*Math.pow(t-1,2);default:return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1}}isAnimating(){return this._animating}getAngleDegrees(){return this.angle*180/Math.PI%360}getNormalizedAngle(){let t=this.angle%(Math.PI*2);return t<0&&(t+=Math.PI*2),t}onRotationStart(t){return this._onRotationStart=t,this}onRotationEnd(t){return this._onRotationEnd=t,this}reset(){return this.setAngle(0),this}}class kt{constructor(t,e=0){this.real=t,this.imag=e}static fromPolar(t,e){return new kt(t*Math.cos(e),t*Math.sin(e))}add(t){return new kt(this.real+t.real,this.imag+t.imag)}subtract(t){return new kt(this.real-t.real,this.imag-t.imag)}multiply(t){return new kt(this.real*t.real-this.imag*t.imag,this.real*t.imag+this.imag*t.real)}divide(t){return new kt(this.real/t,this.imag/t)}scale(t){return new kt(this.real*t,this.imag*t)}abs(){return Math.sqrt(this.real*this.real+this.imag*this.imag)}}class We{static applyColorScheme(t,e,s,i,n,r){const o=(e==null?void 0:e.data)||[];for(let a=0;a<t.length;a++){const l=t[a],c=a*4;switch(s){case"futuristic":{const u=t[a]/10,h={r:0,g:5,b:10},d={r:0,g:30,b:20};if(u>.7){const g=(u-.7)*3.33;o[c]=Math.floor(h.r*(1-g)+d.r*g),o[c+1]=Math.floor(h.g*(1-g)+d.g*g),o[c+2]=Math.floor(h.b*(1-g)+d.b*g)}else{const g=u*1.43;o[c]=Math.floor(h.r*g),o[c+1]=Math.floor(h.g*g),o[c+2]=Math.floor(h.b*g)}o[c+3]=255}break;case"rainbow":if(l===0)o[c]=0,o[c+1]=0,o[c+2]=0,o[c+3]=255;else{const u=(l*10+n)%360,[h,d,g]=r(u,.8,.5);o[c]=h,o[c+1]=d,o[c+2]=g,o[c+3]=255}break;case"grayscale":{const u=l===0?0:255-l*255/i;o[c]=u,o[c+1]=u,o[c+2]=u,o[c+3]=255}break;case"binary":l!==0?(o[c]=0,o[c+1]=0,o[c+2]=0):(o[c]=255,o[c+1]=255,o[c+2]=255),o[c+3]=255;break;case"fire":{if(l==0)o[c]=0,o[c+1]=0,o[c+2]=0;else{const u=l/i;if(u<.3){const h=u/.3;o[c]=Math.floor(255*h),o[c+1]=0,o[c+2]=0}else if(u<.6){const h=(u-.3)/.3;o[c]=255,o[c+1]=Math.floor(165*h),o[c+2]=0}else if(u<.9){const h=(u-.6)/.3;o[c]=255,o[c+1]=165+Math.floor(90*h),o[c+2]=Math.floor(255*h)}else o[c]=255,o[c+1]=255,o[c+2]=255}o[c+3]=255}break;case"ocean":{if(l===0)o[c]=0,o[c+1]=20,o[c+2]=50;else{const u=l/i;o[c]=Math.floor(10+50*u),o[c+1]=Math.floor(50+150*u),o[c+2]=Math.floor(100+155*u)}o[c+3]=255}break;case"electric":{if(l===0)o[c]=0,o[c+1]=0,o[c+2]=0;else{const u=(l+n)%3,h=l%20/20;u===0?(o[c]=Math.floor(255*(.5+.5*Math.sin(h*Math.PI*2))),o[c+1]=Math.floor(128*h),o[c+2]=Math.floor(255*h)):u===1?(o[c]=Math.floor(255*h),o[c+1]=Math.floor(255*(.5+.5*Math.sin(h*Math.PI*2))),o[c+2]=Math.floor(128*h)):(o[c]=Math.floor(128*h),o[c+1]=Math.floor(255*h),o[c+2]=Math.floor(255*(.5+.5*Math.sin(h*Math.PI*2))))}o[c+3]=255}break;case"topographic":{if(l===0)o[c]=5,o[c+1]=15,o[c+2]=30;else{const u=l/i;if(u<.1){const h=u/.1;o[c]=Math.floor(5+20*h),o[c+1]=Math.floor(15+40*h),o[c+2]=Math.floor(30+50*h)}else if(u<.3){const h=(u-.1)/.2;o[c]=Math.floor(210+45*h),o[c+1]=Math.floor(180+40*h),o[c+2]=Math.floor(140+30*h)}else if(u<.7){const h=(u-.3)/.4;o[c]=Math.floor(50*(1-h)),o[c+1]=Math.floor(100+80*h),o[c+2]=Math.floor(50*(1-h))}else{const h=(u-.7)/.3;o[c]=Math.floor(150+105*h),o[c+1]=Math.floor(150+105*h),o[c+2]=Math.floor(150+105*h)}}o[c+3]=255}break;case"historic":default:{if(l===0)o[c]=0,o[c+1]=0,o[c+2]=0;else{const h=(l+n)%64;h<16?(o[c]=h*16,o[c+1]=0,o[c+2]=0):h<32?(o[c]=255,o[c+1]=(h-16)*16,o[c+2]=0):h<48?(o[c]=255-(h-32)*16,o[c+1]=255,o[c+2]=0):(o[c]=0,o[c+1]=255-(h-48)*16,o[c+2]=(h-48)*16)}o[c+3]=255}}}return e??o}static pythagorasTree(t,e,s=10,i=-2,n=2,r=-.5,o=3.5){const a=new Uint8Array(t*e),l=b=>Math.floor((b-i)*t/(n-i)),c=b=>Math.floor((b-r)*e/(o-r)),u=(b,S,C,T)=>{const M=l(b),R=c(S),k=l(C),D=c(T);let z=M,A=R;const P=Math.abs(k-M),E=Math.abs(D-R),F=M<k?1:-1,K=R<D?1:-1;let G=P-E;for(;z>=0&&z<t&&A>=0&&A<e&&(a[A*t+z]=255),!(z===k&&A===D);){const nt=2*G;nt>-E&&(G-=E,z+=F),nt<P&&(G+=P,A+=K)}},h=(b,S,C,T,M,R,k,D)=>{u(b,S,C,T),u(C,T,M,R),u(M,R,k,D),u(k,D,b,S)},d=(b,S,C,T,M)=>{if(M<=0)return;const R=C-b,k=T-S,D=C+k,z=T-R,A=b+k,P=S-R;h(b,S,C,T,D,z,A,P);const E=Math.PI/4,F=Math.sqrt(R*R+k*k)*.7,K=F*Math.cos(Math.atan2(k,R)-E),G=F*Math.sin(Math.atan2(k,R)-E),nt=Math.sqrt(R*R+k*k)*.7,pt=nt*Math.cos(Math.atan2(k,R)+E),ut=nt*Math.sin(Math.atan2(k,R)+E),ft=D,tt=z,Q=A,ot=P,Ut=ft+K,Yt=tt+G,$t=Q+pt,xt=ot+ut;d(ft,tt,Ut,Yt,M-1),d(Q,ot,$t,xt,M-1)},g=Math.min(s,12),m=1,p=-1/2,v=0,_=m/2;return d(p,v,_,0,g),a}static mandelbrot(t,e,s=100,i=-2.5,n=1,r=-1.5,o=1.5){const a=new Uint8Array(t*e),l=(n-i)/t,c=(o-r)/e;for(let u=0;u<e;u++){const h=u*t,d=r+u*c;for(let g=0;g<t;g++){const m=i+g*l;let p=0,v=0,_=0,w=0,b=0;do{const S=_-w+m;v=2*p*v+d,p=S,_=p*p,w=v*v,b++}while(_+w<4&&b<s);a[h+g]=b<s?b%256:0}}return a}static julia(t,e,s=100,i=-.7,n=.27,r=1,o=0,a=0){const l=new Uint8Array(t*e),c=2/r,u=-c+o,h=c+o,d=-c+a,g=c+a,m=(h-u)/t,p=(g-d)/e;for(let v=0;v<e;v++){const _=v*t,w=d+v*p;for(let b=0;b<t;b++){let C=u+b*m,T=w,M=0,R=0,k=0;do{M=C*C,R=T*T;const D=M-R+i;T=2*C*T+n,C=D,k++}while(M+R<4&&k<s);l[_+b]=k<s?k%256:0}}return l}static tricorn(t,e,s=100,i=-2.5,n=1.5,r=-1.5,o=1.5){const a=new Uint8Array(t*e),l=(n-i)/t,c=(o-r)/e;for(let u=0;u<e;u++){const h=u*t,d=r+u*c;for(let g=0;g<t;g++){const m=i+g*l;let p=0,v=0,_=0,w=0,b=0;do{const S=_-w+m;v=-2*p*v+d,p=S,_=p*p,w=v*v,b++}while(_+w<4&&b<s);a[h+g]=b<s?b%256:0}}return a}static phoenix(t,e,s=100,i=.5,n=.5,r=-2,o=2,a=-2,l=2){const c=new Uint8Array(t*e),u=(o-r)/t,h=(l-a)/e;for(let d=0;d<e;d++){const g=d*t,m=a+d*h;for(let p=0;p<t;p++){const v=r+p*u;let _=0,w=0,b=0,S=0,C=0,T=0,M=0;do{const R=C-T+v+i*b+n,k=2*_*w+m+i*S;b=_,S=w,_=R,w=k,C=_*_,T=w*w,M++}while(C+T<4&&M<s);c[g+p]=M<s?M%256:0}}return c}static newton(t,e,s=100,i=1e-6,n=-2,r=2,o=-2,a=2){const l=new Uint8Array(t*e),c=i*i,u=r-n,h=a-o,d=3,g=new Float64Array(d),m=new Float64Array(d);for(let _=0;_<d;_++){const w=2*Math.PI*_/d;g[_]=Math.cos(w),m[_]=Math.sin(w)}const p=u/t,v=h/e;for(let _=0;_<e;_++){const w=_*t,b=o+_*v;for(let S=0;S<t;S++){let T=n+S*p,M=b,R=0,k=-1;for(;R<s&&k<0;){const D=T*T-M*M,z=2*T*M,A=D*T-z*M-1,P=D*M+z*T,E=3*D,F=3*z,K=E*E+F*F;if(K<c)break;const G=1/K,nt=(A*E+P*F)*G,pt=(P*E-A*F)*G,ut=T-nt,ft=M-pt;for(let tt=0;tt<d;tt++){const Q=ut-g[tt],ot=ft-m[tt];if(Q*Q+ot*ot<c){k=tt;break}}T=ut,M=ft,R++}if(k>=0){const D=1-Math.min(R/s,1),z=k*(255/d);l[w+S]=Math.floor(z+D*(255/d))}else l[w+S]=0}}return l}static sierpinski(t,e,s=6,i=0,n=1,r=0,o=1){const a=new Uint8Array(t*e).fill(1),l=Math.sqrt(3)/2,c=n-i,h=(o-r)/c;if(Math.abs(h-l)>1e-9){const _=(r+o)/2,w=c*l;r=_-w/2,o=_+w/2}const g=(1<<Math.min(s,32))-1,m=(n-i)/t,p=(o-r)/e,v=2/Math.sqrt(3);for(let _=0;_<e;++_){const w=r+_*p,b=Math.floor(w*v),S=b*.5;for(let C=0;C<t;++C){const T=i+C*m;Math.floor(T-S)&b&g&&(a[_*t+C]=0)}}return a}static sierpinskiCarpet(t,e,s=5,i=0,n=1,r=0,o=1){const a=new Uint8Array(t*e).fill(1),l=n-i,c=o-r,u=Math.max(l,c),h=(i+n)/2,d=(r+o)/2;i=h-u/2,n=h+u/2,r=d-u/2,o=d+u/2;const g=Math.pow(3,s),m=(p,v)=>{let _=p,w=v;for(;_>0||w>0;){if(_%3===1&&w%3===1)return!0;_=Math.floor(_/3),w=Math.floor(w/3)}return!1};for(let p=0;p<e;++p){const _=(r+p/e*(o-r))*g,w=(Math.floor(_)%g+g)%g;for(let b=0;b<t;++b){const C=(i+b/t*(n-i))*g,T=(Math.floor(C)%g+g)%g;m(T,w)&&(a[p*t+b]=0)}}return a}static barnsleyFern(t,e,s=1e5){const i=new Uint8Array(t*e).fill(0);let n=0,r=0;const o=Math.min(t,e)/10,a=t/2;for(let l=0;l<s;l++){const c=Math.random();let u,h;c<.01?(u=0,h=.16*r):c<.86?(u=.85*n+.04*r,h=-.04*n+.85*r+1.6):c<.93?(u=.2*n-.26*r,h=.23*n+.22*r+1.6):(u=-.15*n+.28*r,h=.26*n+.24*r+.44),n=u,r=h;const d=Math.floor(n*o+a),g=Math.floor(e-r*o);if(d>=0&&d<t&&g>=0&&g<e){const m=g*t+d;i[m]<255&&i[m]++}}return i}static lyapunov(t,e,s=1e3,i="AB",n=3.4,r=4,o=3.4,a=4){console.time("lyapunov"),i=i.toUpperCase().replace(/[^AB]/g,"")||"AB";const l=i.length,c=new Float32Array(t*e);let u=1/0,h=-1/0;for(let m=0;m<e;m++){const p=o+(a-o)*m/e;for(let v=0;v<t;v++){const _=n+(r-n)*v/t;let w=.5;for(let T=0;T<100;T++)w=(i[T%l]==="A"?_:p)*w*(1-w);let b=0,S=0;for(;S<s;){const T=i[S%l]==="A"?_:p;w=T*w*(1-w);const M=Math.abs(T*(1-2*w));if(b+=Math.log(Math.max(M,1e-10)),S++,Math.abs(b/S)>10)break}const C=b/S;c[m*t+v]=C,C>-10&&C<10&&(C<u&&(u=C),C>h&&(h=C))}}u===h&&(u-=1,h+=1);const d=h-u,g=new Uint8Array(t*e);for(let m=0;m<c.length;m++){let p=c[m];p=Math.max(-10,Math.min(10,p));let v=(p-u)/d;g[m]=Math.floor(v*255)}return console.timeEnd("lyapunov"),g}static koch(t,e,s=4,i=-2,n=2,r=-2,o=2){const a=new Uint8Array(t*e),l=w=>Math.floor((w-i)*t/(n-i)),c=w=>Math.floor((w-r)*e/(o-r)),u=(w,b,S,C)=>{const T=l(w),M=c(b),R=l(S),k=c(C);let D=T,z=M;const A=Math.abs(R-T),P=Math.abs(k-M),E=T<R?1:-1,F=M<k?1:-1;let K=A-P;for(;D>=0&&D<t&&z>=0&&z<e&&(a[z*t+D]=255),!(D===R&&z===k);){const G=2*K;G>-P&&(K-=P,D+=E),G<A&&(K+=A,z+=F)}},h=(w,b,S,C,T)=>{if(T<=0){u(w,b,S,C);return}const M=(S-w)/3,R=(C-b)/3,k=w+M,D=b+R,z=w+2*M,A=b+2*R,P=Math.PI/3,E=k+M*Math.cos(P)-R*Math.sin(P),F=D+M*Math.sin(P)+R*Math.cos(P);h(w,b,k,D,T-1),h(k,D,E,F,T-1),h(E,F,z,A,T-1),h(z,A,S,C,T-1)},d=Math.min(s,10),g=3,m=g*Math.sqrt(3)/2,p=[0,-m/2+.5],v=[-3/2,m/2+.5],_=[g/2,m/2+.5];return h(p[0],p[1],v[0],v[1],d),h(v[0],v[1],_[0],_[1],d),h(_[0],_[1],p[0],p[1],d),a}}I(We,"types",{MANDELBROT:"mandelbrot",TRICORN:"tricorn",PHOENIX:"phoenix",JULIA:"julia",SIERPINSKI:"sierpinski",SCARPET:"sierpinskiCarpet",BARNSEY_FERN:"barnsleyFern",KOCH:"koch",PYTHAGORAS_TREE:"pythagorasTree",NEWTON:"newton",LYAPUNOV:"lyapunov"});I(We,"colors",{FUTURISTIC:"futuristic",RAINBOW:"rainbow",GRAYSCALE:"grayscale",TOPOGRAPHIC:"topographic",FIRE:"fire",OCEAN:"ocean",ELECTRIC:"electric",BINARY:"binary",HISTORIC:"historic"});const Z=class{static seed(t){t>0&&t<1&&(t*=65536),t=Math.floor(t),t<256&&(t|=t<<8);for(let e=0;e<256;e++){let s;e&1?s=x(this,he)[e]^t&255:s=x(this,he)[e]^t>>8&255,x(this,Y)[e]=x(this,Y)[e+256]=s,x(this,V)[e]=x(this,V)[e+256]=x(this,Me)[s%12]}}static simplex2(t,e){let s,i,n;const r=(t+e)*x(this,Se),o=Math.floor(t+r),a=Math.floor(e+r),l=(o+a)*x(this,Lt),c=t-o+l,u=e-a+l;let h,d;c>u?(h=1,d=0):(h=0,d=1);const g=c-h+x(this,Lt),m=u-d+x(this,Lt),p=c-1+2*x(this,Lt),v=u-1+2*x(this,Lt),_=o&255,w=a&255,b=x(this,V)[_+x(this,Y)[w]],S=x(this,V)[_+h+x(this,Y)[w+d]],C=x(this,V)[_+1+x(this,Y)[w+1]];let T=.5-c*c-u*u;T<0?s=0:(T*=T,s=T*T*b.dot2(c,u));let M=.5-g*g-m*m;M<0?i=0:(M*=M,i=M*M*S.dot2(g,m));let R=.5-p*p-v*v;return R<0?n=0:(R*=R,n=R*R*C.dot2(p,v)),70*(s+i+n)}static simplex3(t,e,s){let i,n,r,o;const a=(t+e+s)*x(this,Ce),l=Math.floor(t+a),c=Math.floor(e+a),u=Math.floor(s+a),h=(l+c+u)*x(this,yt),d=t-l+h,g=e-c+h,m=s-u+h;let p,v,_,w,b,S;d>=g?g>=m?(p=1,v=0,_=0,w=1,b=1,S=0):d>=m?(p=1,v=0,_=0,w=1,b=0,S=1):(p=0,v=0,_=1,w=1,b=0,S=1):g<m?(p=0,v=0,_=1,w=0,b=1,S=1):d<m?(p=0,v=1,_=0,w=0,b=1,S=1):(p=0,v=1,_=0,w=1,b=1,S=0);const C=d-p+x(this,yt),T=g-v+x(this,yt),M=m-_+x(this,yt),R=d-w+2*x(this,yt),k=g-b+2*x(this,yt),D=m-S+2*x(this,yt),z=d-1+3*x(this,yt),A=g-1+3*x(this,yt),P=m-1+3*x(this,yt),E=l&255,F=c&255,K=u&255,G=x(this,V)[E+x(this,Y)[F+x(this,Y)[K]]],nt=x(this,V)[E+p+x(this,Y)[F+v+x(this,Y)[K+_]]],pt=x(this,V)[E+w+x(this,Y)[F+b+x(this,Y)[K+S]]],ut=x(this,V)[E+1+x(this,Y)[F+1+x(this,Y)[K+1]]];let ft=.6-d*d-g*g-m*m;ft<0?i=0:(ft*=ft,i=ft*ft*G.dot3(d,g,m));let tt=.6-C*C-T*T-M*M;tt<0?n=0:(tt*=tt,n=tt*tt*nt.dot3(C,T,M));let Q=.6-R*R-k*k-D*D;Q<0?r=0:(Q*=Q,r=Q*Q*pt.dot3(R,k,D));let ot=.6-z*z-A*A-P*P;return ot<0?o=0:(ot*=ot,o=ot*ot*ut.dot3(z,A,P)),32*(i+n+r+o)}static perlin2(t,e){const s=Math.floor(t),i=Math.floor(e);t=t-s,e=e-i;const n=s&255,r=i&255,o=x(this,V)[n+x(this,Y)[r]].dot2(t,e),a=x(this,V)[n+x(this,Y)[r+1]].dot2(t,e-1),l=x(this,V)[n+1+x(this,Y)[r]].dot2(t-1,e),c=x(this,V)[n+1+x(this,Y)[r+1]].dot2(t-1,e-1),u=J(this,it,qt).call(this,t);return J(this,it,wt).call(this,J(this,it,wt).call(this,o,l,u),J(this,it,wt).call(this,a,c,u),J(this,it,qt).call(this,e))}static perlin3(t,e,s){const i=Math.floor(t),n=Math.floor(e),r=Math.floor(s);t=t-i,e=e-n,s=s-r;const o=i&255,a=n&255,l=r&255,c=x(this,V)[o+x(this,Y)[a+x(this,Y)[l]]].dot3(t,e,s),u=x(this,V)[o+x(this,Y)[a+x(this,Y)[l+1]]].dot3(t,e,s-1),h=x(this,V)[o+x(this,Y)[a+1+x(this,Y)[l]]].dot3(t,e-1,s),d=x(this,V)[o+x(this,Y)[a+1+x(this,Y)[l+1]]].dot3(t,e-1,s-1),g=x(this,V)[o+1+x(this,Y)[a+x(this,Y)[l]]].dot3(t-1,e,s),m=x(this,V)[o+1+x(this,Y)[a+x(this,Y)[l+1]]].dot3(t-1,e,s-1),p=x(this,V)[o+1+x(this,Y)[a+1+x(this,Y)[l]]].dot3(t-1,e-1,s),v=x(this,V)[o+1+x(this,Y)[a+1+x(this,Y)[l+1]]].dot3(t-1,e-1,s-1),_=J(this,it,qt).call(this,t),w=J(this,it,qt).call(this,e),b=J(this,it,qt).call(this,s);return J(this,it,wt).call(this,J(this,it,wt).call(this,J(this,it,wt).call(this,c,g,_),J(this,it,wt).call(this,u,m,_),b),J(this,it,wt).call(this,J(this,it,wt).call(this,h,p,_),J(this,it,wt).call(this,d,v,_),b),w)}};lt=new WeakMap;Me=new WeakMap;he=new WeakMap;Y=new WeakMap;V=new WeakMap;Se=new WeakMap;Lt=new WeakMap;Ce=new WeakMap;yt=new WeakMap;it=new WeakSet;qt=function(f){return f*f*f*(f*(f*6-15)+10)};wt=function(f,t,e){return(1-e)*f+e*t};O(Z,it);O(Z,lt,class{constructor(f,t,e){this.x=f,this.y=t,this.z=e}dot2(f,t){return this.x*f+this.y*t}dot3(f,t,e){return this.x*f+this.y*t+this.z*e}});O(Z,Me,[new(x(Z,lt))(1,1,0),new(x(Z,lt))(-1,1,0),new(x(Z,lt))(1,-1,0),new(x(Z,lt))(-1,-1,0),new(x(Z,lt))(1,0,1),new(x(Z,lt))(-1,0,1),new(x(Z,lt))(1,0,-1),new(x(Z,lt))(-1,0,-1),new(x(Z,lt))(0,1,1),new(x(Z,lt))(0,-1,1),new(x(Z,lt))(0,1,-1),new(x(Z,lt))(0,-1,-1)]);O(Z,he,[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]);O(Z,Y,new Array(512));O(Z,V,new Array(512));O(Z,Se,.5*(Math.sqrt(3)-1));O(Z,Lt,(3-Math.sqrt(3))/6);O(Z,Ce,1/3);O(Z,yt,1/6);Z.seed(0);let bt=Z;function ss(f=800,t=800,e){const{divisions:s=5,zoomType:i="in",color1:n=[255,0,0,255],color2:r=[0,0,255,255],color3:o=[0,0,0,255],backgroundColor:a=[255,255,255,255]}=e||{},l=new Uint8ClampedArray(f*t*4);for(let b=0;b<l.length;b+=4)l[b]=a[0],l[b+1]=a[1],l[b+2]=a[2],l[b+3]=a[3]||255;const c=i==="in"?1:2,u=Math.max(f,t),h=u/c,d=u/c,g=.5*c,m=.5*c,p=(Math.sqrt(5)+1)/2,v=5;let _=[];for(let b=0;b<v*2;b++){const S=kt.fromPolar(1,(2*b-1)*Math.PI/(v*2)),C=kt.fromPolar(1,(2*b+1)*Math.PI/(v*2));b%2===0?_.push(["thin",new kt(0),C,S]):_.push(["thin",new kt(0),S,C])}for(let b=0;b<s;b++){const S=[];for(const[C,T,M,R]of _)if(C==="thin"){const k=T.add(M.subtract(T).scale(1/p));S.push(["thin",R,k,M]),S.push(["thicc",k,R,T])}else{const k=M.add(T.subtract(M).scale(1/p)),D=M.add(R.subtract(M).scale(1/p));S.push(["thicc",D,R,T]),S.push(["thicc",k,D,M]),S.push(["thin",D,k,T])}_=S}function w(b){const S=Math.floor((b.real*h+g*h)*f/u),C=Math.floor((b.imag*d+m*d)*t/u);return{x:S,y:C}}for(const[b,S,C,T]of _){const M=w(S),R=w(C),k=w(T);is(l,M,R,k,b==="thin"?n:r,f,t)}if(o&&o[3]>0)for(const[b,S,C,T]of _){const M=w(S),R=w(C),k=w(T);_e(l,M,R,o,f,t),_e(l,R,k,o,f,t),_e(l,k,M,o,f,t)}return l}function is(f,t,e,s,i,n,r){t.y>e.y&&([t,e]=[e,t]),t.y>s.y&&([t,s]=[s,t]),e.y>s.y&&([e,s]=[s,e]);const o=i[0],a=i[1],l=i[2],c=i[3]||255;if(e.y===s.y)Ee(f,t,e,s,o,a,l,c,n,r);else if(t.y===e.y)Xe(f,t,e,s,o,a,l,c,n,r);else{const u={x:Math.floor(t.x+(e.y-t.y)/(s.y-t.y)*(s.x-t.x)),y:e.y};Ee(f,t,e,u,o,a,l,c,n,r),Xe(f,e,u,s,o,a,l,c,n,r)}}function Ee(f,t,e,s,i,n,r,o,a,l){const c=(e.x-t.x)/(e.y-t.y||1),u=(s.x-t.x)/(s.y-t.y||1);let h=t.x,d=t.x;for(let g=t.y;g<=e.y;g++){if(g>=0&&g<l){const m=Math.max(0,Math.min(Math.floor(h),a-1)),p=Math.max(0,Math.min(Math.floor(d),a-1));for(let v=Math.min(m,p);v<=Math.max(m,p);v++){const _=(g*a+v)*4;_>=0&&_<f.length-3&&(f[_]=i,f[_+1]=n,f[_+2]=r,f[_+3]=o)}}h+=c,d+=u}}function Xe(f,t,e,s,i,n,r,o,a,l){const c=(s.x-t.x)/(s.y-t.y||1),u=(s.x-e.x)/(s.y-e.y||1);let h=s.x,d=s.x;for(let g=s.y;g>t.y;g--)if(g>=0&&g<l){h-=c,d-=u;const m=Math.max(0,Math.min(Math.floor(h),a-1)),p=Math.max(0,Math.min(Math.floor(d),a-1));for(let v=Math.min(m,p);v<=Math.max(m,p);v++){const _=(g*a+v)*4;_>=0&&_<f.length-3&&(f[_]=i,f[_+1]=n,f[_+2]=r,f[_+3]=o)}}}function _e(f,t,e,s,i,n){const r=s[0],o=s[1],a=s[2],l=s[3]||255;let c=t.x,u=t.y,h=e.x,d=e.y;const g=Math.abs(h-c),m=Math.abs(d-u),p=c<h?1:-1,v=u<d?1:-1;let _=g-m;for(;;){if(c>=0&&c<i&&u>=0&&u<n){const b=(u*i+c)*4;if(b>=0&&b<f.length-3){const S=l/255;f[b]=Math.round(f[b]*(1-S)+r*S),f[b+1]=Math.round(f[b+1]*(1-S)+o*S),f[b+2]=Math.round(f[b+2]*(1-S)+a*S),f[b+3]=255}}if(c===h&&u===d)break;const w=2*_;w>-m&&(_-=m,c+=p),w<g&&(_+=g,u+=v)}}class hi{static void(t,e,s={}){const{background:i=[255,255,255,255],foreground:n=[0,0,200,255]}=s,r=new Uint8ClampedArray(t*e*4);for(let o=0;o<r.length;o+=4)r[o]=i[0],r[o+1]=i[1],r[o+2]=i[2],r[o+3]=i[3];return r}static solidGrid(t,e,s={}){const{spacing:i=8,background:n=[0,0,0,0],foreground:r=[128,128,128,255]}=s,o=new Uint8ClampedArray(t*e*4);for(let a=0;a<e;a++){const l=a%i===0;for(let c=0;c<t;c++){const h=c%i===0||l,d=(a*t+c)*4,g=h?r:n;o[d]=g[0],o[d+1]=g[1],o[d+2]=g[2],o[d+3]=g[3]}}return o}static checkerboard(t,e,s={}){const{cellSize:i=8,color1:n=[0,0,0,255],color2:r=[255,255,255,255]}=s,o=new Uint8ClampedArray(t*e*4);for(let a=0;a<e;a++){const l=Math.floor(a/i);for(let c=0;c<t;c++){const d=(Math.floor(c/i)+l)%2===0?n:r,g=(a*t+c)*4;o.set(d,g)}}return o}static stripes(t,e,s={}){const{spacing:i=4,thickness:n=1,background:r=[0,0,0,0],foreground:o=[255,255,0,255]}=s,a=new Uint8ClampedArray(t*e*4);for(let l=0;l<e;l++)for(let c=0;c<t;c++){const h=(c+l)%i<n,d=(l*t+c)*4;a.set(h?o:r,d)}return a}static honeycomb(t,e,s={}){const{radius:i=10,lineWidth:n=1,foreground:r=[255,255,255,255],background:o=[0,0,0,255]}=s,a=new Uint8ClampedArray(t*e*4);for(let _=0;_<a.length;_+=4)a[_]=o[0],a[_+1]=o[1],a[_+2]=o[2],a[_+3]=o[3];const l=Math.floor(t/2),c=Math.floor(e/2),u=(_,w,b,S,C)=>{const T=Math.abs(_-b),M=Math.abs(w-S),R=C*Math.sqrt(3)/2;return M>R||T>C?!1:C*R*2>=C*M*2+R*T},h=i-n,d=i*Math.sqrt(3),g=Math.max(0,Math.floor(l-i-1)),m=Math.min(t-1,Math.ceil(l+i+1)),p=Math.max(0,Math.floor(c-d/2-1)),v=Math.min(e-1,Math.ceil(c+d/2+1));for(let _=p;_<=v;_++)for(let w=g;w<=m;w++){const b=u(w,_,l,c,i),S=h>0?u(w,_,l,c,h):!1;if(b&&!S){const C=(_*t+w)*4;a[C]=r[0],a[C+1]=r[1],a[C+2]=r[2],a[C+3]=r[3]}}return a}static harlequin(t,e,s={}){const{size:i=20,spacing:n=0,background:r=[255,255,255,255],foreground:o=[0,0,0,255]}=s,a=new Uint8ClampedArray(t*e*4);for(let g=0;g<a.length;g+=4)a[g]=r[0],a[g+1]=r[1],a[g+2]=r[2],a[g+3]=r[3];const l=i*2,c=i*2,u=l+n,h=c+n,d=(g,m,p,v)=>{const _=Math.abs(g-p)/(l/2),w=Math.abs(m-v)/(c/2);return _+w<=1};for(let g=-1;g<e/h+1;g++)for(let m=-1;m<t/u+1;m++){const p=m*u+u/2,v=g*h+h/2;if(!((g+m)%2===0))continue;const w=Math.max(0,Math.floor(p-l/2)),b=Math.min(t-1,Math.ceil(p+l/2)),S=Math.max(0,Math.floor(v-c/2)),C=Math.min(e-1,Math.ceil(v+c/2));for(let T=S;T<=C;T++)for(let M=w;M<=b;M++)if(d(M,T,p,v)){const R=(T*t+M)*4;a[R]=o[0],a[R+1]=o[1],a[R+2]=o[2],a[R+3]=o[3]}}return a}static circles(t,e,s={}){const{radius:i=10,lineWidth:n=2,spacing:r=5,background:o=[0,0,0,255],foreground:a=[255,255,255,255]}=s,l=new Uint8ClampedArray(t*e*4);for(let h=0;h<l.length;h+=4)l[h]=o[0],l[h+1]=o[1],l[h+2]=o[2],l[h+3]=o[3];const c=i*2+r,u=(h,d,g,m,p)=>{const v=h-g,_=d-m;return v*v+_*_<=p*p};for(let h=0;h<Math.ceil(e/c)+1;h++)for(let d=0;d<Math.ceil(t/c)+1;d++){const g=d*c+i,m=h*c+i;if(g<-i||g>t+i||m<-i||m>e+i)continue;const p=Math.max(0,Math.floor(g-i)),v=Math.min(t-1,Math.ceil(g+i)),_=Math.max(0,Math.floor(m-i)),w=Math.min(e-1,Math.ceil(m+i)),b=i-n;for(let S=_;S<=w;S++)for(let C=p;C<=v;C++){const T=u(C,S,g,m,i),M=u(C,S,g,m,b);if(T&&!M){const R=(S*t+C)*4;l[R]=a[0],l[R+1]=a[1],l[R+2]=a[2],l[R+3]=a[3]}}}return l}static diamonds(t,e,s={}){const{size:i=16,squareSize:n=6,background:r=[255,255,255,255],foreground:o=[0,0,0,255],innerColor:a=[255,255,255,255]}=s,l=new Uint8ClampedArray(t*e*4);for(let d=0;d<l.length;d+=4)l[d]=r[0],l[d+1]=r[1],l[d+2]=r[2],l[d+3]=r[3];const c=i,u=(d,g,m,p,v)=>{const _=Math.abs(d-m),w=Math.abs(g-p);return _+w<=v/2},h=(d,g,m,p,v)=>Math.abs(d-m)<=v/2&&Math.abs(g-p)<=v/2;for(let d=-1;d<e/c+1;d++)for(let g=-1;g<t/c+1;g++){const m=g*c+c/2,p=d*c+c/2;if(m<-c||m>t+c||p<-c||p>e+c)continue;const v=Math.max(0,Math.floor(m-c/2)),_=Math.min(t-1,Math.ceil(m+c/2)),w=Math.max(0,Math.floor(p-c/2)),b=Math.min(e-1,Math.ceil(p+c/2));for(let S=w;S<=b;S++)for(let C=v;C<=_;C++){const T=u(C,S,m,p,c),M=h(C,S,m,p,n);if(T){const R=(S*t+C)*4;M?(l[R]=a[0],l[R+1]=a[1],l[R+2]=a[2],l[R+3]=a[3]):(l[R]=o[0],l[R+1]=o[1],l[R+2]=o[2],l[R+3]=o[3])}}}return l}static cubes(t,e,s={}){const{size:i=10,spacing:n=2,background:r=[0,0,0,255],foreground:o=[255,100,0,255]}=s,a=new Uint8ClampedArray(t*e*4);for(let c=0;c<a.length;c+=4)a[c]=r[0],a[c+1]=r[1],a[c+2]=r[2],a[c+3]=r[3];const l=i+n;for(let c=0;c<Math.ceil(e/l)+1;c++)for(let u=0;u<Math.ceil(t/l)+1;u++){const h=u*l,d=c*l;if(!(h>=t||d>=e))for(let g=d;g<Math.min(d+i,e);g++)for(let m=h;m<Math.min(h+i,t);m++){const p=(g*t+m)*4;a[p]=o[0],a[p+1]=o[1],a[p+2]=o[2],a[p+3]=o[3]}}return a}static cross(t,e,s={}){const{size:i=8,thickness:n=2,spacing:r=16,background:o=[255,255,255,255],foreground:a=[80,80,80,255]}=s,l=new Uint8ClampedArray(t*e*4);for(let c=0;c<l.length;c+=4)l[c]=o[0],l[c+1]=o[1],l[c+2]=o[2],l[c+3]=o[3];for(let c=0;c<Math.ceil(e/r)+1;c++)for(let u=0;u<Math.ceil(t/r)+1;u++){const h=u*r,d=c*r;if(h<-i||h>t+i||d<-i||d>e+i)continue;const g=h-i/2,m=h+i/2,p=d-n/2,v=d+n/2;for(let C=Math.max(0,Math.floor(p));C<Math.min(e,Math.ceil(v));C++)for(let T=Math.max(0,Math.floor(g));T<Math.min(t,Math.ceil(m));T++){const M=(C*t+T)*4;l[M]=a[0],l[M+1]=a[1],l[M+2]=a[2],l[M+3]=a[3]}const _=h-n/2,w=h+n/2,b=d-i/2,S=d+i/2;for(let C=Math.max(0,Math.floor(b));C<Math.min(e,Math.ceil(S));C++)for(let T=Math.max(0,Math.floor(_));T<Math.min(t,Math.ceil(w));T++){const M=(C*t+T)*4;l[M]=a[0],l[M+1]=a[1],l[M+2]=a[2],l[M+3]=a[3]}}return l}static mesh(t,e,s={}){const{spacing:i=20,lineWidth:n=2,background:r=[255,255,255,0],foreground:o=[0,0,0,255]}=s,a=new Uint8ClampedArray(t*e*4);for(let l=0;l<a.length;l+=4)a[l]=r[0],a[l+1]=r[1],a[l+2]=r[2],a[l+3]=r[3];for(let l=0;l<e;l++)for(let c=0;c<t;c++){const u=(c+l)%i,h=u<n||u>i-n,d=(c-l+e)%i,g=d<n||d>i-n;if(h||g){const m=(l*t+c)*4;a[m]=o[0],a[m+1]=o[1],a[m+2]=o[2],a[m+3]=o[3]}}return a}static isometric(t,e,s={}){const{cellSize:i=20,lineWidth:n=1,background:r=[0,0,0,0],foreground:o=[0,255,0,255]}=s,a=new Uint8ClampedArray(t*e*4);for(let u=0;u<a.length;u+=4)a[u]=r[0],a[u+1]=r[1],a[u+2]=r[2],a[u+3]=r[3];const l=i,c=i/2;for(let u=0;u<e;u++)for(let h=0;h<t;h++){const d=h%l,g=u%c,m=g-d/2,p=g+d/2-c,v=Math.abs(m)<n/2,_=Math.abs(p)<n/2;if(v||_){const w=(u*t+h)*4;a[w]=o[0],a[w+1]=o[1],a[w+2]=o[2],a[w+3]=o[3]}}return a}static weave(t,e,s={}){const{tileSize:i=40,lineWidth:n=2,background:r=[255,255,255,255],foreground:o=[0,0,0,255]}=s,a=new Uint8ClampedArray(t*e*4);for(let l=0;l<a.length;l+=4)a[l]=r[0],a[l+1]=r[1],a[l+2]=r[2],a[l+3]=r[3];for(let l=0;l<e;l++)for(let c=0;c<t;c++){const u=c%i,h=l%i,d=Math.abs((h+i/2)%i-i/2)<n/2,g=Math.abs((u+h*2+i*1.5)%i-i/2)<n/2,m=Math.abs((u-h*2+i*1.5)%i-i/2)<n/2;if(d||g||m){const v=(l*t+c)*4;a[v]=o[0],a[v+1]=o[1],a[v+2]=o[2],a[v+3]=o[3]}}return a}static perlinNoise(t,e,s={}){const{background:i=[0,0,0,0],foreground:n=[255,255,255,255],scale:r=.1,octaves:o=4,persistence:a=.5,lacunarity:l=2,seed:c=Math.random()*65536}=s,u=new Uint8ClampedArray(t*e*4);bt.seed(c);for(let h=0;h<e;h++)for(let d=0;d<t;d++){let g=1,m=1,p=0,v=0;for(let S=0;S<o;S++){const C=d*r*m,T=h*r*m,M=bt.perlin2(C,T);p+=M*g,v+=g,g*=a,m*=l}p/=v;const _=(p+1)*.5,w=[Math.floor(i[0]+_*(n[0]-i[0])),Math.floor(i[1]+_*(n[1]-i[1])),Math.floor(i[2]+_*(n[2]-i[2])),Math.floor(i[3]+_*(n[3]-i[3]))],b=(h*t+d)*4;u.set(w,b)}return u}static circularGradient(t,e,s={}){const{innerColor:i=[255,255,255,255],outerColor:n=[0,0,0,255],centerX:r=t/2,centerY:o=e/2,radius:a=Math.min(t,e)/2,fadeExponent:l=1}=s,c=new Uint8ClampedArray(t*e*4);for(let u=0;u<e;u++)for(let h=0;h<t;h++){const d=(u*t+h)*4,g=h-r,m=u-o,p=Math.sqrt(g*g+m*m);let v=Math.min(p/a,1);v=Math.pow(v,l);const _=[Math.floor(i[0]+v*(n[0]-i[0])),Math.floor(i[1]+v*(n[1]-i[1])),Math.floor(i[2]+v*(n[2]-i[2])),Math.floor(i[3]+v*(n[3]-i[3]))];c.set(_,d)}return c}static noiseDisplacement(t,e,s={}){const{gridSpacing:i=16,gridColor:n=[255,255,255,255],background:r=[0,0,0,0],displacementScale:o=8,noiseScale:a=.05,gridThickness:l=1,seed:c=Math.random()*65536}=s,u=new Uint8ClampedArray(t*e*4);bt.seed(c);for(let h=0;h<u.length;h+=4)u.set(r,h);for(let h=0;h<e;h++)for(let d=0;d<t;d++){const g=bt.perlin2(d*a,h*a),m=bt.perlin2((d+31.416)*a,(h+27.182)*a),p=d+g*o,v=h+m*o,_=p%i<l||p%i>i-l,w=v%i<l||v%i>i-l;if(_||w){const b=(h*t+d)*4;u.set(n,b)}}return u}static dotPattern(t,e,s={}){const{dotSize:i=3,spacing:n=12,dotColor:r=[0,0,0,255],background:o=[255,255,255,255],useNoise:a=!1,noiseScale:l=.1,noiseDensity:c=.4,seed:u=Math.random()*65536}=s,h=new Uint8ClampedArray(t*e*4);a&&bt.seed(u);for(let d=0;d<h.length;d+=4)h.set(o,d);if(a){for(let d=0;d<e;d++)for(let g=0;g<t;g++)if((bt.perlin2(g*l,d*l)+1)*.5>c)for(let v=-i;v<=i;v++)for(let _=-i;_<=i;_++){const w=g+_,b=d+v;if(w>=0&&w<t&&b>=0&&b<e&&_*_+v*v<=i*i){const C=(b*t+w)*4;h.set(r,C)}}}else for(let d=Math.floor(n/2);d<e;d+=n)for(let g=Math.floor(n/2);g<t;g+=n)for(let m=-i;m<=i;m++)for(let p=-i;p<=i;p++){const v=g+p,_=d+m;if(v>=0&&v<t&&_>=0&&_<e&&p*p+m*m<=i*i){const b=(_*t+v)*4;h.set(r,b)}}return h}static voronoi(t,e,s={}){const{cellCount:i=20,cellColors:n=null,edgeColor:r=[0,0,0,255],edgeThickness:o=1.5,seed:a=Math.random()*1e3,jitter:l=.5,baseColor:c=null,colorVariation:u=.3}=s,h=new Uint8ClampedArray(t*e*4);bt.seed(a);const d=[],g=[],m=()=>{let S=Math.sin(a*.167+d.length*.423)*1e4;return S-Math.floor(S)},p=Math.sqrt(i),v=t/p,_=e/p,w=S=>{if(c){const[C,T,M,R]=c,k=Math.max(C,T,M)/255,D=Math.min(C,T,M)/255,z=(k+D)/2;let A,P;if(k===D)A=P=0;else{const Q=k-D;P=z>.5?Q/(2-k-D):Q/(k+D),k===C/255?A=(T/255-M/255)/Q+(T/255<M/255?6:0):k===T/255?A=(M/255-C/255)/Q+2:A=(C/255-T/255)/Q+4,A/=6}const E=bt.perlin2(S*.15,0)*u*.3,F=bt.perlin2(0,S*.15)*u,K=bt.perlin2(S*.15,S*.15)*u*.5;A=(A+E)%1,P=Math.min(1,Math.max(0,P*(1+F)));const G=Math.min(.9,Math.max(.1,z*(1+K)));let nt,pt,ut;if(P===0)nt=pt=ut=G;else{const Q=(Yt,$t,xt)=>(xt<0&&(xt+=1),xt>1&&(xt-=1),xt<.16666666666666666?Yt+($t-Yt)*6*xt:xt<.5?$t:xt<.6666666666666666?Yt+($t-Yt)*(.6666666666666666-xt)*6:Yt),ot=G<.5?G*(1+P):G+P-G*P,Ut=2*G-ot;nt=Q(Ut,ot,A+1/3),pt=Q(Ut,ot,A),ut=Q(Ut,ot,A-1/3)}const ft=.05,tt=()=>(m()*2-1)*ft;return[Math.min(255,Math.max(0,Math.floor(nt*255*(1+tt())))),Math.min(255,Math.max(0,Math.floor(pt*255*(1+tt())))),Math.min(255,Math.max(0,Math.floor(ut*255*(1+tt())))),R]}else{const C=S*.618033988749895%1;let T,M,R;const k=C*6,D=Math.floor(k),z=k-D,A=.5,P=.5*(1-z),E=.5*(1-(1-z));switch(D%6){case 0:T=.5,M=E,R=A;break;case 1:T=P,M=.5,R=A;break;case 2:T=A,M=.5,R=E;break;case 3:T=A,M=P,R=.5;break;case 4:T=E,M=A,R=.5;break;case 5:T=.5,M=A,R=P;break}return[Math.floor(T*255+50+m()*100),Math.floor(M*255+50+m()*100),Math.floor(R*255+50+m()*100),255]}};for(let S=0;S<p;S++)for(let C=0;C<p&&!(d.length>=i);C++){const T=C*v+v/2,M=S*_+_/2,R=(m()*2-1)*l*v,k=(m()*2-1)*l*_;d.push({x:Math.floor(T+R),y:Math.floor(M+k)}),n&&d.length-1<n.length?g.push(n[d.length-1]):g.push(w(d.length-1))}const b=(S,C,T,M)=>{let R=Math.abs(S-T),k=Math.abs(C-M);R=Math.min(R,t-R),k=Math.min(k,e-k);const D=Math.sqrt(R*R+k*k),z=R+k;return D*.8+z*.2};for(let S=0;S<e;S++)for(let C=0;C<t;C++){const T=(S*t+C)*4;let M=1/0,R=1/0,k=0;for(let A=0;A<d.length;A++){const P=b(C,S,d[A].x,d[A].y);P<M?(R=M,M=P,k=A):P<R&&(R=P)}for(let A=0;A<d.length;A++)for(let P=-1;P<=1;P++)for(let E=-1;E<=1;E++){if(P===0&&E===0)continue;const F=d[A].x+P*t,K=d[A].y+E*e,G=Math.sqrt(Math.pow(C-F,2)+Math.pow(S-K,2));G<M?(R=M,M=G,k=A):G<R&&(R=G)}R-M<o?h.set(r,T):h.set(g[k],T)}return h}static penrose(t,e,s={}){return ss(t,e,s)}}function ns(f,t,e,s,i=5){return f<=i||f>=t?0:Math.exp(-f*s)*e}function ui(f,t,e,s,i,n=5){const r=Math.sqrt(f*f+t*t);if(r<=n||r>=e)return{x:f,y:t,displacement:0};const o=ns(r,e,s,i,n),a=(r+o)/r;return{x:f*a,y:t*a,displacement:o}}function fi(f,t,e=1,s=5){return f<=0?0:e*Math.sqrt(t)/Math.pow(f/s,1.5)}class st{static lerp(t,e,s){return t+(e-t)*s}static linear(t){return t}static smoothstep(t){return t*t*(3-2*t)}static smootherstep(t){return t*t*t*(t*(t*6-15)+10)}static easeInQuad(t){return t*t}static easeOutQuad(t){return t*(2-t)}static easeInOutQuad(t){return t<.5?2*t*t:-1+(4-2*t)*t}static easeInCubic(t){return t*t*t}static easeOutCubic(t){return--t*t*t+1}static easeInOutCubic(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1}static easeInQuart(t){return t*t*t*t}static easeOutQuart(t){return 1- --t*t*t*t}static easeInOutQuart(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t}static easeInSine(t){return 1-Math.cos(t*Math.PI/2)}static easeOutSine(t){return Math.sin(t*Math.PI/2)}static easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}static easeInExpo(t){return t===0?0:Math.pow(2,10*(t-1))}static easeOutExpo(t){return t===1?1:1-Math.pow(2,-10*t)}static easeInOutExpo(t){return t===0||t===1?t:t<.5?.5*Math.pow(2,20*t-10):.5*(2-Math.pow(2,-20*t+10))}static easeInCirc(t){return 1-Math.sqrt(1-t*t)}static easeOutCirc(t){return Math.sqrt(1- --t*t)}static easeInOutCirc(t){return t<.5?.5*(1-Math.sqrt(1-4*t*t)):.5*(Math.sqrt(-(2*t-3)*(2*t-1))+1)}static easeInElastic(t,e=1,s=.3){if(t===0||t===1)return t;const i=s/(2*Math.PI)*Math.asin(1/e);return-(e*Math.pow(2,10*(t-1))*Math.sin((t-1-i)*(2*Math.PI)/s))}static easeOutElastic(t,e=1,s=.3){if(t===0||t===1)return t;const i=s/(2*Math.PI)*Math.asin(1/e);return e*Math.pow(2,-10*t)*Math.sin((t-i)*(2*Math.PI)/s)+1}static easeInOutElastic(t,e=1,s=.3){if(t===0||t===1)return t;const i=s/(2*Math.PI)*Math.asin(1/e);return t<.5?-.5*(e*Math.pow(2,10*(2*t-1))*Math.sin((2*t-1-i)*(2*Math.PI)/s)):e*Math.pow(2,-10*(2*t-1))*Math.sin((2*t-1-i)*(2*Math.PI)/s)*.5+1}static easeInBack(t,e=1.70158){return t*t*((e+1)*t-e)}static easeOutBack(t,e=1.70158){return--t*t*((e+1)*t+e)+1}static easeInOutBack(t,e=1.70158){const s=e*1.525;return t<.5?.5*(2*t)*(2*t)*((s+1)*2*t-s):.5*((2*t-2)*(2*t-2)*((s+1)*(2*t-2)+s)+2)}static easeOutBounce(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}static easeInBounce(t){return 1-st.easeOutBounce(1-t)}static easeInOutBounce(t){return t<.5?st.easeInBounce(t*2)*.5:st.easeOutBounce(t*2-1)*.5+.5}}function Ye(f,t,e){const s=Math.max(0,Math.min(1,(e-f)/(t-f)));return st.smoothstep(s)}function os(f,t,e){const{heatZone:s,coolZone:i,rate:n,heatMultiplier:r=1.5,coolMultiplier:o=1.5,middleMultiplier:a=.05,transitionWidth:l=.1}=e,c=Ye(s-l,s+l*.5,f),u=1-Ye(i-l*.5,i+l,f),h=1-c-u;let d=0;return c>0&&(d+=(1-t)*n*r*c),u>0&&(d+=(0-t)*n*o*u),h>0&&(d+=(f-t)*n*a*h),Math.max(0,Math.min(1,t+d))}function di(f,t,e){return(f-t)*e}function gi(f,t,e){const s=f/t;return e*s}function mi(f,t,e,s,i){return e>=s?0:(t-f)*i}function pi(f,t,e,s,i,n=1){if(e>=s)return 0;const r=t-f,o=Math.pow(1-e/s,n);return r*i*o}const re={kernel:{smoothingRadius:28},fluid:{restDensity:1.1,particleMass:1,pressureStiffness:1800,nearPressureStiffness:2.5,viscosity:.18,surfaceTension:0,maxForce:6e3},gas:{interactionRadius:34,pressure:12,diffusion:.08,drag:.04,buoyancy:260,neutralTemperature:.5,turbulence:16},external:{gravity:{x:0,y:820}}},ae=1e-4;function me(f={}){return{kernel:{...re.kernel,...f.kernel||{}},fluid:{...re.fluid,...f.fluid||{}},gas:{...re.gas,...f.gas||{}},external:{...re.external,...f.external||{}}}}const Ht={poly6(f,t){const e=t*t;if(f>=e)return 0;const s=4/(Math.PI*Math.pow(t,8)),i=e-f;return s*i*i*i},spikyPow2(f,t){if(f>=t)return 0;const e=6/(Math.PI*Math.pow(t,4)),s=t-f;return e*s*s},spikyPow3(f,t){if(f>=t)return 0;const e=10/(Math.PI*Math.pow(t,5)),s=t-f;return e*s*s*s},spikyPow2Derivative(f,t){return f===0||f>=t?0:-12/(Math.PI*Math.pow(t,4))*(t-f)},spikyPow3Derivative(f,t){if(f===0||f>=t)return 0;const e=-30/(Math.PI*Math.pow(t,5)),s=t-f;return e*s*s},spikyGradient(f,t){if(f===0||f>=t)return 0;const e=-30/(Math.PI*Math.pow(t,5)),s=(t-f)*(t-f);return e*s},viscosityLaplacian(f,t){return f>=t?0:40/(Math.PI*Math.pow(t,5))*(t-f)}};function rs(f,t={},e){const i=me(t).kernel.smoothingRadius,n=i*i,r=e??ke(f,i),o=f.length,a=new Float32Array(o),l=new Float32Array(o);for(let c=0;c<o;c++)a[c]=Ht.spikyPow2(0,i),l[c]=Ht.spikyPow3(0,i),Ae(c,f,r,n,(u,h,d,g)=>{const m=Math.sqrt(g);a[c]+=Ht.spikyPow2(m,i),l[c]+=Ht.spikyPow3(m,i)});return{densities:a,nearDensities:l}}function as(f,t,e={}){const s=me(e),i=f.length,n=new Float32Array(i),r=new Float32Array(i),{pressureStiffness:o,nearPressureStiffness:a,restDensity:l}=s.fluid;for(let c=0;c<i;c++)n[c]=(f[c]-l)*o,r[c]=t[c]*a;return{pressures:n,nearPressures:r}}function Be(f,t={}){const e=me(t),s=e.kernel.smoothingRadius,i=s*s,n=f.length,r=ke(f,s),{densities:o,nearDensities:a}=rs(f,e,r),{pressures:l,nearPressures:c}=as(o,a,e),u=new Array(n);for(let h=0;h<n;h++)u[h]={x:0,y:0};for(let h=0;h<n;h++){const d=f[h];Math.max(o[h],ae),Ae(h,f,r,i,(g,m,p,v)=>{if(g<=h)return;const _=Math.sqrt(v);if(_<ae||_>=s)return;const w=f[g],b=1/_,S=-m*b,C=-p*b,T=Math.max(o[g],ae),M=Math.max(a[g],ae),R=(l[h]+l[g])*.5,k=(c[h]+c[g])*.5,D=Ht.spikyPow2Derivative(_,s),z=Ht.spikyPow3Derivative(_,s),A=R*D/T,P=k*z/M,E=A+P,F=S*E,K=C*E;u[h].x+=F,u[h].y+=K,u[g].x-=F,u[g].y-=K;const G=Ht.poly6(v,s),nt=e.fluid.viscosity*G,pt=(w.vx-d.vx)*nt,ut=(w.vy-d.vy)*nt;u[h].x+=pt,u[h].y+=ut,u[g].x-=pt,u[g].y-=ut})}return Ne(u,e.fluid.maxForce),{forces:u,densities:o,pressures:l}}function Oe(f,t={}){var e;const s=me(t),i=s.gas.interactionRadius,n=i*i,r=f.length,o=ke(f,i),a=new Array(r);for(let l=0;l<r;l++)a[l]={x:0,y:0};for(let l=0;l<r;l++){const c=f[l],u=Fe(c,s),h=c.temperature??((e=c.custom)==null?void 0:e.temperature)??s.gas.neutralTemperature;Ae(l,f,o,n,(d,g,m,p)=>{var v;if(d<=l||p===0)return;const _=Math.sqrt(p),w=1/_,b=f[d],S=Fe(b,s),C=b.temperature??((v=b.custom)==null?void 0:v.temperature)??s.gas.neutralTemperature,T=s.gas.pressure*(1-_/i),M=g*w*T,R=m*w*T;a[l].x+=M,a[l].y+=R,a[d].x-=M,a[d].y-=R;const k=s.gas.diffusion,D=(b.vx-c.vx)*k,z=(b.vy-c.vy)*k;a[l].x+=D*S,a[l].y+=z*S,a[d].x-=D*u,a[d].y-=z*u;const P=(h-C)*s.gas.buoyancy*.5;a[l].y-=P,a[d].y+=P})}for(let l=0;l<r;l++){const c=f[l],u=s.gas.drag;a[l].x+=-c.vx*u,a[l].y+=-c.vy*u,a[l].x+=(Math.random()-.5)*s.gas.turbulence,a[l].y+=(Math.random()-.5)*s.gas.turbulence}return Ne(a,s.fluid.maxForce),{forces:a}}function ls(f,t,e){const s=Math.min(f.length,t.length),i=new Array(s);for(let n=0;n<s;n++)i[n]={x:st.lerp(f[n].x,t[n].x,e),y:st.lerp(f[n].y,t[n].y,e)};return i}function Fe(f,t){return f.custom&&typeof f.custom.mass=="number"?f.custom.mass:f.mass?f.mass:f.size?f.size*.5+t.fluid.particleMass:t.fluid.particleMass}function Ne(f,t){const e=t*t;for(let s=0;s<f.length;s++){const i=f[s],n=i.x*i.x+i.y*i.y;if(n>e){const r=1/Math.sqrt(n);i.x*=t*r,i.y*=t*r}}}function ke(f,t){const e=t,s=new Map;for(let i=0;i<f.length;i++){const n=f[i],r=Math.floor(n.x/e),o=Math.floor(n.y/e),a=`${r},${o}`;let l=s.get(a);l||(l=[],s.set(a,l)),l.push(i)}return{cellSize:e,buckets:s}}function Ae(f,t,e,s,i){const n=t[f],r=e.cellSize,o=Math.floor(n.x/r),a=Math.floor(n.y/r);for(let l=-1;l<=1;l++)for(let c=-1;c<=1;c++){const u=`${o+l},${a+c}`,h=e.buckets.get(u);if(h)for(let d=0;d<h.length;d++){const g=h[d];if(g===f)continue;const m=t[g],p=n.x-m.x,v=n.y-m.y,_=p*p+v*v;_<s&&i(g,p,v,_)}}}const Dt=class B{static disableAll(){B.enabledClasses=new Set,B.globalLevel=0}static disable(){B.enabled=!1}static enable(){B.enabled=!0}static setLevel(t){B.globalLevel=t}static enableFor(t){B.enabledClasses.add(t)}static disableFor(t){B.enabledClasses.delete(t)}static setOutput(t){B.output=t}constructor(t){this.className=t}static getLogger(t){return B.loggerz[t]||(B.loggerz[t]=new B(t)),B.loggerz[t]}_log(t,e,...s){B.enabled&&(B.globalLevel>=t||B.enabledClasses.has(this.className))&&B.output[e](`[${this.className}]`,...s)}log(...t){this._log(B.INFO,"log",...t)}warn(...t){this._log(B.WARN,"warn",...t)}error(...t){this._log(B.ERROR,"error",...t)}debug(...t){this._log(B.DEBUG,"log",...t)}table(...t){this._log(B.INFO,"table",...t)}groupCollapsed(t){B.enabled&&B.output.groupCollapsed(`[${this.className}] ${t}`)}groupEnd(){B.enabled&&B.output.groupEnd()}time(t){B.enabled&&B.output.time(`[${this.className}] ${t}`)}timeEnd(t){B.enabled&&B.output.timeEnd(`[${this.className}] ${t}`)}clear(){B.output.clear()}};I(Dt,"ERROR",1);I(Dt,"WARN",2);I(Dt,"INFO",3);I(Dt,"DEBUG",4);I(Dt,"globalLevel",Dt.ERROR);I(Dt,"enabledClasses",new Set);I(Dt,"output",console);I(Dt,"enabled",!0);I(Dt,"loggerz",[]);let Rt=Dt;class He{constructor(t={}){this.name=t.name||this.constructor.name,this._logger=this.getLogger(t)}get logger(){return this._logger==null?this.getLogger():this._logger}trace(t="render"){this.logger.log(this.name==null?this.constructor.name:this.name,t,"x",this.x,"y",this.y,"w",this.width,"h",this.height,"opacity",this._opacity,"visible",this._visible,"active",this._active,"debug",this.debug)}getLogger(t){return Rt.getLogger(t.name||this.constructor.name)}}const cs=class jt{static getInstance(){return jt.instance||(jt.instance=new jt),jt.instance}constructor(){this.createTab()}createTab(){this.tab=document.createElement("div"),Object.assign(this.tab.style,{position:"fixed",bottom:"0",left:"0",right:"0",height:"30px",backgroundColor:"#333",color:"#fff",padding:"5px",cursor:"pointer",fontFamily:"monospace",zIndex:"10000",display:"flex",justifyContent:"space-between",alignItems:"center"}),this.tab.innerText="Console";const t=document.createElement("div"),e=(s,i)=>{const n=document.createElement("button");return n.innerText=s,Object.assign(n.style,{marginLeft:"5px",padding:"2px 5px",fontFamily:"monospace",cursor:"pointer"}),n.onclick=i,n};this.paused=!1,this.scrollLock=!0,t.appendChild(e("Clear",()=>this.consoleArea.value="")),t.appendChild(e("Pause",()=>this.paused=!this.paused)),t.appendChild(e("Scroll Lock",()=>this.scrollLock=!this.scrollLock)),this.tab.appendChild(t),document.body.appendChild(this.tab),this.consoleArea=document.createElement("textarea"),Object.assign(this.consoleArea.style,{position:"fixed",bottom:"30px",left:"0",right:"0",height:"200px",display:"none",backgroundColor:"#111",color:"#0f0",fontFamily:"monospace",zIndex:"9999",padding:"10px",resize:"none"}),this.consoleArea.readOnly=!0,document.body.appendChild(this.consoleArea),this.tab.onclick=s=>{s.target===this.tab&&(this.consoleArea.style.display=this.consoleArea.style.display==="none"?"block":"none")}}appendMessage(t,e,...s){if(this.paused)return;const i=`[${t.toUpperCase()}] ${e} ${s.join(" ")}
`;this.consoleArea.value+=i,this.scrollLock&&(this.consoleArea.scrollTop=this.consoleArea.scrollHeight)}log(t,...e){this.appendMessage("log",t,...e)}warn(t,...e){this.appendMessage("warn",t,...e)}error(t,...e){this.appendMessage("error",t,...e)}table(t){const e=JSON.stringify(t,null,2);this.appendMessage("table",e)}groupCollapsed(t){this.appendMessage("group",`Group Start: ${t}`)}groupEnd(){this.appendMessage("group","Group End")}time(t){this[`time_${t}`]=performance.now()}timeEnd(t){const e=performance.now(),s=this[`time_${t}`],i=(e-s).toFixed(2);this.appendMessage("time",`${t}: ${i} ms`)}};I(cs,"instance");const De=class dt{static dropShadow(t,e,s=0,i=0){y.ctx.shadowColor=t,y.ctx.shadowBlur=e,y.ctx.shadowOffsetX=s,y.ctx.shadowOffsetY=i}static clearShadow(){y.ctx.shadowColor="rgba(0, 0, 0, 0)",y.ctx.shadowBlur=0,y.ctx.shadowOffsetX=0,y.ctx.shadowOffsetY=0}static setAlpha(t){y.ctx.globalAlpha=t}static setBlendMode(t){y.ctx.globalCompositeOperation=t}static clipRect(t,e,s,i){y.ctx.beginPath(),y.ctx.rect(t,e,s,i),y.ctx.clip()}static clipCircle(t,e,s){y.ctx.beginPath(),y.shapes.arc(t,e,s,0,Math.PI*2),y.ctx.clip()}static blurRegion(t,e,s,i,n){const r=y.ctx.filter;y.ctx.filter=`blur(${n}px)`;const o=y.ctx.getImageData(t,e,s,i);y.ctx.putImageData(o,t,e),y.ctx.filter=r}static createGlow(t,e,s={}){const i="glow-"+Math.random().toString(36).substr(2,9),r={...{pulseSpeed:0,pulseMin:e*.5,pulseMax:e*1.5,colorShift:0},...s},o={id:i,type:"glow",active:!0,time:0,color:t,blur:e,options:r,update(a){return Object.assign(this,a),this},stop(){return this.active=!1,dt._activeEffects.delete(this.id),this},apply(){if(!this.active)return;let a=this.blur,l=this.color;if(this.options.pulseSpeed>0){const c=Math.sin(this.time*this.options.pulseSpeed)*.5+.5;a=this.options.pulseMin+c*(this.options.pulseMax-this.options.pulseMin)}return this.options.colorShift>0&&(l=l.replace("hue",this.time*this.options.colorShift%360)),y.ctx.shadowColor=l,y.ctx.shadowBlur=a,y.ctx.shadowOffsetX=0,y.ctx.shadowOffsetY=0,this.time+=1/60,this}};return dt._activeEffects.set(i,o),dt._startAnimationLoop(),o}static _startAnimationLoop(){if(dt._animationId!==null)return;const t=()=>{if(dt._activeEffects.forEach(e=>{e.active&&e.apply()}),dt._activeEffects.size===0){cancelAnimationFrame(dt._animationId),dt._animationId=null;return}dt._animationId=requestAnimationFrame(t)};dt._animationId=requestAnimationFrame(t)}static clearAllEffects(){dt._activeEffects.forEach(t=>t.stop()),dt._activeEffects.clear(),y.ctx.shadowColor="rgba(0, 0, 0, 0)",y.ctx.shadowBlur=0,y.ctx.shadowOffsetX=0,y.ctx.shadowOffsetY=0,y.ctx.filter="none",y.ctx.globalAlpha=1,y.ctx.globalCompositeOperation="source-over"}};I(De,"_activeEffects",new Map);I(De,"_animationId",null);let hs=De;class us{static draw(t,e=0,s=0,{width:i,height:n,crop:r=null,anchor:o="topleft",rotation:a=0,scaleX:l=1,scaleY:c=1,flipX:u=!1,flipY:h=!1,alpha:d=1,smoothing:g=!0}={}){const m=y.ctx;if(!m||!t)return;const p=i??(r?r.sw:t.width??t.videoWidth),v=n??(r?r.sh:t.height??t.videoHeight),_={left:0,center:.5,right:1}[o.split("-").pop()]??0,w={top:0,center:.5,bottom:1}[o.split("-")[0]]??0,b=-p*_,S=-v*w;if(m.save(),m.imageSmoothingEnabled=g,m.globalAlpha*=d,m.translate(e,s),a&&m.rotate(a),(u||h)&&m.scale(u?-1:1,h?-1:1),m.scale(l,c),r){const{sx:C,sy:T,sw:M,sh:R}=r;m.drawImage(t,C,T,M,R,b,S,p,v)}else m.drawImage(t,b,S,p,v);m.restore()}static blit(t,e,s,i,n){this.draw(t,e,s,{width:i,height:n})}static createPattern(t,e="repeat"){return y.ctx.createPattern(t,e)}static fillPattern(t,e,s,i,n){const r=y.ctx;r.save(),r.fillStyle=t,r.fillRect(e,s,i,n),r.restore()}static createImageData(t,e){return y.ctx.createImageData(t,e)}static cloneImageData(t){return new ImageData(new Uint8ClampedArray(t.data),t.width,t.height)}static getImageData(t,e,s,i){return y.ctx.getImageData(t,e,s,i)}static putImageData(t,e,s,i=0,n=0,r=t.width,o=t.height){y.ctx.putImageData(t,e,s,i,n,r,o)}static mapPixels(t,e){const s=t.data;for(let i=0;i<s.length;i+=4){const n=i>>2,r=e(s[i],s[i+1],s[i+2],s[i+3],n);r&&([s[i],s[i+1],s[i+2],s[i+3]]=r)}return t}static setPixel(t,e,s,i,n,r,o=255){const a=(s*t.width+e)*4,l=t.data;l[a]=i,l[a+1]=n,l[a+2]=r,l[a+3]=o}static async toBitmap({type:t="image/png",quality:e=.92}={}){const i=await y.ctx.canvas.convertToBlob({type:t,quality:e});return createImageBitmap(i)}static async createBitmap(t){return createImageBitmap(t)}static toImageData(t,e,s){if(t.length!==e*s*4)throw new Error("Invalid RGBA array size for given dimensions");return new ImageData(t,e,s)}static async createImageBitmapFromPixels(t,e,s){const i=this.toImageData(t,e,s);return await createImageBitmap(i)}static createPatternFromImageData(t,e="repeat"){const s=document.createElement("canvas");s.width=t.width,s.height=t.height;const i=s.getContext("2d");return i.putImageData(t,0,0),i.createPattern(s,e)}static createPatternFromPixels(t,e,s,i="repeat"){const n=this.toImageData(t,e,s);return this.createPatternFromImageData(n,i)}}class fs{static path(t,e,s,i=1){const n=y.ctx;n.beginPath();for(const r of t){const[o,...a]=r;o==="M"?n.moveTo(...a):o==="L"?n.lineTo(...a):o==="C"?n.bezierCurveTo(...a):o==="Q"?n.quadraticCurveTo(...a):o==="Z"&&n.closePath()}e&&(n.fillStyle=e,y.colors.fill(e)),s&&(n.strokeStyle=s,n.lineWidth=i,y.colors.stroke())}static line(t,e,s,i,n,r){y.ctx.beginPath(),y.ctx.moveTo(t,e),y.ctx.lineTo(s,i),y.colors.stroke(n,r)}static beginPath(){y.ctx.beginPath()}static closePath(){y.ctx.closePath()}static moveTo(t,e){y.ctx.moveTo(t,e)}static lineTo(t,e){y.ctx.lineTo(t,e)}static bezierCurveTo(t,e,s,i,n,r){y.ctx.bezierCurveTo(t,e,s,i,n,r)}static dashedLine(t,e,s,i,n,r,o){y.ctx.beginPath(),r&&(y.ctx.strokeStyle=r),o!==void 0&&(y.ctx.lineWidth=o),y.ctx.setLineDash(n),y.ctx.moveTo(t,e),y.ctx.lineTo(s,i),y.colors.stroke(),y.ctx.setLineDash([])}static dottedLine(t,e,s,i,n=2,r=5,o){return y.lines.dashedLine(t,e,s,i,[n,r],o,n)}static setLineDash(t){y.ctx.setLineDash(t)}static resetLineDash(){y.ctx.setLineDash([])}static setLineWidth(t){y.ctx.lineWidth=t}static quadraticCurve(t,e,s,i,n,r,o,a){y.ctx.beginPath(),y.ctx.moveTo(t,e),y.ctx.quadraticCurveTo(s,i,n,r),o&&(y.ctx.strokeStyle=o),a!==void 0&&(y.ctx.lineWidth=a),y.colors.stroke()}}class Ge{static pushOpacity(t){const s=this._opacityStack[this._opacityStack.length-1]*t;this._opacityStack.push(s),y.logger.log("NEXT OPACITY WILL BE",s),y.effects.setAlpha(s)}static popOpacity(){if(this._opacityStack.length>1){this._opacityStack.pop();const t=this._opacityStack[this._opacityStack.length-1];y.logger.log("NEXT OPACITY WILL BE",t),y.effects.setAlpha(t)}}static _clone(){this._opacityStack=[...this._opacityStack]}static saveOpacityState(){this._opacityStateBackup=[...this._opacityStack]}static restoreOpacityState(){this._opacityStateBackup&&(this._opacityStack=this._opacityStateBackup,delete this._opacityStateBackup)}}I(Ge,"_opacityStack",[1]);class ds{static rect(t,e,s,i,n){const r=y.ctx.fillStyle;y.colors.fill(n),y.ctx.fillRect(t,e,s,i),y.ctx.fillStyle=r}static outlineRect(t,e,s,i,n,r=1){const o=y.ctx.strokeStyle,a=y.ctx.lineWidth;y.ctx.strokeStyle=n,y.ctx.lineWidth=r,y.ctx.strokeRect(t,e,s,i),y.ctx.strokeStyle=o,y.ctx.lineWidth=a}static roundRect(t,e,s,i,n=0,r,o,a){let l;typeof n=="number"?l=[n,n,n,n]:Array.isArray(n)?l=n.length===4?n:[n[0]||0,n[1]||n[0]||0,n[2]||n[0]||0,n[3]||n[1]||n[0]||0]:l=[0,0,0,0];const[c,u,h,d]=l,g=t+s,m=e+i;y.lines.beginPath(),y.lines.moveTo(t+c,e),y.lines.lineTo(g-u,e),this.arc(g-u,e+u,u,-Math.PI/2,0),y.lines.lineTo(g,m-h),this.arc(g-h,m-h,h,0,Math.PI/2),y.lines.lineTo(t+d,m),this.arc(t+d,m-d,d,Math.PI/2,Math.PI),y.lines.lineTo(t,e+c),this.arc(t+c,e+c,c,Math.PI,-Math.PI/2),y.lines.closePath(),r&&(y.fillStyle=r,y.colors.fill(r)),o&&y.colors.stroke(o,a)}static fillRoundRect(t,e,s,i,n=0,r){this.roundRect(t,e,s,i,n,r,null)}static strokeRoundRect(t,e,s,i,n=0,r,o){this.roundRect(t,e,s,i,n,null,r,o)}static fillCircle(t,e,s,i){y.logger.log("PainterShapes.fillCircle",t,e,s,i),y.lines.beginPath(),this.arc(t,e,s,0,Math.PI*2),y.colors.fill(i)}static arc(t,e,s,i,n,r){y.ctx.arc(t,e,s,i,n,r)}static strokeCircle(t,e,s,i,n){y.lines.beginPath(),this.arc(t,e,s,0,Math.PI*2),y.colors.stroke(i,n)}static fillEllipse(t,e,s,i,n=0,r){y.lines.beginPath(),this.ellipse(t,e,s,i,n,0,Math.PI*2),r&&(y.fillStyle=r),y.colors.fill(r)}static strokeEllipse(t,e,s,i,n=0,r,o){y.lines.beginPath(),this.ellipse(t,e,s,i,n,0,Math.PI*2),r&&(y.strokeStyle=r),o!==void 0&&(y.lineWidth=o),y.colors.stroke(r,o)}static ellipse(t,e,s,i,n,r,o,a){y.ctx.ellipse(t,e,s,i,n,r,o,a)}static polygon(t,e,s,i,n){if(t.length<2)return;const r=y.ctx;r.beginPath(),r.moveTo(t[0].x,t[0].y);for(let o=1;o<t.length;o++)r.lineTo(t[o].x,t[o].y);r.closePath(),e&&y.colors.fill(e),s&&(n&&(r.lineJoin=n),y.colors.stroke(s,i))}}class gs{static font(){return y.ctx.font}static setFont(t){y.ctx.font=t}static setTextAlign(t){y.ctx.textAlign=t}static setTextBaseline(t){y.ctx.textBaseline=t}static fillText(t,e,s,i,n){i&&(y.ctx.fillStyle=i),n&&(y.ctx.font=n),y.ctx.fillText(t,e,s)}static strokeText(t,e,s,i,n,r){i&&(y.ctx.strokeStyle=i),n!==void 0&&(y.ctx.lineWidth=n),r&&(y.ctx.font=r),y.ctx.strokeText(t,e,s)}static measureTextDimensions(t,e,s="start",i="alphabetic"){e&&(y.ctx.font=e);const n=y.ctx.measureText(t),r=n.width,o=n.actualBoundingBoxAscent+n.actualBoundingBoxDescent;let a=0;return i==="middle"&&(a=-1.5),{width:r,height:o,verticalAdjustment:a}}static measureTextWidth(t,e){return e&&(y.ctx.font=e),y.ctx.measureText(t).width}static outlinedText(t,e,s,i,n,r,o){o&&(y.ctx.font=o),y.ctx.strokeStyle=n,y.ctx.lineWidth=r,y.ctx.strokeText(t,e,s),y.ctx.fillStyle=i,y.ctx.fillText(t,e,s)}static wrappedText(t,e,s,i,n,r,o){r&&(y.ctx.fillStyle=r),o&&(y.ctx.font=o);const a=t.split(" ");let l="",c="",u=1;for(let h=0;h<a.length;h++)c=l+a[h]+" ",y.ctx.measureText(c).width>i&&h>0?(y.ctx.fillText(l,e,s),l=a[h]+" ",s+=n,u++):l=c;return y.ctx.fillText(l,e,s),u*n}static textOnPath(t,e,s,i,n=!1){if(e.length<2)return;s&&(y.ctx.fillStyle=s),i&&(y.ctx.font=i);const r=t.split(""),o=r.map(h=>y.ctx.measureText(h).width);n&&(r.reverse(),o.reverse(),e.reverse());let a=0;for(let h=1;h<e.length;h++){const d=e[h].x-e[h-1].x,g=e[h].y-e[h-1].y;a+=Math.sqrt(d*d+g*g)}const l=o.reduce((h,d)=>h+d,0);let c=(a-l)/2;c<0&&(c=0);let u=c;for(let h=0;h<r.length;h++){const d=o[h],{x:g,y:m,angle:p}=getPositionOnPath(e,u);y.ctx.save(),y.ctx.translate(g,m),y.ctx.rotate(p),y.ctx.fillText(r[h],0,0),y.ctx.restore(),u+=d}}static getPositionOnPath(t,e){let s=0;for(let o=1;o<t.length;o++){const a=t[o-1],l=t[o],c=l.x-a.x,u=l.y-a.y,h=Math.sqrt(c*c+u*u);if(s+h>=e){const d=(e-s)/h,g=a.x+c*d,m=a.y+u*d,p=Math.atan2(u,c);return{x:g,y:m,angle:p}}s+=h}const i=t[t.length-1],n=t[t.length-2],r=Math.atan2(i.y-n.y,i.x-n.x);return{x:i.x,y:i.y,angle:r}}}const It=class gt{static get colors(){return J(this,zt,Xt).call(this,"colors",x(this,Jt)),x(this,Jt)}static get effects(){return J(this,zt,Xt).call(this,"effects",x(this,Qt)),x(this,Qt)}static get img(){return J(this,zt,Xt).call(this,"img",x(this,te)),x(this,te)}static get lines(){return J(this,zt,Xt).call(this,"lines",x(this,ee)),x(this,ee)}static get opacity(){return J(this,zt,Xt).call(this,"opacity",x(this,se)),x(this,se)}static get shapes(){return J(this,zt,Xt).call(this,"shapes",x(this,ie)),x(this,ie)}static get text(){return J(this,zt,Xt).call(this,"text",x(this,ne)),x(this,ne)}static set ctx(t){this._ctx=t}static get ctx(){if(!this._ctx)throw new Error("Cannot access Painter.ctx before initialization!");return this._ctx}static init(t){this._ctx=t,this.saveStack=[],N(this,Jt,ms),N(this,Qt,hs),N(this,te,us),N(this,ee,fs),N(this,se,Ge),N(this,ie,ds),N(this,ne,gs),gt.logger=Rt.getLogger("Painter"),gt.saveStack=[]}static setContext(t){this._ctx=t}static save(){const e=(new Error().stack.split(`
`)[2]||"").match(/at\s+(\w+)\.(\w+)/),s=e?`${e[1]}.${e[2]}`:"unknown";this.saveStack.push(s),this.logger.log(`Painter.save() by: ${s}`),this.ctx.save(),gt.opacity.saveOpacityState()}static restore(){if(this.saveStack.length===0){console.error("PAINTER ERROR: restore() without matching save()!");return}const t=this.saveStack.pop();this.logger.log(`Painter.restore() balancing save from: ${t}`),this.ctx.restore(),gt.opacity.restoreOpacityState()}static translateTo(t,e){(isNaN(t)||t===void 0)&&(t=0),(isNaN(e)||e===void 0)&&(e=0),this.logger.log("moveTo",t,e),this.ctx.translate(t,e)}static resetPosition(){this.logger.log("resetPosition");const t=this.ctx.getTransform();this.ctx.setTransform(t.a,t.b,t.c,t.d,0,0)}static withPosition(t,e,s){this.logger.log("withPosition",t,e),this.save(),this.translateTo(t,e),s(),this.restore()}static clear(t=0,e=0,s=gt.ctx.canvas.width,i=gt.ctx.canvas.height){gt.ctx.clearRect(t,e,s,i)}static translate(t,e){gt.ctx.translate(t,e)}static rotate(t){gt.logger.log("Painter.rotate",t),gt.ctx.rotate(t)}static scale(t,e){gt.logger.log("Painter.scale",t,e),gt.ctx.scale(t,e)}static useCtx(t,e={}){const s=this.ctx,{saveState:i=!1}=e;i&&this.save(),s.beginPath(),t(s),s.beginPath(),i&&this.restore()}};Jt=new WeakMap;Qt=new WeakMap;te=new WeakMap;ee=new WeakMap;se=new WeakMap;ie=new WeakMap;ne=new WeakMap;zt=new WeakSet;Xt=function(f,t){if(!t)throw new Error(`Painter.${f} is not initialized. Call Painter.init(ctx) first.`)};O(It,zt);O(It,Jt,null);O(It,Qt,null);O(It,te,null);O(It,ee,null);O(It,se,null);O(It,ie,null);O(It,ne,null);I(It,"logger");let y=It;class ms{static fill(t){y.logger.log("PainterColors.fill - before:",y.ctx.fillStyle,"setting to:",t),y.ctx.fillStyle,y.ctx.fillStyle=t,y.ctx.fill(),y.logger.log("PainterColors.fill - after:",y.ctx.fillStyle)}static strokeOptions(t){t.color&&(y.ctx.strokeStyle=t.color),t.lineWidth!==void 0&&(y.ctx.lineWidth=t.lineWidth),t.lineCap&&(y.ctx.lineCap=t.lineCap),t.lineJoin&&(y.ctx.lineJoin=t.lineJoin),t.strokeStyle&&(y.ctx.strokeStyle=t.strokeStyle)}static stroke(t,e){t&&(y.ctx.strokeStyle=t),e!==void 0&&(y.ctx.lineWidth=e),y.ctx.stroke()}static setFillColor(t){y.ctx.fillStyle=t}static setStrokeColor(t){y.ctx.strokeStyle=t}static randomColorRGB(){const t=Math.floor(Math.random()*360),e=70+Math.floor(Math.random()*30),s=50+Math.floor(Math.random()*20);return y.colors.hslToRgb(t,e,s)}static randomColorRGBA(t=255){const[e,s,i]=this.randomColorRGB();return[e,s,i,t]}static randomColorHSL(){return`hsl(${Math.random()*360}, 100%, 50%)`}static randomColorHSL_RGBA(t=255){const e=Math.random()*360,s=60+Math.random()*40,i=40+Math.random()*40,[n,r,o]=y.colors.hslToRgb(e,s,i);return[n,r,o,t]}static randomColorHEX(){return"#"+(Math.random()*1048575*1e6).toString(16).slice(0,6)}static parseColorString(t){if(t=t.trim().toLowerCase(),t.startsWith("hsl")){const e=t.replace(/hsla?\(|\)/g,""),[s,i,n]=e.split(",").map(l=>l.trim()),r=parseFloat(s),o=parseFloat(i)/100,a=parseFloat(n)/100;return y.colors.hslToRgb(r,o,a)}if(t.startsWith("#"))return hexToRgb(t);if(t.startsWith("rgb")){const e=t.replace(/rgba?\(|\)/g,""),[s,i,n]=e.split(",").map(r=>parseInt(r.trim()));return[s,i,n]}return[0,0,0]}static rgbArrayToCSS([t,e,s]){return`rgb(${Math.round(t)}, ${Math.round(e)}, ${Math.round(s)})`}static hslToRgb(t,e,s){e/=100,s/=100;const i=o=>(o+t/30)%12,n=e*Math.min(s,1-s),r=o=>s-n*Math.max(-1,Math.min(i(o)-3,Math.min(9-i(o),1)));return[Math.round(r(0)*255),Math.round(r(8)*255),Math.round(r(4)*255)]}static rgbToHsl(t,e,s){t/=255,e/=255,s/=255;const i=Math.max(t,e,s),n=Math.min(t,e,s),r=i-n;let o=0,a=0,l=(i+n)/2;if(r!==0)switch(a=r/(1-Math.abs(2*l-1)),i){case t:o=60*(((e-s)/r+6)%6);break;case e:o=60*((s-t)/r+2);break;case s:o=60*((t-e)/r+4);break}return[o%360,a,l]}static hexToRgb(t){const e=t.replace("#",""),s=parseInt(e.substring(0,2),16),i=parseInt(e.substring(2,4),16),n=parseInt(e.substring(4,6),16);return[s,i,n]}static linearGradient(t,e,s,i,n){const r=y.ctx.createLinearGradient(t,e,s,i);for(const o of n)r.addColorStop(o.offset,o.color);return r}static radialGradient(t,e,s,i,n,r,o){const a=y.ctx.createRadialGradient(t,e,s,i,n,r);for(const l of o)a.addColorStop(l.offset,l.color);return a}static verticalGradient(t,e,s,i,n){return y.colors.linearGradient(t,e,t,e+i,n)}static horizontalGradient(t,e,s,i,n){return y.colors.linearGradient(t,e,t+s,e,n)}static conicGradient(t,e,s,i){if(typeof y.ctx.createConicGradient=="function"){const n=y.ctx.createConicGradient(s,t,e);for(const r of i)n.addColorStop(r.offset,r.color);return n}return null}static rgba(t,e,s,i=1){return`rgba(${Math.round(t)}, ${Math.round(e)}, ${Math.round(s)}, ${i})`}static hsl(t,e,s){return`hsl(${t}, ${e}%, ${s}%)`}static hsla(t,e,s,i){return`hsla(${t}, ${e}%, ${s}%, ${i})`}}class ps extends He{constructor(t={}){super(t),this._x=typeof t.x=="number"?t.x:0,this._y=typeof t.y=="number"?t.y:0,this._width=typeof t.width=="number"?t.width:0,this._height=typeof t.height=="number"?t.height:0,this.logger.log("Euclidian",this._x,this._y,this._width,this._height)}get x(){return this._x}set x(t){this.validateProp(t,"x"),this._x=t}get y(){return this._y}set y(t){this.validateProp(t,"y"),this._y=t}get width(){return this._width}set width(t){this.validateProp(t,"width"),this._width=Math.max(0,t)}get height(){return this._height}set height(t){this.validateProp(t,"height"),this._height=Math.max(0,t)}get debug(){return this._debug}set debug(t){this.validateProp(t,"debug"),this._debug=!!t}get debugColor(){return this._debugColor}set debugColor(t){this.validateProp(t,"debugColor"),this._debugColor=t}validateProp(t,e){if(t==null)throw new Error("Invalid property value: "+e+" "+t)}}class ys extends ps{constructor(t={}){super(t),this._minX=t.minX,this._maxX=t.maxX,this._minY=t.minY,this._maxY=t.maxY,this._boundsDirty=!0,this._cachedBounds=null,this.crisp=t.crisp??!0,this.logger.log("Geometry2d",this.x,this.y,this.width,this.height)}update(){this.trace("Geometry2d.update"),this.applyConstraints(),this.getBounds()}get minX(){return this._minX}set minX(t){this._minX=t}get maxX(){return this._maxX}set maxX(t){this._maxX=t}get minY(){return this._minY}set minY(t){this._minY=t}get maxY(){return this._maxY}set maxY(t){this._maxY=t}get boundsDirty(){return this._boundsDirty}applyConstraints(){this._minX!==void 0&&(this.x=Math.max(this.x,this._minX)),this._maxX!==void 0&&(this.x=Math.min(this.x,this._maxX)),this._minY!==void 0&&(this.y=Math.max(this.y,this._minY)),this._maxY!==void 0&&(this.y=Math.min(this.y,this._maxY)),this.crisp&&(this.x=Math.round(this.x),this.y=Math.round(this.y),this.width=Math.round(this.width),this.height=Math.round(this.height))}getBounds(){return(this._boundsDirty||!this._cachedBounds)&&(this._cachedBounds=this.calculateBounds(),this._boundsDirty=!1),this._cachedBounds}calculateBounds(){return{width:this.width,height:this.height,x:this.x,y:this.y}}getLocalPosition(){let t=0,e=0;return this.parent&&(t=this.parent.x,e=this.parent.y),{x:this.x-t-this.width/2,y:this.y-e-this.height/2}}markBoundsDirty(){this._boundsDirty=!0}validateProp(t,e){super.validateProp(t,e);const s=this[e];t!==s&&this.markBoundsDirty()}setTopLeft(t,e){return this.x=t+this.width/2,this.y=e+this.height/2,this}setCenter(t,e){return this.x=t,this.y=e,this}}class vs extends ys{constructor(t={}){super(t),this._debug=!!t.debug,this._debugColor=typeof t.debugColor=="string"?t.debugColor:"#0f0",this.logger.log("Traceable",this.x,this.y,this.width,this.height)}drawDebug(){if(!this._debug)return;const t=this.getDebugBounds();this.logger.log(this.constructor.name,"drawDebug",t.x,t.y,t.width,t.height),y.shapes.outlineRect(t.x,t.y,t.width,t.height,this._debugColor,2)}getDebugBounds(){return{width:this.width,height:this.height,x:-this.width/2,y:-this.height/2}}trace(t="render"){this.logger.log(this.name==null?this.constructor.name:this.name,t,"x",this.x,"y",this.y,"w",this.width,"h",this.height,"opacity",this._opacity,"visible",this._visible,"active",this._active,"debug",this.debug)}}class _s extends vs{constructor(t={}){super(t),this._visible=t.visible!==!1,this._opacity=typeof t.opacity=="number"?t.opacity:1,this._active=t.active!==!1,this.zIndex=t.zIndex??0,this._shadowColor=t.shadowColor??void 0,this._shadowBlur=t.shadowBlur??0,this._shadowOffsetX=t.shadowOffsetX??0,this._shadowOffsetY=t.shadowOffsetY??0,this._cacheRendering=t.cacheRendering??!1,this._cacheCanvas=null,this._cacheDirty=!0,this._cachePadding=t.cachePadding??2,this._tick=0,this.logger.log("Renderable",this.x,this.y,this.width,this.height)}render(){if(!(!this._visible||this._opacity<=0)){if(y.save(),y.effects.setBlendMode(this._blendMode),this.crisp?y.translateTo(Math.round(this.x),Math.round(this.y)):y.translateTo(this.x,this.y),this.applyShadow(y.ctx),!this._cacheRendering||this.constructor.name==="Renderable")y.opacity.pushOpacity(this._opacity),this.draw(),y.opacity.popOpacity();else{const t=typeof this.width=="number"?this.width:0,e=typeof this.height=="number"?this.height:0,s=this._cachePadding*2,i=Math.ceil(t+s)||1,n=Math.ceil(e+s)||1;(!this._cacheCanvas||this._cacheCanvas.width!==i||this._cacheCanvas.height!==n)&&(this._cacheCanvas=document.createElement("canvas"),this._cacheCanvas.width=i,this._cacheCanvas.height=n,this._cacheDirty=!0),this._cacheDirty&&(this._renderToCache(i,n),this._cacheDirty=!1),y.opacity.pushOpacity(this._opacity);const r=this.rotation??0,o=this.scaleX??1,a=this.scaleY??1;y.img.draw(this._cacheCanvas,0,0,{width:i,height:n,rotation:r,scaleX:o,scaleY:a,anchor:"center"}),y.opacity.popOpacity()}y.restore()}}_renderToCache(t,e){const s=this._cacheCanvas.getContext("2d");s.clearRect(0,0,t,e);const i=y.ctx;y.ctx=s,this._isCaching=!0,s.save(),s.translate(t/2,e/2),this.draw(),s.restore(),this._isCaching=!1,y.ctx=i}invalidateCache(){this._cacheDirty=!0}draw(){this.drawDebug()}update(t){this.trace("Renderable.update"),this._tick+=t,super.update(t)}applyShadow(t){this._shadowColor&&(t.shadowColor=this._shadowColor,t.shadowBlur=this._shadowBlur,t.shadowOffsetX=this._shadowOffsetX,t.shadowOffsetY=this._shadowOffsetY)}get visible(){return this._visible}set visible(t){this._visible=!!t}get width(){return super.width}set width(t){super.width=t,this.invalidateCache()}get height(){return super.height}set height(t){super.height=t,this.invalidateCache()}get active(){return this._active}set active(t){this._active=!!t}get opacity(){return this._opacity}set opacity(t){this._opacity=Math.min(1,Math.max(0,typeof t=="number"?t:1))}get shadowColor(){return this._shadowColor}set shadowColor(t){this._shadowColor=t,this.invalidateCache()}get shadowBlur(){return this._shadowBlur}set shadowBlur(t){this._shadowBlur=t,this.invalidateCache()}get shadowOffsetX(){return this._shadowOffsetX}set shadowOffsetX(t){this._shadowOffsetX=t,this.invalidateCache()}get shadowOffsetY(){return this._shadowOffsetY}set shadowOffsetY(t){this._shadowOffsetY=t,this.invalidateCache()}get tick(){return this._tick}get cacheRendering(){return this._cacheRendering}set cacheRendering(t){this._cacheRendering=!!t,t&&this.invalidateCache()}}const Ue=class xe{constructor(t){this._owner=t}get owner(){return this._owner}x(t){return this._owner._x=t,this._owner.markBoundsDirty(),this}y(t){return this._owner._y=t,this._owner.markBoundsDirty(),this}position(t,e){return this._owner._x=t,this._owner._y=e,this._owner.markBoundsDirty(),this}translateBy(t,e){return this._owner._x+=t,this._owner._y+=e,this._owner.markBoundsDirty(),this}width(t){var e,s;return this._owner._width=Math.max(0,t),this._owner.markBoundsDirty(),(s=(e=this._owner).invalidateCache)==null||s.call(e),this}height(t){var e,s;return this._owner._height=Math.max(0,t),this._owner.markBoundsDirty(),(s=(e=this._owner).invalidateCache)==null||s.call(e),this}size(t,e){var s,i;return this._owner._width=Math.max(0,t),this._owner._height=Math.max(0,e),this._owner.markBoundsDirty(),(i=(s=this._owner).invalidateCache)==null||i.call(s),this}rotation(t){return this._owner._rotation=t*Math.PI/180,this._owner.markBoundsDirty(),this}rotationRad(t){return this._owner._rotation=t,this._owner.markBoundsDirty(),this}rotateBy(t){return this._owner._rotation+=t*Math.PI/180,this._owner.markBoundsDirty(),this}scaleX(t){return this._owner._scaleX=t,this._owner.markBoundsDirty(),this}scaleY(t){return this._owner._scaleY=t,this._owner.markBoundsDirty(),this}scale(t){return this._owner._scaleX=t,this._owner._scaleY=t,this._owner.markBoundsDirty(),this}scaleBy(t){return this._owner._scaleX*=t,this._owner._scaleY*=t,this._owner.markBoundsDirty(),this}set(t){var e,s;let i=!1;return t.x!==void 0&&(this._owner._x=t.x),t.y!==void 0&&(this._owner._y=t.y),t.width!==void 0&&(this._owner._width=Math.max(0,t.width),i=!0),t.height!==void 0&&(this._owner._height=Math.max(0,t.height),i=!0),t.rotation!==void 0&&(this._owner._rotation=t.rotation*Math.PI/180),t.scaleX!==void 0&&(this._owner._scaleX=t.scaleX),t.scaleY!==void 0&&(this._owner._scaleY=t.scaleY),this._owner.markBoundsDirty(),i&&((s=(e=this._owner).invalidateCache)==null||s.call(e)),this}reset(){return this._owner._rotation=0,this._owner._scaleX=1,this._owner._scaleY=1,this._owner.markBoundsDirty(),this}resetAll(){var t,e;return this._owner._x=0,this._owner._y=0,this._owner._width=0,this._owner._height=0,this._owner._rotation=0,this._owner._scaleX=1,this._owner._scaleY=1,this._owner.markBoundsDirty(),(e=(t=this._owner).invalidateCache)==null||e.call(t),this}toObject(){return{x:this._owner._x,y:this._owner._y,width:this._owner._width,height:this._owner._height,rotation:this._owner._rotation*180/Math.PI,scaleX:this._owner._scaleX,scaleY:this._owner._scaleY}}copyFrom(t){const e=t instanceof xe?t.toObject():t;return this.set(e)}static handleDirectSet(t,e){if(xe.strictMode)throw new Error(`Direct property assignment "${t} = ${e}" is disabled. Use shape.transform.${t}(${e}) instead. Set Transform.strictMode = false to allow direct assignment.`);console.warn(`[Deprecation] Direct assignment "${t} = ${e}" is deprecated. Use shape.transform.${t}(${e}) instead.`)}};I(Ue,"strictMode",!1);let xs=Ue;class ue extends _s{constructor(t={}){super(t),this._rotation=t.rotation*Math.PI/180,this._scaleX=t.scaleX??1,this._scaleY=t.scaleY??1,this.transform=new xs(this),this.logger.log("Transformable",this.x,this.y,this.width,this.height)}draw(){this.applyTransforms();const t=y.ctx;t.beginPath(),t.fill(),this.drawDebug()}applyTransforms(){this._isCaching||(y.rotate(this._rotation),y.scale(this._scaleX,this._scaleY))}get rotation(){return this._rotation}set rotation(t){this._rotation=t*Math.PI/180,this.markBoundsDirty()}get scaleX(){return this._scaleX}set scaleX(t){this._scaleX=t,this.markBoundsDirty()}get scaleY(){return this._scaleY}set scaleY(t){this._scaleY=t,this.markBoundsDirty()}calculateBounds(){const t=this.width/2,e=this.height/2,s=[{x:-t,y:-e},{x:t,y:-e},{x:t,y:e},{x:-t,y:e}],i=Math.cos(this._rotation),n=Math.sin(this._rotation),r=s.map(({x:d,y:g})=>{d*=this._scaleX,g*=this._scaleY;const m=d*i-g*n,p=d*n+g*i;return{x:m+this.x,y:p+this.y}}),o=r.map(d=>d.x),a=r.map(d=>d.y),l=Math.min(...o),c=Math.max(...o),u=Math.min(...a),h=Math.max(...a);return{x:(l+c)/2,y:(u+h)/2,width:c-l,height:h-u}}}class ht extends ue{constructor(t={}){super(t),this._color=t.color??null,this._stroke=t.stroke??null,this._lineWidth=t.lineWidth??1,this._lineJoin=t.lineJoin??"miter",this._lineCap=t.lineCap??"butt",this._miterLimit=t.miterLimit??10,this.logger.log("Shape",this.x,this.y,this.width,this.height)}get color(){return this._color}set color(t){this._color=t,this.invalidateCache()}get stroke(){return this._stroke}set stroke(t){this._stroke=t,this.invalidateCache()}get lineWidth(){return this._lineWidth}set lineWidth(t){this._lineWidth=Math.max(0,t),this.invalidateCache()}get lineJoin(){return this._lineJoin}set lineJoin(t){this._lineJoin=t,this.invalidateCache()}get lineCap(){return this._lineCap}set lineCap(t){this._lineCap=t,this.invalidateCache()}get miterLimit(){return this._miterLimit}set miterLimit(t){this._miterLimit=t,this.invalidateCache()}}class bs extends ue{constructor(t={}){super(t),this._collection=new Te({sortByZIndex:t.sortByZIndex||!0}),this._collection._owner=this,this._childrenVersion=0,this._cachedBounds=null,t.width=Math.max(0,t.width||0),t.height=Math.max(0,t.height||0),this.userDefinedWidth=t.width,this.userDefinedHeight=t.height,this.userDefinedDimensions=t.width!==void 0&&t.height!==void 0&&(t.width>0||t.height>0)}add(t){if(t==null||t==null)throw new Error("Object is null or undefined");if(!(t instanceof ue))throw new TypeError("Group can only add Transformable instances");return t.parent=this,this._collection.add(t),this._childrenVersion++,this.markBoundsDirty(),this.invalidateCache(),t}remove(t){const e=this._collection.remove(t);return e&&(t.parent=null,this._childrenVersion++,this.markBoundsDirty(),this.invalidateCache()),e}clear(){this._collection.clear(),this._childrenVersion++,this.markBoundsDirty(),this.invalidateCache()}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}draw(){super.draw(),this.logger.log("Group.draw children:",this.children.length),this._renderChildren()}_renderChildren(){const t=this._collection.getSortedChildren();for(let e=0;e<t.length;e++){const s=t[e];s.visible&&(y.save(),s.render(),y.restore())}}update(t){this.logger.groupCollapsed("Group.update");const e=this._collection.getSortedChildren();for(let s=0;s<e.length;s++){const i=e[s];i.active&&typeof i.update=="function"&&i.update(t)}super.update(t),this.logger.groupEnd()}get children(){var t;return((t=this._collection)==null?void 0:t.children)||[]}get width(){return this.userDefinedDimensions?this._width:this.getBounds().width}set width(t){const e=Math.max(0,t);this._width=e,this.userDefinedWidth=e,this.userDefinedDimensions=(this.userDefinedWidth>0||this.userDefinedHeight>0)&&this.userDefinedWidth!==void 0&&this.userDefinedHeight!==void 0,this.markBoundsDirty()}get height(){return this.userDefinedDimensions?this._height:this.getBounds().height}set height(t){const e=Math.max(0,t);this._height=e,this.userDefinedHeight=e,this.userDefinedDimensions=(this.userDefinedWidth>0||this.userDefinedHeight>0)&&this.userDefinedWidth!==void 0&&this.userDefinedHeight!==void 0,this.markBoundsDirty()}calculateBounds(){var t;if(this.userDefinedDimensions)return{x:this.x,y:this.y,width:this._width,height:this._height};if(!((t=this.children)!=null&&t.length))return{x:this.x,y:this.y,width:0,height:0};let e=1/0,s=1/0,i=-1/0,n=-1/0;for(const a of this.children){const l=a.x,c=a.y,u=a.width,h=a.height,d=l-u/2,g=l+u/2,m=c-h/2,p=c+h/2;e=Math.min(e,d),i=Math.max(i,g),s=Math.min(s,m),n=Math.max(n,p)}const r=i-e,o=n-s;return{x:this.x,y:this.y,width:r,height:o}}getDebugBounds(){const t=this.calculateBounds();return{width:t.width,height:t.height,x:-t.width/2,y:-t.height/2}}forEachTransform(t){return this.children.forEach((e,s)=>{e.transform&&t(e.transform,e,s)}),this}translateChildren(t,e){return this.forEachTransform(s=>s.translateBy(t,e))}scaleChildren(t){return this.forEachTransform(e=>e.scaleBy(t))}rotateChildren(t){return this.forEachTransform(e=>e.rotateBy(t))}resetChildTransforms(){return this.forEachTransform(t=>t.reset())}}class yi extends ht{constructor(t,e,s,i={}){super(i),this.radius=t,this.startAngle=e,this.endAngle=s}draw(){super.draw(),y.lines.beginPath(),y.shapes.arc(0,0,this.radius,this.startAngle,this.endAngle,!1),this.stroke&&y.colors.stroke(this.stroke,this.lineWidth)}getBounds(){const t=this.radius;return{x:this.x,y:this.y,width:t*2,height:t*2}}}class vi extends ht{constructor(t,e={}){super(e),this._radius=t,this.width=t*2,this.height=t*2}draw(){super.draw(),this.color&&y.shapes.fillCircle(0,0,this._radius,this.color),this.stroke&&y.shapes.strokeCircle(0,0,this._radius,this.stroke,this.lineWidth)}calculateBounds(){const t=this._radius*2;return this.trace("Circle.calculateBounds:"+t),{x:this.x,y:this.y,width:t,height:t}}get radius(){return this._radius}set radius(t){this.validateProp(t,"radius"),t!=this._radius&&(this._radius=t,this.width=t*2,this.height=t*2,this._boundsDirty=!0,this.calculateBounds())}}class _i extends ht{constructor(t=40,e={}){super(e),this.size=t,this.width=t*2,this.height=t*2}draw(){super.draw();const t=this.size,e=y.ctx,s=[{x:-t*.5,y:0,r:t*.4},{x:-t*.2,y:-t*.3,r:t*.35},{x:t*.2,y:-t*.35,r:t*.4},{x:t*.5,y:0,r:t*.35},{x:0,y:t*.15,r:t*.5}];if(this.color){e.fillStyle=this.color;for(const i of s)e.beginPath(),e.arc(i.x,i.y,i.r,0,Math.PI*2),e.fill()}if(this.stroke){e.strokeStyle=this.stroke,e.lineWidth=this.lineWidth;for(const i of s)e.beginPath(),e.arc(i.x,i.y,i.r,0,Math.PI*2),e.stroke()}}getBounds(){const t=this.size*2;return{x:this.x,y:this.y,width:t,height:t}}}class qe extends ht{constructor(t={}){super(t)}draw(){super.draw(),this.drawRect()}drawRect(){const t=-this.width/2,e=-this.height/2;this.color&&y.shapes.rect(t,e,this.width,this.height,this.color),this.stroke&&y.shapes.outlineRect(t,e,this.width,this.height,this.stroke,this.lineWidth)}}class xi extends qe{constructor(t,e={}){super(e),this.width=t,this.height=t}}class bi extends ht{constructor(t=50,e={}){super(e),this.size=t}draw(){super.draw();const t=this.size/2,e=[{x:0,y:-t},{x:t,y:t},{x:-t,y:t}];y.shapes.polygon(e,this.color,this.stroke,this.lineWidth)}}class wi extends ht{constructor(t=50,e={}){super(e),this._leg=t,this._updateDimensions()}get leg(){return this._leg}set leg(t){this._leg=t,this._updateDimensions(),this.invalidateCache()}get hypotenuse(){return this._leg*Math.SQRT2}_updateDimensions(){this._width=this._leg,this._height=this._leg}getVertices(){const t=this._leg,e=t/3,s=t/3;return[{x:-e,y:-s},{x:t-e,y:-s},{x:-e,y:t-s}]}draw(){super.draw();const t=this.getVertices();y.shapes.polygon(t,this.color,this.stroke,this.lineWidth,this.lineJoin)}calculateBounds(){return{x:this.x,y:this.y,width:this._width,height:this._height}}}class Mi extends ht{constructor(t={}){super(t),this._pgWidth=t.width??100,this._pgHeight=t.height??50,this._slant=t.slant??this._pgHeight,this._flipX=t.flipX??!1,this._updateDimensions()}get pgWidth(){return this._pgWidth}set pgWidth(t){this._pgWidth=t,this._updateDimensions(),this.invalidateCache()}get pgHeight(){return this._pgHeight}set pgHeight(t){this._pgHeight=t,this._updateDimensions(),this.invalidateCache()}get slant(){return this._slant}set slant(t){this._slant=t,this._updateDimensions(),this.invalidateCache()}get flipX(){return this._flipX}set flipX(t){this._flipX=t,this.invalidateCache()}_updateDimensions(){this._width=this._pgWidth+Math.abs(this._slant),this._height=this._pgHeight}getVertices(){const t=this._pgWidth,e=this._pgHeight;let s=this._slant;this._flipX&&(s=-s);const n=-(t+Math.abs(s))/2+(s<0?-s:0);return[{x:n,y:e/2},{x:n+t,y:e/2},{x:n+t+s,y:-e/2},{x:n+s,y:-e/2}]}draw(){super.draw();const t=this.getVertices();y.shapes.polygon(t,this.color,this.stroke,this.lineWidth,this.lineJoin)}calculateBounds(){return{x:this.x,y:this.y,width:this._width,height:this._height}}}class Ze{constructor(t,e){if(this.width=t,this.height=e,this.canvas=document.createElement("canvas"),this.canvas.width=t,this.canvas.height=e,this.gl=this.canvas.getContext("webgl",{alpha:!0,premultipliedAlpha:!0,antialias:!0,preserveDrawingBuffer:!0}),!this.gl){console.warn("WebGL not available, falling back to Canvas 2D"),this.available=!1;return}this.available=!0;const s=this.gl;s.enable(s.BLEND),s.blendFunc(s.ONE,s.ONE_MINUS_SRC_ALPHA),s.viewport(0,0,t,e),this.programs=new Map,this.currentProgram=null,this.uniformLocations=new Map,this._needsAttributeRebind=!1,this._createQuad()}isAvailable(){return this.available}resize(t,e){this.width=t,this.height=e,this.canvas.width=t,this.canvas.height=e,this.gl&&(this.gl.viewport(0,0,t,e),this._needsAttributeRebind=!0)}_createQuad(){const t=this.gl,e=new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),s=new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]);this.positionBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),this.uvBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.uvBuffer),t.bufferData(t.ARRAY_BUFFER,s,t.STATIC_DRAW)}_compileShader(t,e){const s=this.gl,i=s.createShader(t);return s.shaderSource(i,e),s.compileShader(i),s.getShaderParameter(i,s.COMPILE_STATUS)?i:(console.error("Shader compile error:",s.getShaderInfoLog(i)),console.error("Source:",e),s.deleteShader(i),null)}useProgram(t,e,s){if(!this.available)return null;const i=this.gl;if(this.programs.has(t)){const a=this.programs.get(t);return i.useProgram(a),this.currentProgram=t,this._needsAttributeRebind&&(this._bindAttributes(a),this._needsAttributeRebind=!1),a}const n=this._compileShader(i.VERTEX_SHADER,e),r=this._compileShader(i.FRAGMENT_SHADER,s);if(!n||!r)return null;const o=i.createProgram();return i.attachShader(o,n),i.attachShader(o,r),i.linkProgram(o),i.getProgramParameter(o,i.LINK_STATUS)?(this.programs.set(t,o),this.uniformLocations.set(t,new Map),i.useProgram(o),this.currentProgram=t,this._bindAttributes(o),o):(console.error("Program link error:",i.getProgramInfoLog(o)),i.deleteProgram(o),null)}_bindAttributes(t){const e=this.gl,s=e.getAttribLocation(t,"aPosition"),i=e.getAttribLocation(t,"aUv");s!==-1&&(e.bindBuffer(e.ARRAY_BUFFER,this.positionBuffer),e.enableVertexAttribArray(s),e.vertexAttribPointer(s,2,e.FLOAT,!1,0,0)),i!==-1&&(e.bindBuffer(e.ARRAY_BUFFER,this.uvBuffer),e.enableVertexAttribArray(i),e.vertexAttribPointer(i,2,e.FLOAT,!1,0,0))}_getUniformLocation(t){const e=this.gl,s=this.programs.get(this.currentProgram),i=this.uniformLocations.get(this.currentProgram);return i.has(t)||i.set(t,e.getUniformLocation(s,t)),i.get(t)}setUniforms(t){if(!this.available||!this.currentProgram)return;const e=this.gl;for(const[s,i]of Object.entries(t)){const n=this._getUniformLocation(s);if(n!==null)if(typeof i=="number")e.uniform1f(n,i);else if(Array.isArray(i))switch(i.length){case 2:e.uniform2fv(n,i);break;case 3:e.uniform3fv(n,i);break;case 4:e.uniform4fv(n,i);break}else i instanceof Float32Array&&(i.length===9?e.uniformMatrix3fv(n,!1,i):i.length===16&&e.uniformMatrix4fv(n,!1,i))}}setColorUniform(t,e){if(!this.available||!this.currentProgram)return;const s=e.replace("#",""),i=parseInt(s.substring(0,2),16)/255,n=parseInt(s.substring(2,4),16)/255,r=parseInt(s.substring(4,6),16)/255,o=this._getUniformLocation(t);o!==null&&this.gl.uniform3f(o,i,n,r)}clear(t=0,e=0,s=0,i=0){if(!this.available)return;const n=this.gl;n.clearColor(t,e,s,i),n.clear(n.COLOR_BUFFER_BIT)}render(){if(!this.available||!this.currentProgram)return;const t=this.gl;t.drawArrays(t.TRIANGLES,0,6)}compositeOnto(t,e,s,i,n){this.available&&t.drawImage(this.canvas,e,s,i??this.canvas.width,n??this.canvas.height)}getCanvas(){return this.canvas}destroy(){if(!this.available)return;const t=this.gl;for(const e of this.programs.values())t.deleteProgram(e);t.deleteBuffer(this.positionBuffer),t.deleteBuffer(this.uvBuffer),this.programs.clear(),this.uniformLocations.clear()}}const ws=`
precision highp float;

attribute vec2 aPosition;
attribute vec2 aUv;

varying vec2 vUv;

void main() {
    vUv = aUv;
    gl_Position = vec4(aPosition, 0.0, 1.0);
}
`,pe=`
precision highp float;

varying vec2 vUv;

// Uniforms common to all sphere shaders
uniform float uTime;
uniform vec2 uResolution;
uniform vec3 uCameraRotation;  // rotationX, rotationY, rotationZ

// =============================================================================
// NOISE FUNCTIONS
// =============================================================================

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

float hash2(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

float hash3(vec3 p) {
    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
}

// 3D Value noise
float noise3D(vec3 x) {
    vec3 i = floor(x);
    vec3 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);

    float n = dot(i, vec3(1.0, 57.0, 113.0));

    return mix(
        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
            mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
        mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
            mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z
    );
}

// FBM (Fractional Brownian Motion)
float fbm(vec3 p, int octaves) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;

    for (int i = 0; i < 8; i++) {
        if (i >= octaves) break;
        value += amplitude * noise3D(p * frequency);
        frequency *= 2.0;
        amplitude *= 0.5;
    }

    return value;
}

// =============================================================================
// RAY-SPHERE INTERSECTION
// =============================================================================

/**
 * Ray-sphere intersection
 * @param rayOrigin - Ray origin (camera position)
 * @param rayDir - Normalized ray direction
 * @param sphereCenter - Sphere center
 * @param sphereRadius - Sphere radius
 * @return t value for intersection, -1.0 if no hit
 */
float raySphereIntersect(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius) {
    vec3 oc = rayOrigin - sphereCenter;
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        return -1.0;
    }

    return (-b - sqrt(discriminant)) / (2.0 * a);
}

// =============================================================================
// CAMERA AND ROTATION
// =============================================================================

/**
 * Create rotation matrix from Euler angles
 */
mat3 rotationMatrix(vec3 rotation) {
    float cx = cos(rotation.x);
    float sx = sin(rotation.x);
    float cy = cos(rotation.y);
    float sy = sin(rotation.y);
    float cz = cos(rotation.z);
    float sz = sin(rotation.z);

    mat3 rx = mat3(
        1.0, 0.0, 0.0,
        0.0, cx, -sx,
        0.0, sx, cx
    );

    mat3 ry = mat3(
        cy, 0.0, sy,
        0.0, 1.0, 0.0,
        -sy, 0.0, cy
    );

    mat3 rz = mat3(
        cz, -sz, 0.0,
        sz, cz, 0.0,
        0.0, 0.0, 1.0
    );

    return rz * ry * rx;
}

/**
 * Calculate ray direction from UV coordinates
 * Uses a simple pinhole camera model
 */
vec3 getRayDirection(vec2 uv) {
    // Convert UV to normalized device coordinates (-1 to 1)
    vec2 ndc = uv * 2.0 - 1.0;
    // Field of view ~53 degrees (atan(0.5) * 2)
    return normalize(vec3(ndc * 0.5, 1.0));
}

// =============================================================================
// LIGHTING
// =============================================================================

/**
 * Simple diffuse + ambient lighting
 */
float lighting(vec3 normal, vec3 lightDir, float ambient) {
    float diffuse = max(0.0, dot(normal, lightDir));
    return ambient + (1.0 - ambient) * diffuse;
}

/**
 * Fresnel effect for rim lighting
 */
float fresnel(vec3 normal, vec3 viewDir, float power) {
    return pow(1.0 - abs(dot(normal, viewDir)), power);
}
`,Ms=`
${pe}

uniform vec3 uStarColor;
uniform float uTemperature;      // Kelvin, affects color
uniform float uActivityLevel;    // 0-1, affects turbulence
uniform float uRotationSpeed;    // Self-rotation speed (radians/second)

// Tidal disruption uniforms
uniform float uTidalStretch;     // 0 = sphere, 1+ = elongated toward BH
uniform float uStretchDirX;      // Direction to black hole (X component)
uniform float uStretchDirZ;      // Direction to black hole (Z component)
uniform float uStressLevel;      // 0-1, surface chaos from tidal forces
uniform float uBaseRadius;       // Dynamic base radius for proper sizing
uniform float uTidalFlare;       // 0-1, sudden brightness burst at disruption start
uniform float uTidalWobble;      // 0-1, violent geometry wobble during trauma

// =============================================================================
// TIDAL DISTORTION - True Spaghettification via Ellipsoid Deformation
// Uses ray-ellipsoid intersection for physically correct stretching
// =============================================================================

/**
 * Ray-Ellipsoid intersection
 * Ellipsoid defined by semi-axes (a, b, c) where:
 * - a = stretch along BH direction (in XZ plane)
 * - b = Y axis (slight compression)
 * - c = perpendicular to BH direction in XZ plane (compression)
 *
 * Technique: Transform ray into "unit sphere space" via inverse scaling
 */
float rayEllipsoidIntersect(vec3 rayOrigin, vec3 rayDir, vec3 center, vec3 semiAxes) {
    // Scale ray into unit sphere space
    vec3 scaledOrigin = (rayOrigin - center) / semiAxes;
    vec3 scaledDir = rayDir / semiAxes;

    // Standard ray-sphere intersection in scaled space
    float a = dot(scaledDir, scaledDir);
    float b = 2.0 * dot(scaledOrigin, scaledDir);
    float c = dot(scaledOrigin, scaledOrigin) - 1.0;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        return -1.0;
    }

    return (-b - sqrt(discriminant)) / (2.0 * a);
}

/**
 * Calculate ellipsoid normal at hit point
 * Normal = gradient of ellipsoid equation = 2*(x/a, y/b, z/c)
 */
vec3 ellipsoidNormal(vec3 hitPoint, vec3 center, vec3 semiAxes) {
    vec3 localPos = hitPoint - center;
    // Gradient of (x/a) + (y/b) + (z/c) = 1
    vec3 grad = localPos / (semiAxes * semiAxes);
    return normalize(grad);
}

/**
 * Build tidal stretch axes from BH direction
 * Returns semi-axes (stretchAxis, Y, perpAxis) for ellipsoid
 * Includes violent wobble effect during trauma
 */
vec3 tidalSemiAxes(float stretch, vec2 stretchDir, float baseRadius, float wobble, float time) {
    // Stretch factor along BH direction (elongation toward/away from BH)
    float stretchFactor = 1.0 + stretch * 0.8;  // Up to 1.8x longer

    // Compression factor perpendicular (volume roughly conserved)
    float compressFactor = 1.0 / sqrt(stretchFactor);  // Compress to conserve volume

    // Y axis gets slight compression too
    float yFactor = 1.0 - stretch * 0.15;

    // === TRAUMA WOBBLE ===
    // Violent, chaotic geometry distortion during tidal shock
    if (wobble > 0.01) {
        // Multiple frequency wobbles for organic chaos
        float wobble1 = sin(time * 12.0) * cos(time * 7.3);
        float wobble2 = sin(time * 19.0 + 1.5) * cos(time * 11.0);
        float wobble3 = sin(time * 8.0 + 3.0);
        
        // Asymmetric wobble - more violent on stretch axis
        float stretchWobble = wobble * (0.3 + wobble1 * 0.2 + wobble2 * 0.15);
        float yWobble = wobble * (wobble2 * 0.25 + wobble3 * 0.15);
        float perpWobble = wobble * (wobble3 * 0.2 + wobble1 * 0.1);
        
        stretchFactor *= (1.0 + stretchWobble);
        yFactor *= (1.0 + yWobble);
        compressFactor *= (1.0 + perpWobble);
    }

    return vec3(
        baseRadius * stretchFactor,   // Stretch along BH radial
        baseRadius * yFactor,         // Slight Y compression
        baseRadius * compressFactor   // Compress perpendicular
    );
}

// =============================================================================
// PLASMA NOISE with flowing distortion
// =============================================================================

float plasmaNoise(vec3 p, float time) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float totalAmp = 0.0;

    for (int i = 0; i < 5; i++) {
        vec3 offset = vec3(
            sin(time * 0.1 + float(i)) * 0.5,
            cos(time * 0.15 + float(i) * 0.7) * 0.5,
            time * 0.05
        );
        value += amplitude * noise3D((p + offset) * frequency);
        totalAmp += amplitude;
        amplitude *= 0.5;
        frequency *= 2.0;
    }

    return value / totalAmp;
}

// =============================================================================
// HOT BUBBLES - bright spots that appear and pop
// =============================================================================

float hotBubbles(vec3 p, float time) {
    // Large slow bubbles
    vec3 p1 = p * 5.0 + vec3(0.0, time * 0.06, 0.0);
    float b1 = noise3D(p1);
    b1 = smoothstep(0.3, 0.6, b1);

    // Medium bubbles, faster
    vec3 p2 = p * 9.0 + vec3(time * 0.04, time * 0.08, 0.0);
    float b2 = noise3D(p2);
    b2 = smoothstep(0.35, 0.65, b2);

    // Small rapid bubbles
    vec3 p3 = p * 16.0 + vec3(time * 0.1, 0.0, time * 0.12);
    float b3 = noise3D(p3);
    b3 = smoothstep(0.4, 0.7, b3);

    float bubbles = b1 * 0.5 + b2 * 0.35 + b3 * 0.15;
    float pulse = sin(time * 2.0 + p.x * 10.0) * 0.3 + 0.7;

    return bubbles * pulse;
}

// =============================================================================
// BOILING TURBULENCE - fast chaotic movement
// =============================================================================

float boilingTurbulence(vec3 p, float time) {
    float turb = 0.0;
    float amp = 1.0;
    float freq = 4.0;

    for (int i = 0; i < 4; i++) {
        vec3 offset = vec3(
            sin(time * 0.3 + float(i) * 1.7) * 0.5,
            cos(time * 0.25 + float(i) * 2.3) * 0.5,
            time * 0.15 * (1.0 + float(i) * 0.3)
        );
        turb += amp * abs(noise3D(p * freq + offset));
        amp *= 0.5;
        freq *= 2.1;
    }
    return turb;
}

// =============================================================================
// CORONA FLAMES - structures around the edge
// =============================================================================

float coronaFlames(float angle, float rimFactor, float time, float activity) {
    // Multiple flame frequencies
    float flames = 0.0;

    // Large slow flames
    float f1 = sin(angle * 5.0 + time * 0.5) * 0.5 + 0.5;
    f1 *= noise3D(vec3(angle * 2.0, time * 0.3, 0.0));

    // Medium flames
    float f2 = sin(angle * 12.0 + time * 0.8) * 0.5 + 0.5;
    f2 *= noise3D(vec3(angle * 4.0, time * 0.5, 5.0));

    // Small rapid flames
    float f3 = sin(angle * 25.0 + time * 1.5) * 0.5 + 0.5;
    f3 *= noise3D(vec3(angle * 8.0, time * 0.8, 10.0));

    flames = f1 * 0.5 + f2 * 0.3 + f3 * 0.2;

    // Flames only visible at rim
    flames *= pow(rimFactor, 1.5);
    flames *= 0.5 + activity * 0.5;

    return flames;
}

// =============================================================================
// SELF ROTATION - rotate normal around Y axis
// =============================================================================

vec3 rotateY(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);
}

void main() {
    // === CIRCULAR MASK - prevents square canvas artifacts ===
    vec2 center = vUv - 0.5;
    float distFromCenter = length(center) * 2.0;

    // Wider cutoff for stretched ellipsoid
    if (distFromCenter > 1.6) {
        gl_FragColor = vec4(0.0);
        return;
    }

    float circularMask = 1.0 - smoothstep(1.3, 1.6, distFromCenter);

    // Setup ray - camera looking at sphere from fixed position
    vec3 rayOrigin = vec3(0.0, 0.0, -2.5);
    vec3 rayDir = getRayDirection(vUv);

    float time = uTime;
    float selfRotation = time * uRotationSpeed;

    // === TIDAL ELLIPSOID SETUP ===
    // Direction toward black hole in XZ plane
    vec2 stretchDir2D = normalize(vec2(uStretchDirX, uStretchDirZ) + 0.0001);
    float stretch = uTidalStretch;

    // Build rotation matrix to align ellipsoid X-axis with stretch direction
    // This rotates the ellipsoid so its long axis points toward the BH
    float stretchAngle = atan(stretchDir2D.y, stretchDir2D.x);
    float cs = cos(stretchAngle);
    float sn = sin(stretchAngle);

    // Rotation matrix around Y axis (to align stretch in XZ plane)
    mat3 stretchRot = mat3(
        cs,  0.0, -sn,
        0.0, 1.0, 0.0,
        sn,  0.0,  cs
    );
    mat3 stretchRotInv = mat3(
        cs,  0.0,  sn,
        0.0, 1.0, 0.0,
        -sn, 0.0,  cs
    );

    // Transform ray into ellipsoid-aligned space
    vec3 rotatedRayDir = stretchRotInv * rayDir;
    vec3 rotatedRayOrigin = stretchRotInv * rayOrigin;

    // Calculate ellipsoid semi-axes based on stretch
    // Use dynamic base radius passed from JS (scales with render texture size)
    // Falls back to 0.4 if uniform not set
    float baseRadius = uBaseRadius > 0.0 ? uBaseRadius : 0.4;
    vec3 semiAxes = tidalSemiAxes(stretch, stretchDir2D, baseRadius, uTidalWobble, time);

    // Ray-ellipsoid intersection for SURFACE
    float t = rayEllipsoidIntersect(rotatedRayOrigin, rotatedRayDir, vec3(0.0), semiAxes);

    // === NO CORONA - just render solid ellipsoid ===
    // If ray doesn't hit the surface, render transparent
    if (t < 0.0) {
        gl_FragColor = vec4(0.0);
        return;
    }

    // === SURFACE RENDERING ===
    // Calculate hit point in rotated (ellipsoid-aligned) space
    vec3 rotatedHitPoint = rotatedRayOrigin + rotatedRayDir * t;

    // Calculate ellipsoid normal (gradient of implicit surface)
    vec3 rotatedNormalRaw = ellipsoidNormal(rotatedHitPoint, vec3(0.0), semiAxes);

    // Transform hit point and normal back to world space
    vec3 hitPoint = stretchRot * rotatedHitPoint;
    vec3 normal = normalize(stretchRot * rotatedNormalRaw);

    // Apply inverse camera rotation to the normal (camera orbit)
    mat3 camRotMat = rotationMatrix(-uCameraRotation);
    vec3 rotatedNormal = camRotMat * normal;

    // Apply self-rotation to surface features
    rotatedNormal = rotateY(rotatedNormal, selfRotation);

    // === SPHERICAL DISTORTION for boiling effect ===
    vec2 sp = normal.xy;
    float r = dot(sp, sp);

    float brightness = 0.15 + (uTemperature / 10000.0) * 0.1;
    float distortStrength = 2.0 - brightness;

    vec2 warpedUV;
    if (r < 0.0001) {
        // At pole - use alternative coords
        float poleAngle = atan(rotatedNormal.y, rotatedNormal.x) + time * 0.15;
        float poleElev = acos(clamp(rotatedNormal.z, -1.0, 1.0));
        warpedUV = vec2(cos(poleAngle), sin(poleAngle)) * (poleElev / 3.14159) * distortStrength;
    } else {
        sp *= distortStrength;
        r = dot(sp, sp);
        float f = (1.0 - sqrt(abs(1.0 - r))) / (r + 0.001) + brightness * 0.5;
        warpedUV = sp * f + vec2(time * 0.05, 0.0);
    }

    // === PLASMA TEXTURE ===
    vec3 plasmaCoord = vec3(warpedUV * 3.0, time * 0.12);
    float plasma1 = plasmaNoise(plasmaCoord, time);
    float plasma2 = plasmaNoise(plasmaCoord * 1.3 + vec3(50.0), time * 1.2);
    float plasma = plasma1 * 0.6 + plasma2 * 0.4;
    plasma = plasma * 0.5 + 0.5;

    // === VIEW GEOMETRY ===
    float viewAngle = dot(normal, -rayDir);
    float edgeDist = 1.0 - viewAngle;
    float limbDarkening = pow(max(0.0, viewAngle), 0.4);

    // === TIDAL FACE INTENSITY ===
    // The side facing the black hole experiences more violent tidal forces
    // Calculate how much this surface point faces the BH direction
    vec3 bhDir3D = normalize(vec3(uStretchDirX, 0.0, uStretchDirZ));
    float facingBH = dot(normal, bhDir3D);  // -1 to 1, positive = facing BH
    float tidalFace = smoothstep(-0.2, 0.8, facingBH);  // Gradual transition
    tidalFace = tidalFace * tidalFace;  // More concentrated on BH side
    
    // Tidal face boost - up to 3x more violent on the BH-facing side
    float tidalFaceBoost = 1.0 + tidalFace * uStressLevel * 2.0;

    // === MULTI-LAYER EFFECTS (stress-enhanced) ===
    // Stress amplifies all turbulent effects - star is being torn apart!
    // Much more violent - up to 5x chaos at max stress
    float stressBoost = 1.0 + uStressLevel * 4.0;
    
    // Combined boost: general stress + extra violence on BH-facing side
    float combinedBoost = stressBoost * tidalFaceBoost;

    float turbIntensity = boilingTurbulence(rotatedNormal, time * combinedBoost) * 0.6;
    turbIntensity *= combinedBoost;

    float bubbles = hotBubbles(rotatedNormal, time * combinedBoost);
    bubbles *= combinedBoost * 1.5;  // More dramatic bubbles on tidal face

    // Granulation becomes violent under stress - larger and faster
    float gran = noise3D(rotatedNormal * 15.0 + time * 0.5 * combinedBoost);
    gran *= combinedBoost * 1.2;

    // === TIDAL FRACTURING ===
    // Stress causes visible cracks/tears - concentrated on BH-facing side
    float fractures = 0.0;
    if (uStressLevel > 0.15) {  // Start fractures earlier (was 0.3)
        // Fractures are more intense on the tidal face
        float fractureBoost = 1.0 + tidalFace * 2.0;  // Up to 3x on BH side
        float fractureNoise = noise3D(rotatedNormal * 6.0 + time * 0.8 * fractureBoost);
        float fractureThreshold = 1.0 - (uStressLevel - 0.15) * 1.2 * fractureBoost;
        fractures = smoothstep(fractureThreshold, fractureThreshold + 0.08, fractureNoise);
        fractures *= uStressLevel * 1.2 * fractureBoost;  // More intense on BH side
    }

    // === PULSATION (amplified by stress) ===
    float pulse1 = cos(time * 0.5) * 0.5;
    float pulse2 = sin(time * 0.25) * 0.5;
    float pulseAmp = uActivityLevel * (1.0 + uStressLevel);
    float pulse = (pulse1 + pulse2) * 0.3 * pulseAmp;

    // === TIDAL HOTSPOT ===
    // Bright glowing region on the BH-facing side - like matter being pulled off
    float tidalHotspot = pow(tidalFace, 3.0) * uStressLevel;
    // Add some flickering/chaos to the hotspot
    tidalHotspot *= 0.7 + 0.3 * noise3D(rotatedNormal * 8.0 + time * 2.0);

    // === COMBINED INTENSITY ===
    float totalIntensity = plasma * 0.35 + turbIntensity * 0.25 + gran * 0.2;
    totalIntensity += bubbles * 0.4;
    totalIntensity += fractures * 0.5;  // Fractures glow hot
    totalIntensity += tidalHotspot * 0.8;  // Bright tidal hotspot
    totalIntensity *= 1.0 + pulse;

    // === 4-TIER COLOR SYSTEM ===
    vec3 baseColor = uStarColor;
    float maxComp = max(baseColor.r, max(baseColor.g, baseColor.b));
    if (maxComp > 0.01) baseColor = baseColor / maxComp * 0.85;

    // Temperature-based color blending
    float tempBlend = smoothstep(5000.0, 7500.0, uTemperature);

    vec3 hotColor = baseColor * vec3(1.6, 1.35, 1.2);
    vec3 coolColor = mix(baseColor * vec3(0.5, 0.3, 0.2), baseColor * vec3(0.7, 0.8, 0.95), tempBlend);
    vec3 warmColor = mix(baseColor * vec3(1.2, 1.0, 0.85), baseColor * vec3(1.0, 1.05, 1.2), tempBlend);
    vec3 blazingColor = mix(baseColor * vec3(2.0, 1.6, 1.3), baseColor * vec3(1.4, 1.5, 1.8), tempBlend);

    // Map intensity to color
    vec3 surfaceColor;
    if (totalIntensity < 0.35) {
        surfaceColor = mix(coolColor, warmColor, totalIntensity / 0.35);
    } else if (totalIntensity < 0.65) {
        surfaceColor = mix(warmColor, hotColor, (totalIntensity - 0.35) / 0.3);
    } else if (totalIntensity < 1.0) {
        surfaceColor = mix(hotColor, blazingColor, (totalIntensity - 0.65) / 0.35);
    } else {
        surfaceColor = blazingColor * (1.0 + (totalIntensity - 1.0) * 0.8);
    }

    // Bubble highlights
    float bubbleHighlight = pow(bubbles, 1.5) * turbIntensity;
    surfaceColor += blazingColor * bubbleHighlight * 0.6;

    // === LIMB DARKENING ===
    surfaceColor *= 0.75 + limbDarkening * 0.25;

    // === ORGANIC RIM GLOW ===
    float rimAngle = atan(normal.y, normal.x) + selfRotation;
    float rimNoise = noise3D(vec3(rimAngle * 3.0, edgeDist * 2.0, time * 0.2));
    rimNoise = rimNoise * 0.5 + 0.5;

    float rimIntensity = pow(edgeDist, 2.0) * (0.4 + rimNoise * 0.6);
    vec3 rimColor = baseColor * vec3(1.3, 0.95, 0.6);
    surfaceColor += rimColor * rimIntensity * 0.6 * uActivityLevel;

    // === EDGE GLOW (corona bleeding into surface) ===
    float edgeGlow = pow(edgeDist, 0.5) * 0.3 * uActivityLevel;
    surfaceColor += warmColor * edgeGlow;

    // === CENTER BOOST ===
    float centerBoost = pow(viewAngle, 1.5) * 0.2;
    surfaceColor += baseColor * centerBoost;

    // === SHIMMER ===
    float shimmer = sin(turbIntensity * 10.0 + time * 3.0) * 0.05 + 1.0;
    surfaceColor *= shimmer;

    // === TIDAL FLARE ===
    // Sudden brightness burst when disruption begins
    // Concentrated on the BH-facing side with violent flickering
    if (uTidalFlare > 0.01) {
        // Flare is brightest on the BH-facing side
        float flareFace = 0.3 + tidalFace * 0.7;
        
        // Violent flickering during the flare
        float flareFlicker = 0.7 + 0.3 * noise3D(rotatedNormal * 10.0 + time * 8.0);
        
        // White-hot flare color
        vec3 flareColor = vec3(1.0, 0.95, 0.8);
        
        // Additive flare - makes entire star brighter
        float flareIntensity = uTidalFlare * flareFace * flareFlicker * 2.0;
        surfaceColor += flareColor * flareIntensity;
        
        // Extra bloom at the BH-facing tip
        float tipFlare = pow(tidalFace, 4.0) * uTidalFlare * 1.5;
        surfaceColor += vec3(1.0, 0.9, 0.7) * tipFlare;
    }

    surfaceColor = clamp(surfaceColor, 0.0, 3.5);  // Allow brighter for flare

    gl_FragColor = vec4(surfaceColor, 1.0);
}
`,Ss=`
${pe}

uniform float uAwakeningLevel;  // 0 = dormant, 1 = fully active
uniform float uFeedingPulse;    // Temporary glow from feeding
uniform float uRotation;        // Black hole spin angle (Kerr rotation)

void main() {
    vec2 uv = vUv;
    vec2 center = uv - 0.5;
    float dist = length(center) * 2.0;  // 0 at center, 1 at edge
    float angle = atan(center.y, center.x);

    float time = uTime;
    float awakeFactor = uAwakeningLevel;
    float pulseFactor = uFeedingPulse;

    // Spin angle for rotating effects (frame dragging)
    // Using uTime since custom uniforms don't update properly
    float spinAngle = angle + uTime * 4.0;  // Faster spin

    // === RADII (normalized to quad size) ===
    float eventHorizon = 0.42;          // Slightly larger core
    float photonSphere = 0.54;          // Tighten ring closer to horizon
    float shadowEdge = 0.5;             // Shadow boundary

    // === CIRCULAR MASK ===
    if (dist > 1.5) {
        gl_FragColor = vec4(0.0);
        return;
    }

    // === NO INTERNAL STARFIELD ===
    // The real starfield is rendered separately in the scene
    // This shader just renders the dark void + subtle edge effects
    // True gravitational lensing would require render-to-texture of background

    // === EVENT HORIZON - Gradient from pure black to very dark edge ===
    // Edge color ~#110b06 = RGB(17,11,6) = vec3(0.067, 0.043, 0.024)
    if (dist < shadowEdge) {
        // Use shadowEdge (0.52) as outer boundary for smooth transition to ring
        float edgeT = dist / shadowEdge;  // 0 at center, 1 at shadow edge

        // Very steep curve - stays pure black until very close to edge
        float glowFactor = pow(edgeT, 8.0);

        // Very dark brownish-black - NO yellow, matches #110b06
        vec3 edgeColor = vec3(0.067, 0.043, 0.024) * glowFactor;

        gl_FragColor = vec4(edgeColor, 1.0);
        return;
    }

    // === PHOTON SPHERE - Subtle ring with gentler spin asymmetry ===
    float photonRingWidth = 0.035;
    float photonDist = abs(dist - photonSphere);
    float photonRing = exp(-photonDist * photonDist / (photonRingWidth * photonRingWidth));

    // Softer Doppler asymmetry to avoid pointy highlights
    float doppler = 0.78 + 0.22 * cos(spinAngle);  // narrower asymmetry
    photonRing *= 0.18 + doppler * 0.38;           // 18%..56% brightness

    // Soft tip highlight to indicate spin without a spike
    float tipAlign = max(0.0, cos(spinAngle));
    float tipRadial = smoothstep(photonRingWidth * 1.2, 0.0, photonDist);
    float hotSpotGlow = tipAlign * tipAlign * tipRadial * 0.25;

    // Scale with awakening - more visible when feeding
    photonRing *= 0.15 + awakeFactor * 0.35;

    // === FEEDING PULSE - Subtle ripple when consuming ===
    float pulseRipple = 0.0;
    if (pulseFactor > 0.01) {
        float ripplePhase = fract(time * 1.5) * 0.3;
        float rippleRadius = shadowEdge + ripplePhase;
        float ripple = exp(-pow(dist - rippleRadius, 2.0) * 80.0);
        pulseRipple = ripple * pulseFactor * 0.15;  // Subtle
    }

    // === EDGE GLOW - keep subtle; avoid wide smear
    float edgeGlow = 0.0;
    if (dist > shadowEdge && dist < photonSphere + 0.08) {
        float edgeFactor = smoothstep(shadowEdge, photonSphere, dist);
        edgeFactor *= smoothstep(photonSphere + 0.08, photonSphere, dist);
        edgeGlow = edgeFactor * pulseFactor * 0.06;
    }

    // === COMBINE EFFECTS ===
    vec3 color = vec3(0.0);

    // Photon sphere ring (warm orange-yellow)
    vec3 photonColor = vec3(1.0, 0.8, 0.45);
    color += photonColor * photonRing;

    // Soft tip highlight (spin indicator)
    vec3 hotSpotColor = vec3(1.0, 0.9, 0.65);
    color += hotSpotColor * hotSpotGlow;

    // Edge glow when feeding
    vec3 glowColor = vec3(1.0, 0.5, 0.2);
    color += glowColor * edgeGlow;

    // Feeding pulse ripple
    vec3 pulseColor = vec3(1.0, 0.6, 0.3);
    color += pulseColor * pulseRipple;

    // === OUTER FADE ===
    float outerFade = 1.0 - smoothstep(0.9, 1.25, dist);
    color *= outerFade;

    // === ALPHA ===
    // Event horizon and photon sphere are fully opaque to occlude background
    float alpha;
    if (dist < photonSphere) {
        alpha = 1.0;
        color = (dist < shadowEdge) ? vec3(0.0) : color; // keep core solid black
    } else {
        // Alpha based on visible content
        float contentBrightness = max(max(color.r, color.g), color.b);
        alpha = smoothstep(0.01, 0.06, contentBrightness);
        alpha = max(alpha, smoothstep(photonSphere + 0.12, shadowEdge, dist) * 0.25);
        alpha *= outerFade;
    }

    gl_FragColor = vec4(color, alpha);
}
`,Cs=`
${pe}

uniform vec3 uBaseColor;
uniform float uHasAtmosphere;  // 0-1
uniform float uSeed;

void main() {
    // Setup ray - camera looking at sphere from fixed position
    vec3 rayOrigin = vec3(0.0, 0.0, -2.5);
    vec3 rayDir = getRayDirection(vUv);

    // Ray-sphere intersection (sphere at origin with radius 0.5)
    float t = raySphereIntersect(rayOrigin, rayDir, vec3(0.0), 0.5);

    if (t < 0.0) {
        // Atmosphere halo
        if (uHasAtmosphere > 0.0) {
            vec2 center = vUv - 0.5;
            float dist = length(center) * 2.0;
            float atmo = smoothstep(0.6, 0.5, dist) * smoothstep(0.45, 0.52, dist);
            atmo *= uHasAtmosphere * 0.4;
            vec3 atmoColor = vec3(0.5, 0.7, 1.0) * atmo;
            // Premultiplied alpha
            gl_FragColor = vec4(atmoColor * atmo, atmo);
        } else {
            gl_FragColor = vec4(0.0);
        }
        return;
    }

    // Calculate hit point and normal
    vec3 hitPoint = rayOrigin + rayDir * t;
    vec3 normal = normalize(hitPoint);

    // Apply inverse camera rotation for surface features
    mat3 rotMat = rotationMatrix(-uCameraRotation);
    vec3 rotatedNormal = rotMat * normal;

    // Seeded noise for consistent terrain
    vec3 noiseCoord = rotatedNormal * 4.0 + uSeed * 100.0;
    float terrain = fbm(noiseCoord, 5);

    // Height-based coloring
    vec3 lowColor = uBaseColor * 0.6;    // Valleys/lowlands
    vec3 highColor = uBaseColor * 1.2;   // Mountains/highlands
    vec3 surfaceColor = mix(lowColor, highColor, terrain);

    // Add some variation
    float variation = noise3D(rotatedNormal * 10.0 + uSeed * 50.0);
    surfaceColor *= 0.9 + variation * 0.2;

    // Lighting
    vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));
    float light = lighting(normal, lightDir, 0.3);
    surfaceColor *= light;

    // Atmosphere scattering at edges
    if (uHasAtmosphere > 0.0) {
        float rim = fresnel(normal, -rayDir, 3.0);
        vec3 atmoColor = vec3(0.5, 0.7, 1.0);
        surfaceColor = mix(surfaceColor, atmoColor, rim * uHasAtmosphere * 0.4);
    }

    gl_FragColor = vec4(surfaceColor, 1.0);
}
`,Rs=`
${pe}

uniform vec3 uBaseColor;
uniform float uSeed;
uniform float uStormIntensity;  // 0-1
uniform float uRotationSpeed;   // rotation speed multiplier (default ~0.1)

void main() {
    // Setup ray - camera looking at sphere from fixed position
    vec3 rayOrigin = vec3(0.0, 0.0, -2.5);
    vec3 rayDir = getRayDirection(vUv);

    // Ray-sphere intersection (sphere at origin with radius 0.5)
    float t = raySphereIntersect(rayOrigin, rayDir, vec3(0.0), 0.5);

    if (t < 0.0) {
        gl_FragColor = vec4(0.0);
        return;
    }

    // Calculate hit point and normal
    vec3 hitPoint = rayOrigin + rayDir * t;
    vec3 normal = normalize(hitPoint);

    // Apply inverse camera rotation for surface features
    mat3 rotMat = rotationMatrix(-uCameraRotation);
    vec3 rotatedNormal = rotMat * normal;

    // Convert to spherical coordinates for banding (use rotated normal)
    float latitude = asin(rotatedNormal.y);  // -PI/2 to PI/2
    float longitude = atan(rotatedNormal.z, rotatedNormal.x);  // -PI to PI

    // Animated rotation (use uRotationSpeed, default to 0.1 if not set)
    float rotSpeed = uRotationSpeed > 0.0 ? uRotationSpeed : 0.1;
    float time = uTime * rotSpeed;

    // Create bands based on latitude
    float bands = sin(latitude * 15.0 + time) * 0.5 + 0.5;
    bands += sin(latitude * 25.0 - time * 0.5) * 0.25;
    bands += sin(latitude * 40.0 + time * 0.3) * 0.125;

    // Turbulent distortion of bands
    vec3 noiseCoord = vec3(longitude + time * 0.2, latitude * 3.0, uSeed);
    float turb = fbm(noiseCoord * 5.0, 4) * 0.3;
    bands += turb;

    // Color variation based on bands
    vec3 lightBand = uBaseColor * 1.3;
    vec3 darkBand = uBaseColor * 0.7;
    vec3 surfaceColor = mix(darkBand, lightBand, bands);

    // Add storm features
    if (uStormIntensity > 0.0) {
        // Great red spot style storm
        float stormLat = 0.3;  // Storm latitude
        float stormLon = time * 0.5;  // Storm drifts
        vec2 stormCenter = vec2(stormLon, stormLat);
        vec2 pos = vec2(longitude, latitude);
        float stormDist = length(pos - stormCenter);
        float storm = smoothstep(0.5, 0.2, stormDist);
        storm *= uStormIntensity;

        // Storm color and swirl
        vec3 stormColor = vec3(0.8, 0.3, 0.2);
        float swirl = sin(stormDist * 20.0 - time * 3.0) * 0.5 + 0.5;
        surfaceColor = mix(surfaceColor, stormColor * swirl, storm);
    }

    // Lighting with some subsurface scattering effect
    vec3 lightDir = normalize(vec3(1.0, 0.5, 0.3));
    float light = lighting(normal, lightDir, 0.4);
    surfaceColor *= light;

    // Limb darkening
    float viewAngle = dot(normal, -rayDir);
    surfaceColor *= 0.7 + max(0.0, viewAngle) * 0.3;

    gl_FragColor = vec4(surfaceColor, 1.0);
}
`,Bt={vertex:ws,star:Ms,blackHole:Ss,rockyPlanet:Cs,gasGiant:Rs},Pe=class St extends ht{static _getGLRenderer(t,e){return St._glRenderer?(St._glRendererSize.width!==t||St._glRendererSize.height!==e)&&(St._glRenderer.resize(t,e),St._glRendererSize={width:t,height:e}):(St._glRenderer=new Ze(t,e),St._glRendererSize={width:t,height:e}),St._glRenderer}constructor(t,e={}){super(e),this.radius=t,this.camera=e.camera??null,this.debug=e.debug??!1,this.segments=e.segments??20,this.useShader=e.useShader??!1,this.shaderType=e.shaderType??"star",this.shaderUniforms=e.shaderUniforms??{},this._shaderInitialized=!1,this.selfRotationX=e.selfRotationX??0,this.selfRotationY=e.selfRotationY??0,this.selfRotationZ=e.selfRotationZ??0,this._generateGeometry()}setCamera(t){return this.camera=t,this}setShaderUniforms(t){return Object.assign(this.shaderUniforms,t),this}_getFragmentShader(){switch(this.shaderType){case"star":return Bt.star;case"blackHole":return Bt.blackHole;case"rockyPlanet":return Bt.rockyPlanet;case"gasGiant":return Bt.gasGiant;default:return Bt.star}}_initShader(t,e){const s=St._getGLRenderer(t,e);if(!s||!s.isAvailable()){this.useShader=!1;return}const i=`sphere_${this.shaderType}`;s.useProgram(i,Bt.vertex,this._getFragmentShader()),this._shaderInitialized=!0}_renderWithShader(t,e,s,i){var n,r,o,a;const c=1+(((n=this.shaderUniforms)==null?void 0:n.uTidalStretch)??0),u=i*c,h=Math.ceil((i+u)*2),d=St._getGLRenderer(h,h);if(!d||!d.isAvailable())return!1;this._shaderInitialized||this._initShader(h,h);const g=`sphere_${this.shaderType}`;d.useProgram(g,Bt.vertex,this._getFragmentShader()),d.clear(0,0,0,0);const p=1.25*i/(h/2);d.setUniforms({uTime:performance.now()/1e3,uResolution:[h,h],uBaseRadius:p,uCameraRotation:[((r=this.camera)==null?void 0:r.rotationX)??0,((o=this.camera)==null?void 0:o.rotationY)??0,((a=this.camera)==null?void 0:a.rotationZ)??0]}),d.setUniforms(this.shaderUniforms);for(const[w,b]of Object.entries(this.shaderUniforms))typeof b=="string"&&b.startsWith("#")&&d.setColorUniform(w,b);d.render();const v=e-h/2,_=s-h/2;return d.compositeOnto(t,v,_,h,h),!0}_generateGeometry(){this.vertices=[],this.faces=[];const t=this.segments,e=this.segments*2;for(let s=0;s<=t;s++){const i=s*Math.PI/t,n=Math.sin(i),r=Math.cos(i);for(let o=0;o<=e;o++){const a=o*2*Math.PI/e,l=Math.sin(a),c=Math.cos(a),u=this.radius*n*c,h=this.radius*r,d=this.radius*n*l;this.vertices.push({x:u,y:h,z:d,nx:n*c,ny:r,nz:n*l})}}for(let s=0;s<t;s++)for(let i=0;i<e;i++){const n=s*(e+1)+i,r=n+e+1;this.faces.push([n,r,n+1]),this.faces.push([r,r+1,n+1])}}_applySelfRotation(t,e,s){if(this.selfRotationY!==0){const i=Math.cos(this.selfRotationY),n=Math.sin(this.selfRotationY),r=t*i-s*n,o=t*n+s*i;t=r,s=o}if(this.selfRotationX!==0){const i=Math.cos(this.selfRotationX),n=Math.sin(this.selfRotationX),r=e*i-s*n,o=e*n+s*i;e=r,s=o}if(this.selfRotationZ!==0){const i=Math.cos(this.selfRotationZ),n=Math.sin(this.selfRotationZ),r=t*i-e*n,o=t*n+e*i;t=r,e=o}return{x:t,y:e,z:s}}_calculateLighting(t,e,s){const o=Math.sqrt(.99),a=.5/o,l=.7/o,c=.5/o;let u=t*a+e*l+s*c;return u=Math.max(0,u)*.7+.3,u}_applyLighting(t,e){if(!t||typeof t!="string"||!t.startsWith("#"))return t;const s=t.replace("#",""),i=parseInt(s.substring(0,2),16),n=parseInt(s.substring(2,4),16),r=parseInt(s.substring(4,6),16),o=Math.round(i*e),a=Math.round(n*e),l=Math.round(r*e);return`rgb(${o}, ${a}, ${l})`}draw(){if(super.draw(),!this.camera){this.color&&y.shapes.fillCircle(0,0,this.radius,this.color),this.debug&&this.stroke&&y.shapes.strokeCircle(0,0,this.radius,this.stroke,this.lineWidth);return}if(this.useShader&&!this.debug){const i=this.camera.project(this.x||0,this.y||0,this.z||0),n=this.camera.perspective/(this.camera.perspective+i.z),r=this.radius*n,o=y.ctx,a=o.getTransform(),l=a.e,c=a.f;o.save(),o.setTransform(1,0,0,1,0,0);const u=this._renderWithShader(o,l+i.x,c+i.y,r);if(o.restore(),u)return}const t=this.selfRotationX!==0||this.selfRotationY!==0||this.selfRotationZ!==0,e=this.vertices.map(i=>{let n=i.x,r=i.y,o=i.z,a=i.nx,l=i.ny,c=i.nz;if(t){const b=this._applySelfRotation(n,r,o);n=b.x,r=b.y,o=b.z;const S=this._applySelfRotation(a,l,c);a=S.x,l=S.y,c=S.z}const u=this.camera.project(n+(this.x||0),r+(this.y||0),o+(this.z||0));if(this.camera.rotationZ!==0){const b=Math.cos(this.camera.rotationZ),S=Math.sin(this.camera.rotationZ),C=a,T=l;a=C*b-T*S,l=C*S+T*b}const h=Math.cos(this.camera.rotationY),d=Math.sin(this.camera.rotationY),g=a*h-c*d,m=a*d+c*h,p=Math.cos(this.camera.rotationX),v=Math.sin(this.camera.rotationX),_=l*p-m*v,w=l*v+m*p;return{...u,nx:g,ny:_,nz:w}});this.debug&&this.trace("Sphere3D.draw: projected vertices",e.length);const s=[];for(const i of this.faces){const n=e[i[0]],r=e[i[1]],o=e[i[2]];if(n.z<-this.camera.perspective+10||r.z<-this.camera.perspective+10||o.z<-this.camera.perspective+10)continue;const a=(n.z+r.z+o.z)/3,l=(n.nx+r.nx+o.nx)/3,c=(n.ny+r.ny+o.ny)/3,u=(n.nz+r.nz+o.nz)/3;if(u>.1)continue;const h=this._calculateLighting(l,c,u);s.push({vertices:[n,r,o],avgZ:a,intensity:h})}s.sort((i,n)=>n.avgZ-i.avgZ);for(const i of s){const n=i.vertices.map(r=>({x:r.x,y:r.y}));if(this.debug)y.ctx.beginPath(),y.ctx.moveTo(n[0].x,n[0].y),y.ctx.lineTo(n[1].x,n[1].y),y.ctx.lineTo(n[2].x,n[2].y),y.ctx.closePath(),this.stroke&&(y.ctx.strokeStyle=this.stroke,y.ctx.lineWidth=this.lineWidth??1,y.ctx.stroke());else if(this.color){const r=this._applyLighting(this.color,i.intensity);y.ctx.beginPath(),y.ctx.moveTo(n[0].x,n[0].y),y.ctx.lineTo(n[1].x,n[1].y),y.ctx.lineTo(n[2].x,n[2].y),y.ctx.closePath(),y.ctx.fillStyle=r,y.ctx.fill()}}}calculateBounds(){const t=this.radius*2;return{x:this.x,y:this.y,width:t,height:t}}};I(Pe,"_glRenderer",null);I(Pe,"_glRendererSize",{width:0,height:0});let Si=Pe;const Ts=`
precision highp float;

attribute vec2 aPosition;
attribute vec2 aUv;

varying vec2 vUv;

void main() {
    vUv = aUv;
    gl_Position = vec4(aPosition, 0.0, 1.0);
}
`,ye=`
precision highp float;

varying vec2 vUv;

uniform float uTime;
uniform vec2 uResolution;

// =============================================================================
// NOISE FUNCTIONS
// =============================================================================

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

float hash2(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

// 2D Value noise
float noise2D(vec2 x) {
    vec2 i = floor(x);
    vec2 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);

    float a = hash2(i);
    float b = hash2(i + vec2(1.0, 0.0));
    float c = hash2(i + vec2(0.0, 1.0));
    float d = hash2(i + vec2(1.0, 1.0));

    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

// FBM (Fractional Brownian Motion)
float fbm2D(vec2 p, int octaves) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;

    for (int i = 0; i < 8; i++) {
        if (i >= octaves) break;
        value += amplitude * noise2D(p * frequency);
        frequency *= 2.0;
        amplitude *= 0.5;
    }

    return value;
}
`,ks=`
${ye}

uniform vec3 uColor1;
uniform vec3 uColor2;
uniform float uAngle;

void main() {
    vec2 uv = vUv;

    // Calculate gradient direction from angle
    vec2 dir = vec2(cos(uAngle), sin(uAngle));

    // Project UV onto gradient direction
    // Center at 0.5 so gradient goes through middle
    float t = dot(uv - 0.5, dir) + 0.5;
    t = clamp(t, 0.0, 1.0);

    // Interpolate colors
    vec3 color = mix(uColor1, uColor2, t);

    gl_FragColor = vec4(color, 1.0);
}
`,As=`
${ye}

uniform vec3 uLineColor;
uniform vec3 uBackgroundColor;
uniform float uGridSize;
uniform float uLineWidth;

void main() {
    vec2 uv = vUv;

    // Scale UV to grid space
    vec2 grid = fract(uv * uGridSize);

    // Calculate distance to nearest grid line
    float lineX = min(grid.x, 1.0 - grid.x);
    float lineY = min(grid.y, 1.0 - grid.y);

    // Smoothstep for anti-aliased lines
    float halfWidth = uLineWidth * 0.5;
    float edgeSmooth = 0.01;

    float lineAlphaX = 1.0 - smoothstep(halfWidth - edgeSmooth, halfWidth + edgeSmooth, lineX);
    float lineAlphaY = 1.0 - smoothstep(halfWidth - edgeSmooth, halfWidth + edgeSmooth, lineY);
    float lineAlpha = max(lineAlphaX, lineAlphaY);

    // Mix colors
    vec3 color = mix(uBackgroundColor, uLineColor, lineAlpha);

    gl_FragColor = vec4(color, 1.0);
}
`,Ds=`
${ye}

uniform vec3 uColor1;
uniform vec3 uColor2;
uniform float uSize;

void main() {
    vec2 uv = vUv;

    // Calculate which square we're in
    vec2 cell = floor(uv * uSize);

    // Alternating pattern based on cell coordinates
    float checker = mod(cell.x + cell.y, 2.0);

    // Select color
    vec3 color = mix(uColor1, uColor2, checker);

    gl_FragColor = vec4(color, 1.0);
}
`,Ps=`
${ye}

uniform vec3 uColor1;
uniform vec3 uColor2;
uniform float uNoiseScale;
uniform float uAnimSpeed;

void main() {
    vec2 uv = vUv;

    // Animated noise
    float n = fbm2D(uv * uNoiseScale + uTime * uAnimSpeed, 4);

    // Map noise to colors
    vec3 color = mix(uColor1, uColor2, n);

    gl_FragColor = vec4(color, 1.0);
}
`,Ot={vertex:Ts,gradient:ks,grid:As,checkerboard:Ds,noise:Ps},Ve=class Ct extends ht{static _getGLRenderer(t,e){return Ct._glRenderer?(Ct._glRendererSize.width!==t||Ct._glRendererSize.height!==e)&&(Ct._glRenderer.resize(t,e),Ct._glRendererSize={width:t,height:e}):(Ct._glRenderer=new Ze(t,e),Ct._glRendererSize={width:t,height:e}),Ct._glRenderer}constructor(t,e,s={}){super(s),this.planeWidth=t,this.planeHeight=e,this.x=s.x??0,this.y=s.y??0,this.z=s.z??0,this.camera=s.camera??null,this.debug=s.debug??!1,this.doubleSided=s.doubleSided??!0,this.texture=s.texture??null,this.selfRotationX=s.selfRotationX??0,this.selfRotationY=s.selfRotationY??0,this.selfRotationZ=s.selfRotationZ??0,this.useShader=s.useShader??!1,this.shaderType=s.shaderType??"gradient",this.shaderUniforms=s.shaderUniforms??{},this._shaderInitialized=!1,this._generateGeometry()}setCamera(t){return this.camera=t,this}setTexture(t){return this.texture=t,this}setShaderUniforms(t){return Object.assign(this.shaderUniforms,t),this}_generateGeometry(){const t=this.planeWidth/2,e=this.planeHeight/2;this.vertices=[{x:-t,y:-e,z:0,nx:0,ny:0,nz:-1,u:0,v:0},{x:t,y:-e,z:0,nx:0,ny:0,nz:-1,u:1,v:0},{x:t,y:e,z:0,nx:0,ny:0,nz:-1,u:1,v:1},{x:-t,y:e,z:0,nx:0,ny:0,nz:-1,u:0,v:1}],this.faces=[[0,1,2],[0,2,3]]}_getFragmentShader(){switch(this.shaderType){case"gradient":return Ot.gradient;case"grid":return Ot.grid;case"checkerboard":return Ot.checkerboard;case"noise":return Ot.noise;default:return Ot.gradient}}_initShader(t,e){const s=Ct._getGLRenderer(t,e);if(!s||!s.isAvailable())return!1;const i=`plane_${this.shaderType}`,n=Ot.vertex,r=this._getFragmentShader();try{return s.useProgram(i,n,r),this._shaderInitialized=!0,!0}catch(o){return console.warn("Plane3D shader init failed:",o),!1}}_renderWithShader(t,e,s,i,n){const r=Math.max(Math.ceil(Math.max(i,n)),16);if(!this._shaderInitialized&&!this._initShader(r,r))return!1;const o=Ct._getGLRenderer(r,r);if(!o||!o.isAvailable())return!1;const a=`plane_${this.shaderType}`;o.useProgram(a,Ot.vertex,this._getFragmentShader());const l=performance.now()/1e3;o.setUniforms({uTime:l,uResolution:[r,r]}),o.setUniforms(this.shaderUniforms),o.render();const c=e-i/2,u=s-n/2;return o.compositeOnto(t,c,u,i,n),!0}_applySelfRotation(t,e,s){if(this.selfRotationY!==0){const i=Math.cos(this.selfRotationY),n=Math.sin(this.selfRotationY),r=t*i-s*n,o=t*n+s*i;t=r,s=o}if(this.selfRotationX!==0){const i=Math.cos(this.selfRotationX),n=Math.sin(this.selfRotationX),r=e*i-s*n,o=e*n+s*i;e=r,s=o}if(this.selfRotationZ!==0){const i=Math.cos(this.selfRotationZ),n=Math.sin(this.selfRotationZ),r=t*i-e*n,o=t*n+e*i;t=r,e=o}return{x:t,y:e,z:s}}_calculateLighting(t,e,s){const o=Math.sqrt(.99),a=.5/o,l=.7/o,c=.5/o;let u=t*a+e*l+s*c;return u=Math.max(0,u)*.7+.3,u}_applyLighting(t,e){if(!t||typeof t!="string"||!t.startsWith("#"))return t;const s=t.replace("#",""),i=parseInt(s.substring(0,2),16),n=parseInt(s.substring(2,4),16),r=parseInt(s.substring(4,6),16),o=Math.round(i*e),a=Math.round(n*e),l=Math.round(r*e);return`rgb(${o}, ${a}, ${l})`}draw(){if(super.draw(),!this.camera){this.color&&y.shapes.fillRect(-this.planeWidth/2,-this.planeHeight/2,this.planeWidth,this.planeHeight,this.color);return}const t=this.selfRotationX!==0||this.selfRotationY!==0||this.selfRotationZ!==0,e=this.vertices.map(h=>{let d=h.x,g=h.y,m=h.z,p=h.nx,v=h.ny,_=h.nz;if(t){const z=this._applySelfRotation(d,g,m);d=z.x,g=z.y,m=z.z;const A=this._applySelfRotation(p,v,_);p=A.x,v=A.y,_=A.z}const w=this.camera.project(d+this.x,g+this.y,m+this.z);if(this.camera.rotationZ!==0){const z=Math.cos(this.camera.rotationZ),A=Math.sin(this.camera.rotationZ),P=p,E=v;p=P*z-E*A,v=P*A+E*z}const b=Math.cos(this.camera.rotationY),S=Math.sin(this.camera.rotationY),C=p*b-_*S,T=p*S+_*b,M=Math.cos(this.camera.rotationX),R=Math.sin(this.camera.rotationX),k=v*M-T*R,D=v*R+T*M;return{...w,nx:C,ny:k,nz:D,u:h.u,v:h.v}}),s=(e[0].nz+e[1].nz+e[2].nz+e[3].nz)/4;if(!this.doubleSided&&s>.1||((e[0].z+e[1].z+e[2].z+e[3].z)/4,e.some(h=>h.z<-this.camera.perspective+10)))return;if(this.useShader&&!this.debug){const h=e.map(D=>D.x),d=e.map(D=>D.y),g=Math.min(...h),m=Math.max(...h),p=Math.min(...d),v=Math.max(...d),_=m-g,w=v-p,b=(g+m)/2,S=(p+v)/2,C=y.ctx,T=C.getTransform(),M=T.e,R=T.f;C.save(),C.setTransform(1,0,0,1,0,0);const k=this._renderWithShader(C,M+b,R+S,_,w);if(C.restore(),k)return}const n=y.ctx;let r=(e[0].nx+e[1].nx+e[2].nx+e[3].nx)/4,o=(e[0].ny+e[1].ny+e[2].ny+e[3].ny)/4,a=r,l=o,c=s;this.doubleSided&&s>0&&(a=-r,l=-o,c=-s);const u=this._calculateLighting(a,l,c);for(const h of this.faces){const d=e[h[0]],g=e[h[1]],m=e[h[2]];if(this.debug)n.beginPath(),n.moveTo(d.x,d.y),n.lineTo(g.x,g.y),n.lineTo(m.x,m.y),n.closePath(),this.stroke&&(n.strokeStyle=this.stroke,n.lineWidth=this.lineWidth??1,n.stroke());else if(this.texture)this._renderTexturedTriangle(n,d,g,m);else if(this.color){const p=this._applyLighting(this.color,u);n.beginPath(),n.moveTo(d.x,d.y),n.lineTo(g.x,g.y),n.lineTo(m.x,m.y),n.closePath(),n.fillStyle=p,n.fill()}}}_renderTexturedTriangle(t,e,s,i){if(!this.texture||!this.texture.complete)return;const n=this.texture,r=n.width,o=n.height,a=e.u*r,l=e.v*o,c=s.u*r,u=s.v*o,h=i.u*r,d=i.v*o,g=e.x,m=e.y,p=s.x,v=s.y,_=i.x,w=i.y,b=(c-a)*(d-l)-(h-a)*(u-l);if(Math.abs(b)<1e-4)return;const S=((p-g)*(d-l)-(_-g)*(u-l))/b,C=((_-g)*(c-a)-(p-g)*(h-a))/b,T=g-S*a-C*l,M=((v-m)*(d-l)-(w-m)*(u-l))/b,R=((w-m)*(c-a)-(v-m)*(h-a))/b,k=m-M*a-R*l;t.save(),t.beginPath(),t.moveTo(g,m),t.lineTo(p,v),t.lineTo(_,w),t.closePath(),t.clip(),t.setTransform(S,M,C,R,T,k),t.drawImage(n,0,0),t.restore()}getCenter(){return{x:this.x,y:this.y,z:this.z}}getBounds(){return{x:this.x-this.planeWidth/2,y:this.y-this.planeHeight/2,width:this.planeWidth,height:this.planeHeight}}};I(Ve,"_glRenderer",null);I(Ve,"_glRendererSize",{width:0,height:0});class Ci extends ht{constructor(t,e={}){var s,i,n,r,o,a;super(e),this.size=t,this.x=e.x??0,this.y=e.y??0,this.z=e.z??0,this.camera=e.camera??null,this.debug=e.debug??!1,this.selfRotationX=e.selfRotationX??0,this.selfRotationY=e.selfRotationY??0,this.selfRotationZ=e.selfRotationZ??0,this.faceColors={front:((s=e.faceColors)==null?void 0:s.front)??"#B71234",back:((i=e.faceColors)==null?void 0:i.back)??"#FF5800",top:((n=e.faceColors)==null?void 0:n.top)??"#FFFFFF",bottom:((r=e.faceColors)==null?void 0:r.bottom)??"#FFD500",left:((o=e.faceColors)==null?void 0:o.left)??"#009B48",right:((a=e.faceColors)==null?void 0:a.right)??"#0046AD"},this.stroke=e.stroke??null,this.lineWidth=e.lineWidth??1,this.stickerMode=e.stickerMode??!1,this.stickerMargin=e.stickerMargin??.15,this.stickerBackgroundColor=e.stickerBackgroundColor??"#0A0A0A",this._faceConfigs=this._createFaceConfigs()}_createFaceConfigs(){const t=this.size/2;return{front:{localPos:{x:0,y:0,z:-t},faceRotX:0,faceRotY:0,color:this.faceColors.front},back:{localPos:{x:0,y:0,z:t},faceRotX:0,faceRotY:Math.PI,color:this.faceColors.back},top:{localPos:{x:0,y:-t,z:0},faceRotX:-Math.PI/2,faceRotY:0,color:this.faceColors.top},bottom:{localPos:{x:0,y:t,z:0},faceRotX:Math.PI/2,faceRotY:0,color:this.faceColors.bottom},left:{localPos:{x:-t,y:0,z:0},faceRotX:0,faceRotY:Math.PI/2,color:this.faceColors.left},right:{localPos:{x:t,y:0,z:0},faceRotX:0,faceRotY:-Math.PI/2,color:this.faceColors.right}}}setCamera(t){return this.camera=t,this}setFaceColors(t){Object.assign(this.faceColors,t);for(const[e,s]of Object.entries(this._faceConfigs))t[e]&&(s.color=t[e]);return this}_applySelfRotation(t,e,s){if(this.selfRotationY!==0){const i=Math.cos(this.selfRotationY),n=Math.sin(this.selfRotationY),r=t*i-s*n,o=t*n+s*i;t=r,s=o}if(this.selfRotationX!==0){const i=Math.cos(this.selfRotationX),n=Math.sin(this.selfRotationX),r=e*i-s*n,o=e*n+s*i;e=r,s=o}if(this.selfRotationZ!==0){const i=Math.cos(this.selfRotationZ),n=Math.sin(this.selfRotationZ),r=t*i-e*n,o=t*n+e*i;t=r,e=o}return{x:t,y:e,z:s}}_calculateLighting(t,e,s){const o=Math.sqrt(.99),a=.5/o,l=.7/o,c=.5/o;let u=t*a+e*l+s*c;return u=Math.max(0,u)*.7+.3,u}_applyLighting(t,e){if(!t||typeof t!="string"||!t.startsWith("#"))return t;const s=t.replace("#",""),i=parseInt(s.substring(0,2),16),n=parseInt(s.substring(2,4),16),r=parseInt(s.substring(4,6),16),o=Math.round(i*e),a=Math.round(n*e),l=Math.round(r*e);return`rgb(${o}, ${a}, ${l})`}draw(){if(super.draw(),!this.camera){const i=this.size/2;this.faceColors.front&&y.shapes.fillRect(-i,-i,this.size,this.size,this.faceColors.front);return}const t=y.ctx;this.size/2;const e=this.selfRotationX!==0||this.selfRotationY!==0||this.selfRotationZ!==0,s=[];for(const[i,n]of Object.entries(this._faceConfigs)){let{x:r,y:o,z:a}=n.localPos;if(e){const A=this._applySelfRotation(r,o,a);r=A.x,o=A.y,a=A.z}const l=this.x+r,c=this.y+o,u=this.z+a;let h=0,d=0,g=0;if(i==="front"?(h=0,d=0,g=-1):i==="back"?(h=0,d=0,g=1):i==="top"?(h=0,d=-1,g=0):i==="bottom"?(h=0,d=1,g=0):i==="left"?(h=-1,d=0,g=0):i==="right"&&(h=1,d=0,g=0),e){const A=this._applySelfRotation(h,d,g);h=A.x,d=A.y,g=A.z}let m=h,p=d,v=g;if(this.camera.rotationZ!==0){const A=Math.cos(this.camera.rotationZ),P=Math.sin(this.camera.rotationZ),E=m,F=p;m=E*A-F*P,p=E*P+F*A}const _=Math.cos(this.camera.rotationY),w=Math.sin(this.camera.rotationY),b=m*_-v*w,S=m*w+v*_,C=Math.cos(this.camera.rotationX),T=Math.sin(this.camera.rotationX),M=p*C-S*T,R=p*T+S*C;if(R>.01)continue;const k=this.camera.project(l,c,u);if(k.z<-this.camera.perspective+10)continue;const D=this._calculateLighting(b,M,R),z=this._getFaceVertices(i,n,e);s.push({name:i,config:n,projected:k,vertices:z,depth:k.z,intensity:D,nx:b,ny:M,nz:R})}s.sort((i,n)=>n.depth-i.depth);for(const i of s)this._renderFace(t,i)}_getFaceVertices(t,e,s){const i=this.size/2;let n;switch(t){case"front":n=[{x:-i,y:-i,z:-i},{x:i,y:-i,z:-i},{x:i,y:i,z:-i},{x:-i,y:i,z:-i}];break;case"back":n=[{x:i,y:-i,z:i},{x:-i,y:-i,z:i},{x:-i,y:i,z:i},{x:i,y:i,z:i}];break;case"top":n=[{x:-i,y:-i,z:i},{x:i,y:-i,z:i},{x:i,y:-i,z:-i},{x:-i,y:-i,z:-i}];break;case"bottom":n=[{x:-i,y:i,z:-i},{x:i,y:i,z:-i},{x:i,y:i,z:i},{x:-i,y:i,z:i}];break;case"left":n=[{x:-i,y:-i,z:i},{x:-i,y:-i,z:-i},{x:-i,y:i,z:-i},{x:-i,y:i,z:i}];break;case"right":n=[{x:i,y:-i,z:-i},{x:i,y:-i,z:i},{x:i,y:i,z:i},{x:i,y:i,z:-i}];break}return n.map(r=>{let{x:o,y:a,z:l}=r;if(s){const c=this._applySelfRotation(o,a,l);o=c.x,a=c.y,l=c.z}return o+=this.x,a+=this.y,l+=this.z,this.camera.project(o,a,l)})}_renderFace(t,e){const{vertices:s,config:i,intensity:n}=e,r=this._applyLighting(i.color,n);t.beginPath(),t.moveTo(s[0].x,s[0].y);for(let o=1;o<s.length;o++)t.lineTo(s[o].x,s[o].y);if(t.closePath(),this.debug)t.strokeStyle=this.stroke||"#fff",t.lineWidth=this.lineWidth??1,t.stroke();else if(this.stickerMode){const o=this._applyLighting(this.stickerBackgroundColor,n);t.fillStyle=o,t.fill(),this.stroke&&(t.strokeStyle=this.stroke,t.lineWidth=this.lineWidth??1,t.stroke());const a=this._getInsetVertices(s,this.stickerMargin);t.beginPath(),t.moveTo(a[0].x,a[0].y);for(let l=1;l<a.length;l++)t.lineTo(a[l].x,a[l].y);t.closePath(),t.fillStyle=r,t.fill()}else t.fillStyle=r,t.fill(),this.stroke&&(t.strokeStyle=this.stroke,t.lineWidth=this.lineWidth??1,t.stroke())}_getInsetVertices(t,e){let s=0,i=0;for(const r of t)s+=r.x,i+=r.y;s/=t.length,i/=t.length;const n=1-e*2;return t.map(r=>({x:s+(r.x-s)*n,y:i+(r.y-i)*n}))}getCenter(){return{x:this.x,y:this.y,z:this.z}}getBounds(){const t=this.size/2;return{x:this.x-t,y:this.y-t,width:this.size,height:this.size}}}class Ri extends ht{constructor(t,e,s={}){super(s),this.outerRadius=t,this.innerRadius=e}draw(){super.draw(),y.lines.beginPath(),y.shapes.arc(0,0,this.outerRadius,0,Math.PI*2),y.shapes.arc(0,0,this.innerRadius,0,Math.PI*2,!0),y.lines.closePath(),this.color&&y.colors.fill(this.color),this.stroke&&y.colors.stroke(this.stroke,this.lineWidth)}}class Ti extends ht{constructor(t,e,s,i={}){super(i),this.radius=t,this.startAngle=e,this.endAngle=s}draw(){super.draw(),y.lines.beginPath(),y.lines.moveTo(0,0),y.shapes.arc(0,0,this.radius,this.startAngle,this.endAngle),y.lines.closePath(),this.color&&y.colors.fill(this.color),this.stroke&&y.colors.stroke(this.stroke,this.lineWidth)}}class Is extends ht{constructor(t,e={}){super(e),this._text=t,this._font=e.font||"12px monospace",this._color=e.color||"yellow",this._align=e.align||"center",this._baseline=e.baseline||"middle",this._calculateBounds(),this._calculateAlignmentOffsets()}draw(){super.draw(),this.logger.log("draw",this.font,this.color,this.opacity),y.text.setFont(this.font),y.text.setTextAlign(this.align),y.text.setTextBaseline(this.baseline),y.text.fillText(this.text,0,0,this.color)}_calculateAlignmentOffsets(){if(!y.text)return;const t=y.text.measureTextDimensions(this.text,this.font);switch(this._align){case"left":this._centerOffsetX=t.width/2;break;case"center":this._centerOffsetX=0;break;case"right":this._centerOffsetX=-t.width/2-5;break}switch(this._baseline){case"top":this._centerOffsetY=t.height/4;break;case"middle":this._centerOffsetY=-2;break;case"bottom":this._centerOffsetY=-t.height;break}}getTextBounds(){if(y.text){const t=y.text.measureTextDimensions(this.text,this.font),e=2;return{x:this._centerOffsetX-t.width/2,y:this._centerOffsetY-t.height/2,width:t.width+e*2,height:t.height+e*2}}return{x:this._centerOffsetX,y:this._centerOffsetY,width:this._width,height:this._height}}_calculateBounds(){if(y.text){const t=y.text.measureTextDimensions(this.text,this.font);this._width=t.width,this._height=t.height,this._calculateAlignmentOffsets()}else this._width=this.text?this.text.length*8:0,this._height=16;this.trace("TextShape.calculateBounds: "+this._width+"x"+this._height)}getDebugBounds(){const t=this.getTextBounds();return{x:t.x,y:t.y,width:t.width,height:t.height}}checkDirty(t,e){t!==e&&(this._boundsDirty=!0,this._calculateBounds())}get text(){return this._text}set text(t){this.checkDirty(t,this._text),this._text=t}get font(){return this._font}set font(t){this.checkDirty(t,this._font),this._font=t}get color(){return this._color}set color(t){this._color=t}get align(){return this._align}set align(t){this.checkDirty(t,this._align),this._align=t}get baseline(){return this._baseline}set baseline(t){this.checkDirty(t,this._baseline),this._baseline=t}}class be extends ht{constructor(t,e={}){if(!t&&!e.width&&!e.height)throw new Error("ImageShape must be initialized with either a bitmap or width and height");super(e),this._bitmap=t??y.img.createImageData(e.width,e.height),this._width=e.width??(t==null?void 0:t.width)??0,this._height=e.height??(t==null?void 0:t.height)??0,this.anchor=e.anchor??"center",this._anchorX=.5,this._anchorY=.5,this._updateAnchorOffsets(),this.smoothing=e.smoothing!==!1,t instanceof ImageData&&this.buffer(t)}_updateAnchorOffsets(){var t;const e=((t=this.anchor)==null?void 0:t.toLowerCase())??"center";e.includes("left")?this._anchorX=0:e.includes("right")?this._anchorX=1:this._anchorX=.5,e.includes("top")?this._anchorY=0:e.includes("bottom")?this._anchorY=1:this._anchorY=.5}get bitmap(){return this._bitmap}set bitmap(t){t&&(this._bitmap=t,!this._width&&t.width&&(this._width=t.width),!this._height&&t.height&&(this._height=t.height),t instanceof ImageData&&this.buffer(t))}buffer(t){if(!t)return;this._buffer||(this._buffer=document.createElement("canvas")),(this._buffer.width!==t.width||this._buffer.height!==t.height)&&(this._buffer.width=t.width,this._buffer.height=t.height),this._buffer.getContext("2d").putImageData(t,0,0)}reset(){this._buffer=null,this._bitmap=y.img.createImageData(this.width,this.height)}setAnchor(t){this.anchor=t,this._updateAnchorOffsets()}draw(){if(!this.visible||!this._bitmap&&!this._buffer)return;super.draw();let t=this._bitmap instanceof ImageData?this._buffer:this._bitmap;(!t||this._bitmap instanceof ImageData&&!this._buffer)&&(this._bitmap instanceof ImageData&&(this.buffer(this._bitmap),t=this._buffer),!t)||y.img.draw(t,0,0,{width:this.width,height:this.height,anchor:this.anchor,rotation:this.rotation,scaleX:this.scaleX,scaleY:this.scaleY,alpha:this.opacity,smoothing:this.smoothing,flipX:this.scaleX<0,flipY:this.scaleY<0})}calculateBounds(){return{x:-this._anchorX*this.width,y:-this._anchorY*this.height,width:this.width,height:this.height}}}class $e{constructor(){this.listeners={}}on(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}off(t,e){this.listeners[t]&&(this.listeners[t]=this.listeners[t].filter(s=>s!==e))}emit(t,e){this.listeners[t]&&this.listeners[t].forEach(s=>s(e))}}class W{static init(t){W.game=t,W.x=0,W.y=0,W.down=!1,t.events.on("mousedown",e=>W._onDown(e,t)),t.events.on("mouseup",e=>W._onUp(e,t)),t.events.on("mousemove",e=>W._onMove(e,t)),t.events.on("touchstart",e=>W._onTouchStart(e,t)),t.events.on("touchend",e=>W._onTouchEnd(e,t)),t.events.on("touchmove",e=>W._onTouchMove(e,t))}static _scaleToCanvas(t,e,s){const i=t.canvas,n=i.getBoundingClientRect(),r=i.width/n.width,o=i.height/n.height;return{x:e*r,y:s*o}}static _setPosition(t,e){W.x=t,W.y=e}static _onDown(t,e){W.down=!0;const s=W._scaleToCanvas(e,t.offsetX,t.offsetY);W._setPosition(s.x,s.y),Object.defineProperty(t,"x",{value:s.x,configurable:!0}),Object.defineProperty(t,"y",{value:s.y,configurable:!0}),e.events.emit("inputdown",t)}static _onUp(t,e){W.down=!1;const s=W._scaleToCanvas(e,t.offsetX,t.offsetY);W._setPosition(s.x,s.y),Object.defineProperty(t,"x",{value:s.x,configurable:!0}),Object.defineProperty(t,"y",{value:s.y,configurable:!0}),e.events.emit("inputup",t)}static _onMove(t,e){const s=W._scaleToCanvas(e,t.offsetX,t.offsetY);W._setPosition(s.x,s.y),Object.defineProperty(t,"x",{value:s.x,configurable:!0}),Object.defineProperty(t,"y",{value:s.y,configurable:!0}),e.events.emit("inputmove",t)}static _onTouchStart(t,e){const s=t.touches[0],i=e.canvas.getBoundingClientRect();W.down=!0;const n=s.clientX-i.left,r=s.clientY-i.top,o=W._scaleToCanvas(e,n,r);W._setPosition(o.x,o.y),Object.defineProperty(t,"x",{value:o.x,configurable:!0}),Object.defineProperty(t,"y",{value:o.y,configurable:!0}),e.events.emit("inputdown",t)}static _onTouchEnd(t,e){W.down=!1,e.events.emit("inputup",t)}static _onTouchMove(t,e){const s=t.touches[0],i=e.canvas.getBoundingClientRect(),n=s.clientX-i.left,r=s.clientY-i.top,o=W._scaleToCanvas(e,n,r);W._setPosition(o.x,o.y),Object.defineProperty(t,"x",{value:o.x,configurable:!0}),Object.defineProperty(t,"y",{value:o.y,configurable:!0}),e.events.emit("inputmove",t)}}const q=class et{static init(t){et._gameMap.set(t.canvas,t),et.game=t,et.canvas=t.canvas,et.x=0,et.y=0,et.leftDown=!1,et.middleDown=!1,et.rightDown=!1,t.canvas.addEventListener("mousemove",et._onMove),t.canvas.addEventListener("mousedown",et._onDown),t.canvas.addEventListener("mouseup",et._onUp),t.canvas.addEventListener("click",et._onClick),t.canvas.addEventListener("wheel",et._onWheel)}static _getGameForEvent(t){const e=t.currentTarget;return et._gameMap.get(e)||et.game}static _updatePosition(t,e){const s=e.canvas,i=s.getBoundingClientRect(),n=t.clientX-i.left,r=t.clientY-i.top,o=s.width/i.width,a=s.height/i.height;et.x=n*o,et.y=r*a}};I(q,"_gameMap",new Map);I(q,"_onMove",f=>{const t=q._getGameForEvent(f);q._updatePosition(f,t),t.events.emit("mousemove",f)});I(q,"_onDown",f=>{const t=q._getGameForEvent(f);q._updatePosition(f,t),f.button===0&&(q.leftDown=!0),f.button===1&&(q.middleDown=!0),f.button===2&&(q.rightDown=!0),t.events.emit("mousedown",f)});I(q,"_onUp",f=>{const t=q._getGameForEvent(f);q._updatePosition(f,t),f.button===0&&(q.leftDown=!1),f.button===1&&(q.middleDown=!1),f.button===2&&(q.rightDown=!1),t.events.emit("mouseup",f)});I(q,"_onClick",f=>{const t=q._getGameForEvent(f);q._updatePosition(f,t),f.canvasX=q.x,f.canvasY=q.y,Object.defineProperty(f,"x",{value:q.x,writable:!1}),Object.defineProperty(f,"y",{value:q.y,writable:!1}),t.events.emit("click",f)});I(q,"_onWheel",f=>{const t=q._getGameForEvent(f);q._updatePosition(f,t),t.events.emit("wheel",f)});let zs=q;const X=class rt{static init(t){rt.game=t,window.addEventListener("keydown",rt._onKeyDown),window.addEventListener("keyup",rt._onKeyUp)}static isDown(t){return rt._down.has(t)}static _onKeyDown(t){const e=rt._codeMap[t.code];e&&(rt._down.has(e)||(rt._down.add(e),rt.game.events.emit(e,t))),rt.game.events.emit(t.type,t)}static _onKeyUp(t){const e=rt._codeMap[t.code];e&&rt._down.has(e)&&(rt._down.delete(e),rt.game.events.emit(e+"_up",t)),rt.game.events.emit(t.type,t)}};I(X,"W","W");I(X,"A","A");I(X,"S","S");I(X,"D","D");I(X,"Q","Q");I(X,"E","E");I(X,"R","R");I(X,"F","F");I(X,"Z","Z");I(X,"C","C");I(X,"UP","UP");I(X,"DOWN","DOWN");I(X,"LEFT","LEFT");I(X,"RIGHT","RIGHT");I(X,"SPACE","SPACE");I(X,"SHIFT","SHIFT");I(X,"ENTER","ENTER");I(X,"ESC","ESC");I(X,"_codeMap",{KeyW:X.W,KeyA:X.A,KeyS:X.S,KeyD:X.D,KeyQ:X.Q,KeyE:X.E,KeyR:X.R,KeyF:X.F,KeyZ:X.Z,KeyC:X.C,ArrowUp:X.UP,ArrowDown:X.DOWN,ArrowLeft:X.LEFT,ArrowRight:X.RIGHT,Space:X.SPACE,ShiftLeft:X.SHIFT,ShiftRight:X.SHIFT,Enter:X.ENTER,NumpadEnter:X.ENTER,Escape:X.ESC});I(X,"_down",new Set);I(X,"game",null);let Es=X;const _t=class at{static init(t){at._gameMap.set(t.canvas,t),at.game=t,at.canvas=t.canvas,at.x=0,at.y=0,at.active=!1,t.canvas.addEventListener("touchstart",at._onStart),t.canvas.addEventListener("touchend",at._onEnd),t.canvas.addEventListener("touchmove",at._onMove)}static _getGameForEvent(t){const e=t.currentTarget;return at._gameMap.get(e)||at.game}static _updatePosition(t,e){const s=e.canvas,i=s.getBoundingClientRect(),n=t.clientX-i.left,r=t.clientY-i.top,o=s.width/i.width,a=s.height/i.height;at.x=n*o,at.y=r*a}};I(_t,"_gameMap",new Map);I(_t,"_onStart",f=>{if(f.touches.length>0){const t=_t._getGameForEvent(f);_t.active=!0,_t._updatePosition(f.touches[0],t),t.events.emit("touchstart",f)}});I(_t,"_onEnd",f=>{const t=_t._getGameForEvent(f);_t.active=!1,t.events.emit("touchend",f)});I(_t,"_onMove",f=>{if(f.touches.length>0){const t=_t._getGameForEvent(f);_t._updatePosition(f.touches[0],t),t.events.emit("touchmove",f)}});let Xs=_t;function Ys(f,t={}){var e;if(!f||!(f instanceof Vt))return console.warn("applyAnchor can only be applied to GameObject instances"),f;f._anchor={position:t.anchor??null,margin:t.anchorMargin??10,offsetX:t.anchorOffsetX??0,offsetY:t.anchorOffsetY??0,relative:t.anchorRelative??!1,setTextAlign:t.anchorSetTextAlign!==!1,lastUpdate:0};const s=(e=f.update)==null?void 0:e.bind(f);f.update=function(n){const r=f._anchor.relative===!0&&f.parent?f.parent:f._anchor.relative;if(f._anchor.position&&(f.boundsDirty||r&&r.boundsDirty||f.parent&&f.parent.boundsDirty)){let o;if(r){const c={x:r.x,y:r.y,width:r.width,height:r.height};o=ze.calculate(f._anchor.position,f,c,f._anchor.margin,f._anchor.offsetX,f._anchor.offsetY)}else o=ze.calculateAbsolute(f._anchor.position,f,f.game,f._anchor.margin,f._anchor.offsetX,f._anchor.offsetY);let a,l;f.parent&&!i(f)?r===f.parent?(a=o.x-r.x,l=o.y-r.y):(a=o.x-f.parent.x,l=o.y-f.parent.y):(a=o.x,l=o.y),f.transform&&typeof f.transform.position=="function"?f.transform.position(a,l):(f.x=a,f.y=l),f._anchor.setTextAlign&&("align"in f&&(f.align=o.align),"baseline"in f&&(f.baseline=o.baseline)),f._anchor.lastUpdate=f.game?f.game.lastTime:Date.now()}s&&s(n)};function i(n){return n.game&&n.game.pipeline&&n.game.pipeline.gameObjects&&n.game.pipeline.gameObjects.includes(n)}return f}class Vt extends ue{constructor(t,e={}){super(e),this.game=t,this.parent=null,this.events=new $e,this._interactive=e.interactive??!1,this._hovered=!1,e.anchor&&Ys(this,e)}update(t){this.logger.groupCollapsed("GameObject.update: "+(this.name==null?this.constructor.name:this.name)),super.update(t),this.logger.groupEnd()}get interactive(){return this._interactive}set interactive(t){const e=!!t;this._interactive!==e&&(this._interactive=e,e===!0?this._enableEvents():(this._disableEvents(),this._hovered&&(this._hovered=!1,this.events.emit("mouseout"))))}_enableEvents(){this.logger.log(`${this.constructor.name} is now interactive`)}_disableEvents(){this.logger.log(`${this.constructor.name} is no longer interactive`)}get hovered(){return this._hovered}set hovered(t){this._hovered=!!t}_setHovered(t){this._hovered=!!t}_hitTest(t,e){var s;if(!this._interactive)return!1;const i=(s=this.getBounds)==null?void 0:s.call(this);if(!i)return!1;let n=t,r=e;const o=[];let a=this;for(;a;)o.unshift(a),a=a.parent;for(const u of o){if(n-=u.x||0,r-=u.y||0,u.rotation){const h=Math.cos(-u.rotation),d=Math.sin(-u.rotation),g=n;n=g*h-r*d,r=g*d+r*h}u.scaleX!==void 0&&u.scaleX!==0&&(n/=u.scaleX),u.scaleY!==void 0&&u.scaleY!==0&&(r/=u.scaleY)}const l=(i.width||this.width||0)/2,c=(i.height||this.height||0)/2;return n>=-l&&n<=l&&r>=-c&&r<=c}on(t,e){this.events.on(t,e)}off(t,e){this.events.off(t,e)}emit(t,...e){this.events.emit(t,...e)}}class Bs extends Vt{constructor(t,e,s={}){const{anchor:i,...n}=s;if(super(t,n),!e||e==null||e==null)throw new Error("GameObjectShapeWrapper requires a shape");this.shape=e,s.color!==void 0&&(e.color=s.color),s.stroke!==void 0&&(e.stroke=s.stroke),s.lineWidth!==void 0&&(e.lineWidth=s.lineWidth),s.lineJoin!==void 0&&(e.lineJoin=s.lineJoin),s.lineCap!==void 0&&(e.lineCap=s.lineCap),s.miterLimit!==void 0&&(e.miterLimit=s.miterLimit),this.syncPropertiesToShape(),this.logger.log(`Created GameObject(${this.constructor.name}):`,{x:this.x,y:this.y,width:this.width,height:this.height,color:this.color,stroke:this.stroke})}syncPropertiesToShape(){if(!this.shape)return;const t=["width","height","rotation","scaleX","scaleY","visible","debug","debugColor"];for(const e of t)e in this&&e in this.shape&&this[e]!==this.shape[e]&&(this.shape[e]=this[e])}get color(){return this.shape?this.shape.color:null}set color(t){this.shape&&(this.shape.color=t)}get stroke(){return this.shape?this.shape.stroke:null}set stroke(t){this.shape&&(this.shape.stroke=t)}get lineWidth(){return this.shape?this.shape.lineWidth:1}set lineWidth(t){this.shape&&(this.shape.lineWidth=t)}get lineJoin(){return this.shape?this.shape.lineJoin:"miter"}set lineJoin(t){this.shape&&(this.shape.lineJoin=t)}get lineCap(){return this.shape?this.shape.lineCap:"butt"}set lineCap(t){this.shape&&(this.shape.lineCap=t)}get miterLimit(){return this.shape?this.shape.miterLimit:10}set miterLimit(t){this.shape&&(this.shape.miterLimit=t)}update(t){var e;this.active&&((e=this.onUpdate)==null||e.call(this,t),(this._boundsDirty||this.tweening)&&(this.syncPropertiesToShape(),this._boundsDirty=!1),super.update(t))}draw(){super.draw(),this.shape.draw()}}class Kt extends Vt{constructor(t,e={}){super(t,e),this._collection=new Te({sortByZIndex:e.sortByZIndex||!0}),this._collection._owner=this,this._width=e.width??0,this._height=e.height??0,this.forceWidth=null,this.forceHeight=null,this._naturalWidth=null,this._naturalHeight=null,this.userDefinedDimensions=!1,e.width!=null&&e.height!=null&&(this.userDefinedWidth=e.width,this.userDefinedHeight=e.height,this.userDefinedDimensions=!0)}update(t){this.logger.groupCollapsed("Scene.update: "+(this.name==null?this.constructor.name:this.name));for(let e=0;e<this.children.length;e++){const s=this.children[e];s.active&&s.update&&s.update(t)}super.update(t),this.logger.groupEnd()}add(t){if(t==null||t==null)throw new Error("GameObject is null or undefined");return t.parent!=null&&console.warn("This GameObject already has a parent. Consider removing it first."),t.parent=this,this._collection.add(t),this.markBoundsDirty(),t.init&&t.init(),t}markBoundsDirty(){super.markBoundsDirty(),this.children.forEach(t=>{t.markBoundsDirty()})}remove(t){const e=this._collection.remove(t);return e&&(t.parent=null,this.markBoundsDirty()),e}draw(){super.draw(),this.logger.log("Scene.draw chilren:"),this._collection.getSortedChildren().filter(t=>t.visible).map(function(t){return y.save(),t.render(),y.restore(),t})}getDebugBounds(){return{width:this.width,height:this.height,x:-this.width/2,y:-this.height/2}}getBounds(){return{x:this.x,y:this.y,width:this._width||0,height:this._height||0}}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}clear(){return this._collection.children.forEach(t=>this.remove(t)),this._collection.clear()}get children(){return this._collection.children}}class ki extends Kt{constructor(t,e={}){super(t,e),this.tileWidth=e.tileWidth??64,this.tileHeight=e.tileHeight??this.tileWidth/2,this.depthSort=e.depthSort??!0,this.scaleByDepth=e.scaleByDepth??!1,this.gridSize=e.gridSize??10,this.elevationScale=e.elevationScale??1,this.camera=e.camera??null}setCamera(t){return this.camera=t,this}toIsometric(t,e,s=0){let i=t,n=e;if(this.camera){const l=this.camera.angle,c=Math.cos(l),u=Math.sin(l);i=t*c-e*u,n=t*u+e*c}const r=(i-n)*(this.tileWidth/2),o=(i+n)*(this.tileHeight/2)-s*this.elevationScale,a=i+n-s*.01;return{x:r,y:o,depth:a}}fromIsometric(t,e){const s=this.tileWidth/2,i=this.tileHeight/2;let n=(t/s+e/i)/2,r=(e/i-t/s)/2;if(this.camera){const o=-this.camera.angle,a=Math.cos(o),l=Math.sin(o),c=n*a-r*l,u=n*l+r*a;return{x:c,y:u}}return{x:n,y:r}}update(t){super.update(t),this.camera&&this.camera.update(t)}getTileAt(t,e){const s=this.fromIsometric(t,e);return{x:Math.floor(s.x),y:Math.floor(s.y)}}getRotatedDepth(t,e=0){const s=this.camera?this.camera.angle:0,i=Math.cos(s),n=Math.sin(s);let r=-1/0;for(const o of t){const a=o.x*i-o.y*n,l=o.x*n+o.y*i,c=a+l;c>r&&(r=c)}return r+e*.5}getDepthScale(t){const e=Math.abs(t),s=this.gridSize;return .7+e/s*.6}render(){if(!this.visible)return;y.save(),y.translateTo(this.x,this.y);const t=[];for(const e of this._collection.getSortedChildren()){if(!e.visible)continue;let s;if(e.isoDepth!==void 0)s=e.isoDepth;else{let i=e.x,n=e.y;if(this.camera){const o=this.camera.angle,a=Math.cos(o),l=Math.sin(o);i=e.x*a-e.y*l,n=e.x*l+e.y*a}const r=e.z??0;s=i+n+r*.05}t.push({child:e,depth:s})}this.depthSort&&t.sort((e,s)=>{const i=e.child.zIndex??0,n=s.child.zIndex??0;return i!==n?i-n:e.depth-s.depth});for(const e of t)y.save(),e.child.render(),y.restore();y.restore()}}class Os extends Vt{constructor(t,e={}){super(t,e),this._frames=[],this._currentFrame=0,this._frameAccumulator=0,this._isPlaying=e.autoPlay||!1,this._loop=e.loop!==void 0?e.loop:!0,this._frameRate=e.frameRate||12,this._frameDuration=1/this._frameRate,this._animations=new Map,this._currentAnimation=null,e.frames&&Array.isArray(e.frames)&&e.frames.forEach(s=>this.addFrame(s))}addAnimation(t,e,s={}){if(!t||typeof t!="string")throw new Error("Sprite.addAnimation: name is required");if(!e||!Array.isArray(e)||e.length===0)throw new Error("Sprite.addAnimation: frames array is required");return e.forEach(i=>{i.parent=this}),this._animations.set(t,{frames:e,loop:s.loop!==void 0?s.loop:!0,frameRate:s.frameRate||null}),this}removeAnimation(t){const e=this._animations.get(t);return e?(e.frames.forEach(s=>{s.parent=null}),this._animations.delete(t),this._currentAnimation===t&&(this._currentAnimation=null,this._frames=[]),!0):!1}playAnimation(t,e=!1){const s=this._animations.get(t);return s?this._currentAnimation===t&&this._isPlaying&&!e?this:(this._currentAnimation=t,this._frames=s.frames,this._loop=s.loop,s.frameRate!==null&&(this._frameRate=s.frameRate,this._frameDuration=1/this._frameRate),this._currentFrame=0,this._frameAccumulator=0,this._isPlaying=!0,this):(console.warn(`Sprite.playAnimation: animation '${t}' not found`),this)}stopAnimation(t){const e=this._animations.get(t);return e?(this._currentAnimation=t,this._frames=e.frames,this._loop=e.loop,this._currentFrame=0,this._frameAccumulator=0,this._isPlaying=!1,this):(console.warn(`Sprite.stopAnimation: animation '${t}' not found`),this)}get currentAnimationName(){return this._currentAnimation}get animationNames(){return Array.from(this._animations.keys())}hasAnimation(t){return this._animations.has(t)}addFrame(t){if(!t)throw new Error("Sprite.addFrame: shape is required");return t.parent=this,this._frames.push(t),this.markBoundsDirty(),this._frames.length-1}removeFrame(t){if(t<0||t>=this._frames.length)return null;const e=this._frames.splice(t,1)[0];return e&&(e.parent=null,this.markBoundsDirty(),this._currentFrame>=this._frames.length&&this._frames.length>0&&(this._currentFrame=this._frames.length-1)),e}clearFrames(){this._frames.forEach(t=>{t.parent=null}),this._frames=[],this._currentFrame=0,this.markBoundsDirty()}get totalFrames(){return this._frames.length}get currentFrame(){return this._currentFrame}get currentShape(){return this._frames[this._currentFrame]||null}get frames(){return this._frames}get isPlaying(){return this._isPlaying}get loop(){return this._loop}set loop(t){this._loop=t}get frameRate(){return this._frameRate}set frameRate(t){if(t<=0)throw new Error("Sprite.frameRate must be greater than 0");this._frameRate=t,this._frameDuration=1/t}play(){return this._isPlaying=!0,this}pause(){return this._isPlaying=!1,this}stop(){return this._isPlaying=!1,this._currentFrame=0,this._frameAccumulator=0,this}rewind(){return this._currentFrame=0,this._frameAccumulator=0,this}goto(t){return this._frames.length===0?this:(this._currentFrame=Math.max(0,Math.min(t,this._frames.length-1)),this._frameAccumulator=0,this)}gotoAndStop(t){return this.goto(t),this.pause(),this}gotoAndPlay(t){return this.goto(t),this.play(),this}update(t){if(super.update(t),!this._isPlaying||this._frames.length===0)return;for(this._frameAccumulator+=t;this._frameAccumulator>=this._frameDuration;)this._frameAccumulator-=this._frameDuration,this._advanceFrame();const e=this.currentShape;e&&typeof e.update=="function"&&e.update(t)}_advanceFrame(){this._currentFrame++,this._currentFrame>=this._frames.length&&(this._loop?this._currentFrame=0:(this._currentFrame=this._frames.length-1,this._isPlaying=!1))}draw(){super.draw();const t=this.currentShape;t&&t.visible!==!1&&(y.save(),t.render(),y.restore())}calculateBounds(){if(this._frames.length===0)return{x:this.x,y:this.y,width:0,height:0};let t=1/0,e=1/0,s=-1/0,i=-1/0;return this._frames.forEach(n=>{const r=n.getBounds();t=Math.min(t,r.x),e=Math.min(e,r.y),s=Math.max(s,r.x+r.width),i=Math.max(i,r.y+r.height)}),{x:t+this.x,y:e+this.y,width:s-t,height:i-e}}toString(){return`[Sprite frames=${this.totalFrames} current=${this.currentFrame} playing=${this.isPlaying}]`}}class je extends Os{constructor(t,e={}){super(t,{frameRate:e.frameRate||12,loop:e.loop!==void 0?e.loop:!0,autoPlay:!1,...e}),this._src=e.src,this._frameWidth=e.frameWidth,this._frameHeight=e.frameHeight,this._columns=e.columns,this._rows=e.rows,this._frameCount=e.frameCount||e.columns*e.rows,this._startFrame=e.startFrame||0,this._smoothing=e.smoothing!==void 0?e.smoothing:!1,this._autoPlayAfterLoad=e.autoPlay||!1,this._loaded=!1,this._loading=!1,this._image=null,this._frameCanvases=[],this.width=this._frameWidth,this.height=this._frameHeight}static async create(t,e){const s=new je(t,e);return await s.load(),s}async load(){if(this._loaded||this._loading)return this;this._loading=!0;try{return this._image=await this._loadImage(this._src),await this._sliceFrames(),this._loaded=!0,this._loading=!1,this._autoPlayAfterLoad&&this.play(),this}catch(t){throw this._loading=!1,console.error("SpriteSheet.load failed:",t),t}}_loadImage(t){return new Promise((e,s)=>{const i=new Image;i.onload=()=>e(i),i.onerror=n=>s(new Error(`Failed to load image: ${t}`)),i.src=t})}async _sliceFrames(){const{_image:t,_frameWidth:e,_frameHeight:s,_columns:i}=this;this.clearFrames(),this._frameCanvases=[];for(let n=this._startFrame;n<this._startFrame+this._frameCount;n++){const r=n%i,o=Math.floor(n/i),a=r*e,l=o*s,c=document.createElement("canvas");c.width=e,c.height=s;const u=c.getContext("2d");u.imageSmoothingEnabled=this._smoothing,u.drawImage(t,a,l,e,s,0,0,e,s),this._frameCanvases.push(c);const h=new be(c,{width:e,height:s,anchor:"center",smoothing:this._smoothing});this.addFrame(h)}}get loaded(){return this._loaded}get loading(){return this._loading}get frameWidth(){return this._frameWidth}get frameHeight(){return this._frameHeight}get columns(){return this._columns}get rows(){return this._rows}update(t){this._loaded&&super.update(t)}draw(){this._loaded&&super.draw()}toString(){return`[SpriteSheet src="${this._src}" frames=${this._frameCount} loaded=${this._loaded}]`}}class Ai extends Bs{constructor(t,e,s={}){const i=e instanceof be?e:new be(e,s);super(t,i,s)}reset(){this.shape.reset()}}class At{static lerp(t,e,s){return t+(e-t)*s}static lerpAngle(t,e,s){let i=e-t;for(;i<-Math.PI;)i+=Math.PI*2;for(;i>Math.PI;)i-=Math.PI*2;return t+i*s}static tweenColor(t,e,s){return t.map((i,n)=>At.lerp(i,e[n],s))}static tweenGradient(t,e,s){let i=t[0],n=e[0];Math.abs(n-i)>180&&(i<n?i+=360:n+=360);const r=At.lerp(i,n,s)%360,o=At.lerp(t[1],e[1],s),a=At.lerp(t[2],e[2],s);return[r,o,a]}}function Fs(f,t,e,s,i,n=!1,r=null,o={},a=null){const{t:l,easedT:c,completed:u,state:h}=H._frame(s,i,n,r,o,a),d=1/(e+1),g=Math.min(Math.floor(c/d),e),m=c%d/d,p=f*Math.pow(.6,g),v=Math.sin(m*Math.PI),_=t-v*(t-p);return H.animationResult({y:_,segment:g,bounceHeight:p},l,n,u,h)}function Ls(f,t,e,s,i,n,r=!0,o=null,a={},l=null){if(e<=0)return H.animationResult({x:f.x,y:f.y,moving:!1},1,!1,!0);l||(l={initialX:f.x,initialY:f.y,started:!1,completed:!1,loopCount:0});const c=l.initialX,u=l.initialY,{t:h,easedT:d,completed:g,state:m}=H._frame(t,e,r,o,a,l);l={...l,...m};const p=t*s,v=Math.max(0,Math.min(1,i)),_=.7,w=.9,b=2.3,S=1.9,C=Math.sin(p*_)+v*.4*Math.sin(p*b+.5),T=Math.cos(p*w)+v*.4*Math.cos(p*S+.7),M=c+C*n,R=u+T*n,k=_*Math.cos(p*_)+v*.4*b*Math.cos(p*b+.5),D=-.9*Math.sin(p*w)+v*.4*-1.9*Math.sin(p*S+.7),z=Math.sqrt(k*k+D*D),A=z>.8,P=Math.sqrt((M-c)*(M-c)+(R-u)*(R-u));return H.animationResult({x:M,y:R,centerX:c,centerY:u,offsetX:M-c,offsetY:R-u,distance:P,moving:A,velocity:z},h,r,g,l)}function Ws(f,t=!1,e,s,i=!1,n=null,r={},o=null){if(!f||f.length<2)return this._createResult({x:0,y:0},0,i,!1);const{t:a,easedT:l,completed:c,state:u}=H._frame(e,s,i,n,r,o);if(!o||!o.pathData){const M={segmentLengths:[],totalLength:0,points:[...f]};for(let R=0;R<f.length-1;R++){const k=f[R],D=f[R+1],z=D[0]-k[0],A=D[1]-k[1],P=Math.sqrt(z*z+A*A);M.segmentLengths.push(P),M.totalLength+=P}if(t){const R=f[f.length-1],k=f[0],D=k[0]-R[0],z=k[1]-R[1],A=Math.sqrt(D*D+z*z);M.segmentLengths.push(A),M.totalLength+=A}u.pathData=M}const{segmentLengths:h,totalLength:d,points:g}=u.pathData,m=l*d;let p=0,v=0;for(let M=0;M<h.length;M++){if(p+h[M]>=m){v=M;break}p+=h[M]}const _=(m-p)/h[v],w=g[v],b=v<g.length-1?g[v+1]:g[0],S=At.lerp(w[0],b[0],_),C=At.lerp(w[1],b[1],_),T=Math.atan2(b[1]-w[1],b[0]-w[0]);return H.animationResult({x:S,y:C,angle:T,segmentIndex:v,segmentProgress:_,pathProgress:l},a,i,c,u)}function Ns(f,t,e,s,i,n,r,o=!0,a=!0,l=null,c={},u=null){const{t:h,easedT:d,completed:g,state:m}=H._frame(n,r,o,l,c,u),v=i+(a?1:-1)*d*Math.PI*2,_=f+e*Math.cos(v),w=t+s*Math.sin(v);return H.animationResult({x:_,y:w,angle:v},h,o,g,m)}function Hs(f,t,e,s,i=!0,n=null,r={},o=null){const{t:a,easedT:l,completed:c,state:u}=H._frame(e,s,i,n,r,o),h=(t-f)/2,g=f+h+h*Math.sin(l*Math.PI*2);return H.animationResult({value:g},a,i,c,u)}function Gs(f,t,e,s,i,n=!1,r=!1,o=null,a={},l=null){l||(l={started:!1,loopCount:0,direction:1,lastDirection:1,completed:!1});let c=i>0?s/i:1,u=!1,h={...a};if(r||n)if(n)if(r){const w=i*2,b=s%w,S=Math.floor(s/w),C=b<i?1:-1;c=C===1?b/i:2-b/i,C!==l.direction&&(l.direction=C,l.direction===1&&h.onLoop&&h.onLoop(S)),S>l.loopCount&&(l.loopCount=S)}else{c=c%1;const w=Math.floor(s/i);w>l.loopCount&&h.onLoop&&(h.onLoop(w),l.loopCount=w)}else r&&!n&&(c<=1?l.direction=1:c<=2?(c=2-c,l.direction=-1):(c=0,u=!0,l.direction=1));else c>=1&&(c=1,u=!0);!l.started&&h.onStart&&(h.onStart(),l.started=!0),u&&!l.completed&&h.onComplete&&(h.onComplete(),l.completed=!0);const d=o?o(c):c,g=f+e-2*t,m=2*(t-f),p=f,v=g*d*d+m*d+p,_={...l,lastDirection:l.direction,completed:u||l.completed};return H.animationResult({value:v,direction:l.direction},c,n||r&&!u,u,_)}function Us(f,t,e,s,i,n,r=!0,o=null){o||(o={currentX:f,currentY:t,targetX:f,targetY:t,isWaiting:!0,waitStartTime:0,moveStartTime:0,moveCount:0,direction:"idle"});const a=()=>Math.random();let l=o.isWaiting,c=o.currentX,u=o.currentY,h=o.direction;if(l){if(e-o.waitStartTime>=i){l=!1,o.moveStartTime=e,h=["up","down","left","right"][Math.floor(a()*4)];let v=o.currentX,_=o.currentY;const w=n*(.2+a()*.6);switch(h){case"up":_=o.currentY-w;break;case"down":_=o.currentY+w;break;case"left":v=o.currentX-w;break;case"right":v=o.currentX+w;break}Math.pow(v-f,2)+Math.pow(_-t,2)>n*n&&(h==="up"||h==="down"?(_=t,h=o.currentY>t?"up":"down"):(v=f,h=o.currentX>f?"left":"right")),o.targetX=v,o.targetY=_,o.direction=h,o.moveCount++}}else{const p=(e-o.moveStartTime)/s;p>=1?(l=!0,o.waitStartTime=e,o.currentX=o.targetX,o.currentY=o.targetY,h="idle"):(c=o.currentX+(o.targetX-o.currentX)*p,u=o.currentY+(o.targetY-o.currentY)*p)}o.isWaiting=l,o.direction=h,l||(o.currentX=c,o.currentY=u);const d=s+i,g=e%d/d,m=Math.sqrt(Math.pow(c-f,2)+Math.pow(u-t,2));return H.animationResult({x:c,y:u,moving:!l,direction:h,distanceFromCenter:m},g,r,!1,o)}function qs(f,t,e,s,i=!0,n=!1,r=null,o={},a=null){const{t:l,easedT:c,completed:u,state:h}=H._frame(e,s,i,null,o,a),d=n&&!i?Math.exp(-4*l):1;let g=f+t*Math.cos(c*2*Math.PI)*d;if(r){const m=(g-f)/(t*d);g=f+r((m+1)/2)*t*d*2-t*d}return H.animationResult({angle:g},l,i,u,h)}function Zs(f,t,e,s,i=!0,n=!1,r=null,o={}){let a=e/s,l="forward";if(i){const h=Math.floor(a);a=a%1,h>0&&o.onLoop&&o.onLoop(h)}else a>1&&(a=1);a>0&&e<=s&&o.onStart&&o.onStart();let c;if(n)if(a<.5){const h=a*2,d=r?r(h):h;c=f+(t-f)*d,l="forward"}else{const h=(a-.5)*2,d=r?r(h):h;c=t-(t-f)*d,l="return",a>=.5&&a<.51&&o.onYoyoTurn&&o.onYoyoTurn()}else{const h=r?r(a):a,d=h<.5?h*2:2-h*2;c=f+(t-f)*d}const u=!i&&a>=1;return u&&o.onComplete&&o.onComplete(),H.animationResult({value:c,phase:l},a,i,u)}function Vs(f,t,e,s,i=!0,n=!0,r=null,o={},a=null){const{t:l,easedT:c,completed:u,state:h}=H._frame(e,s,i,r,o,a,n);let d=0;!i&&!n?d=u?1:Math.sin(Math.min(l,1)*Math.PI*.5):n?d=Math.sin(c*Math.PI):d=Math.sin(Math.min(l,1)*Math.PI*.5);const g=f-t*d;return H.animationResult({y:g},l,i,u,h)}function $s(f,t,e,s,i,n,r,o,a=!1,l=null,c={},u=null){const{t:h,easedT:d,completed:g,state:m}=H._frame(r,o,a,l,c,u),p=Math.pow(1-d,n),v=d*Math.PI*2*i,_=d*Math.PI*2*i*1.3,w=p*e*(Math.sin(v)*.6+Math.sin(v*2.5)*.3+Math.sin(v*5.6)*.1),b=p*s*(Math.cos(_)*.6+Math.cos(_*2.7)*.3+Math.cos(_*6.3)*.1);let S=f+w,C=t+b;if(d>.9){const T=(d-.9)/.1;S=f+w*(1-T),C=t+b*(1-T)}return H.animationResult({x:S,y:C,intensity:p},h,a,g,m)}function js(f,t,e,s,i,n,r,o,a=!1,l=!1,c=null,u={},h=null){h||(h={started:!1,loopCount:0,direction:1,lastDirection:1});let d=o>0?r/o:1,g=!1,m={...u};if(l||a)if(a)if(l){const C=o*2,T=r%C,M=Math.floor(r/C),R=T<o?1:-1;d=R===1?T/o:2-T/o,R!==h.direction&&(h.direction=R,h.direction===1&&m.onLoop&&m.onLoop(M)),M>h.loopCount&&(h.loopCount=M)}else{d=d%1;const C=Math.floor(r/o);C>h.loopCount&&m.onLoop&&(m.onLoop(C),h.loopCount=C)}else l&&!a&&(d<=1?h.direction=1:d<=2?(d=2-d,h.direction=-1):(d=0,g=!0,h.direction=1));else d>=1&&(d=1,g=!0);!h.started&&m.onStart&&(m.onStart(),h.started=!0),g&&!h.completed&&m.onComplete&&(m.onComplete(),h.completed=!0);const p=c?c(d):d,v=At.lerp(e,s,p),_=i+p*n*Math.PI*2,w=f+v*Math.cos(_),b=t+v*Math.sin(_),S={...h,lastDirection:h.direction};return H.animationResult({x:w,y:b,radius:v,angle:_,direction:h.direction},d,a||l&&!g,g,S)}function Ks(f,t,e,s,i=!1,n=!1,r={},o={}){if(s<=0)return this.animationResult({value:t,velocity:0,done:!0,phase:"complete"},1,!1,!0);let a=e/s,l="forward",c=0;i?(c=Math.floor(a),a=a%1,c>0&&o.onLoop&&o.onLoop(c)):a>1&&(a=1),a>0&&e<=s&&o.onStart&&o.onStart();let u,h,d;n?a>=.5?(u=f,h=t,d=(a-.5)*2,l="return",a>=.5&&a<.51&&o.onYoyoTurn&&o.onYoyoTurn()):(u=t,h=f,d=a*2,l="forward"):(u=t,h=f,d=a);const g=r.stiffness!==void 0?r.stiffness:.3,m=r.damping!==void 0?r.damping:.6,p=Math.max(.1,1/(m*1.5)),v=Math.max(.1,.8/(g*1.5+.5));let _;if(d<.99)_=st.easeOutElastic(d,p,v);else{const k=(d-.99)/.01;_=st.easeOutElastic(.99,p,v)*(1-k)+1*k}const w=At.lerp(h,u,_),b=.01,S=Math.min(d+b,1);let C;if(S<.99)C=st.easeOutElastic(S,p,v);else{const k=(S-.99)/.01;C=st.easeOutElastic(.99,p,v)*(1-k)+1*k}const M=(At.lerp(h,u,C)-w)/b*s,R=!i&&a>=1;return R&&o.onComplete&&o.onComplete(),H.animationResult({value:w,velocity:M,delta:l==="forward"?t-w:f-w,done:R,phase:l},a,i,R)}function Js(f,t,e,s,i,n=!0,r=!0,o=null,a={},l=null){const{t:c,easedT:u,completed:h,state:d}=H._frame(s,i,n,o,a,l),m=Math.sin(r?u*Math.PI*2:u*Math.PI)*e;return H.animationResult({angle:m},c,n,h,d)}function Qs(f,t,e,s,i,n=!0,r={},o=null){if(!e||!Array.isArray(e)||e.length<2)return console.warn("Patrol animation requires at least 2 waypoints"),H._createResult({x:0,y:0,moving:!1,direction:"idle",waypoint:0},0,!1,!0);o||(o={currentWaypoint:0,nextWaypoint:1,isWaiting:!0,waitStartTime:0,lastWaypointTime:0,lastWaypointReached:-1,completed:!1});let a=0;for(let M=0;M<e.length;M++){const R=(M+1)%e.length;if(!n&&M===e.length-1)break;const k=e[R][0]-e[M][0],D=e[R][1]-e[M][1];a+=Math.abs(k)+Math.abs(D)}const l=a/s,c=i*e.length,u=l+c;let h=t;n?h=t%u:h=Math.min(t,u);const d=h/u;let g=h,m=0,p=1,v=!0,_=0,w=0,b=!1;if(g<i)_=g/i,m=0,p=1,v=!0;else{g-=i;for(let M=0;M<e.length;M++){if(!n&&M===e.length-1){m=M,p=M,v=!0,_=1,b=!0;break}const R=(M+1)%e.length,k=e[R][0]-e[M][0],D=e[R][1]-e[M][1],A=(Math.abs(k)+Math.abs(D))/s;if(g<A){m=M,p=R,v=!1,w=g/A;break}if(g-=A,g<i){m=R,p=(R+1)%e.length,v=!0,_=g/i,o.lastWaypointReached!==m&&(r.onWaypointReached&&r.onWaypointReached(m),r.onWaitStart&&r.onWaitStart(m),o.lastWaypointReached=m);break}g-=i}}let S,C,T;if(v||b)S=e[m][0],C=e[m][1],T="idle",!o.isWaiting&&v&&r.onWaitEnd&&r.onWaitEnd(m);else{const M=e[m],R=e[p],k=R[0]-M[0],D=R[1]-M[1],z=Math.abs(k)+Math.abs(D),A=Math.abs(k)/z;if(w<=A&&k!==0){const P=w/A;S=M[0]+k*P,C=M[1],T=k>0?"right":"left"}else{const P=(w-A)/(1-A);S=R[0],C=M[1]+D*P,T=D>0?"down":"up"}}return o.currentWaypoint=m,o.nextWaypoint=p,o.isWaiting=v,!o.completed&&b&&r.onPatrolComplete&&(r.onPatrolComplete(),o.completed=!0),H.animationResult({x:S,y:C,moving:!v,waiting:v,waitProgress:v?_:0,direction:T,waypoint:m,nextWaypoint:p},d,n,b,o)}class H{static animationResult(t,e,s,i=!1,n=null){return{...t,t:e,progress:e,loop:s,completed:i,state:n}}static _step(t,e,s,i={},n={started:!1,loopCount:0}){let r=e>0?t/e:1,o=!1;if(n=n||{started:!1,loopCount:0},!n.started&&i.onStart&&(i.onStart(),n.started=!0),s){r=r%1;const a=Math.floor(t/e);a>n.loopCount&&i.onLoop&&(i.onLoop(a),n.loopCount=a)}else r>=1&&(r=1,o=!0,!n.completed&&i.onComplete&&(i.onComplete(),n.completed=!0));return{t:r,completed:o,state:n}}static _frame(t,e,s,i=null,n={},r=null){const{t:o,completed:a,state:l}=this._step(t,e,s,n,r),c=i?i(o):o;return{t:o,easedT:c,completed:a,state:l}}static oscillate(t,e,s,i,n=!0,r=null,o={},a=null){return Hs(t,e,s,i,n,r,o,a)}static parabolic(t,e,s,i,n,r=!1,o=!1,a=null,l={},c=null){return Gs(t,e,s,i,n,r,o,a,l,c)}static float(t,e,s,i,n,r,o=!0,a=null,l={},c=null){return Ls(t,e,s,i,n,r,o,a,l,c)}static spring(t,e,s,i,n=!1,r=!1,o={},a={}){return Ks(t,e,s,i,n,r,o,a)}static swing(t,e,s,i,n,r=!0,o=!0,a=null,l={},c=null){return Js(t,e,s,i,n,r,o,a,l,c)}static pendulum(t,e,s,i,n=!0,r=!1,o=null,a={},l=null){return qs(t,e,s,i,n,r,o,a,l)}static pulse(t,e,s,i,n=!0,r=!1,o=null,a={}){return Zs(t,e,s,i,n,r,o,a={})}static spiral(t,e,s,i,n,r,o,a,l=!1,c=!1,u=null,h={},d=null){return js(t,e,s,i,n,r,o,a,l,c,u,h,d)}static orbit(t,e,s,i,n,r,o,a=!0,l=!0,c=null,u={},h=null){return Ns(t,e,s,i,n,r,o,a,l,c,u,h)}static bezier(t,e,s,i,n,r,o=!1,a=!1,l=null,c={},u=null){return ti(t,e,s,i,n,r,o,a,l,c,u)}static bounce(t,e,s,i,n,r=!1,o=null,a={},l=null){return Fs(t,e,s,i,n,r,o,a,l)}static shake(t,e,s,i,n,r,o,a,l=!1,c=null,u={},h=null){return $s(t,e,s,i,n,r,o,a,l,c,u,h)}static follow(t,e=!1,s,i,n=!1,r=null,o={},a=null){return Ws(t,e,s,i,n,r,o,a)}static waypoint(t,e,s,i,n,r=!0,o={},a=null){return Qs(t,e,s,i,n,r,o,a)}static patrol(t,e,s,i,n,r,o=!0,a=null){return Us(t,e,s,i,n,r,o,a)}static hop(t,e,s,i,n=!0,r=!0,o=null,a={},l=null){return Vs(t,e,s,i,n,r,o,a,l)}static group(t,e,s,i,n=!1,r=null,o={},a=null){a||(a={started:!1,loopCount:0,animationStates:Array(t.length).fill(null)});const{t:l,easedT:c,completed:u,state:h}=this._frame(s,i,n,r,o,a),d={};for(let g=0;g<t.length;g++){const m=t[g],p=[...e[g]];m===this.parabolic||m===this.oscillate||m===this.pulse?(p[3]=s,p[4]=i,p[5]=n,p[6]===void 0&&(p[6]=r)):m===this.spring?(p[2]=s,p[3]=i,p[4]=n):m===this.spiral||m===this.bezier?(p[6]=s,p[7]=i,p[8]=n,p[9]===void 0&&(p[9]=r)):m===this.orbit?(p[5]=s,p[6]=i,p[7]=n,p[9]===void 0&&(p[9]=r)):m===this.bounce||m===this.shake?(p[6]=s,p[7]=i,p[8]=n,p[9]===void 0&&(p[9]=r)):m===this.followPath&&(p[2]=s,p[3]=i,p[4]=n,p[5]===void 0&&(p[5]=r)),p.push(o),p.push(h.animationStates[g]);const v=m.apply(this,p);h.animationStates[g]=v.state;const _=`anim${g}`;d[_]=v}return this.animationResult(d,l,n,u,h)}static sequence(t,e,s,i,n=!1,r=null,o={},a=null,l=null){if(!l){l={started:!1,loopCount:0,animationStates:Array(t.length).fill(null),currentAnim:0,animStartTimes:[0],totalDuration:0};let b=0;for(let S=0;S<s.length;S++)b+=s[S],S<s.length-1&&l.animStartTimes.push(b);l.totalDuration=b}let c=i;if(n&&l.totalDuration>0){c=i%l.totalDuration;const b=Math.floor(i/l.totalDuration);b>l.loopCount&&o.onLoop&&(o.onLoop(b),l.loopCount=b)}!l.started&&o.onStart&&(o.onStart(),l.started=!0);let u=0;for(let b=t.length-1;b>=0;b--)if(c>=l.animStartTimes[b]){u=b;break}l.currentAnim=u;const h=l.animStartTimes[u],d=c-h,g=s[u],m=t[u],p=[...e[u]];m===this.parabolic||m===this.oscillate||m===this.pulse?(p[3]=d,p[4]=g,p[5]=!1,r&&r[u]&&(p[6]=r[u])):m===this.spring?(p[2]=d,p[3]=g,p[4]=!1):m===this.spiral||m===this.bezier?(p[6]=d,p[7]=g,p[8]=!1,r&&r[u]&&(p[9]=r[u])):m===this.orbit?(p[5]=d,p[6]=g,p[7]=!1,r&&r[u]&&(p[9]=r[u])):m===this.bounce||m===this.shake?(p[6]=d,p[7]=g,p[8]=!1,r&&r[u]&&(p[9]=r[u])):m===this.followPath&&(p[2]=d,p[3]=g,p[4]=!1,r&&r[u]&&(p[5]=r[u]));const v=a&&a[u]?a[u]:{},_=m.apply(this,[...p,v,l.animationStates[u]]);l.animationStates[u]=_.state;const w=!n&&c>=l.totalDuration;return w&&!l.completed&&o.onComplete&&(o.onComplete(),l.completed=!0),this.animationResult({..._,currentAnim:u,totalAnimations:t.length,sequenceProgress:Math.min(c/l.totalDuration,1)},c/l.totalDuration,n,w,l)}}function ti(f,t,e,s,i,n,r=!1,o=!1,a=null,l={},c=null){if(n<=0)return H.animationResult({x:s[0],y:s[1],phase:"complete"},1,!1,!0);let u=i/n,h="forward",d=0;r?(d=Math.floor(u),u=u%1,d>0&&l.onLoop&&l.onLoop(d)):u>1&&(u=1),u>0&&i<=n&&l.onStart&&l.onStart();let m=a?a(u):u;o&&(u>=.5?(m=1-(u-.5)*2,h="return",u>=.5&&u<.51&&l.onYoyoTurn&&l.onYoyoTurn()):(m=u*2,h="forward"),m=a?a(m):m);const p=3*(t[0]-f[0]),v=3*(e[0]-t[0])-p,_=s[0]-f[0]-p-v,w=3*(t[1]-f[1]),b=3*(e[1]-t[1])-w,S=s[1]-f[1]-w-b,C=_*Math.pow(m,3)+v*Math.pow(m,2)+p*m+f[0],T=S*Math.pow(m,3)+b*Math.pow(m,2)+w*m+f[1],M=!r&&u>=1;return M&&l.onComplete&&l.onComplete(),H.animationResult({x:C,y:T,phase:h},u,r,M,c)}class Tt{constructor(t,e,s,i,n={}){this.target=t,this.toProps={...e},this.duration=s,this.easingFn=i||st.easeOutQuad,this.delay=n.delay||0,this.onStart=n.onStart||null,this.onComplete=n.onComplete||null,this.onUpdate=n.onUpdate||null,this._elapsed=0,this._started=!1,this._finished=!1,this._startProps={};for(const r in this.toProps)r in this.target&&(this._startProps[r]=this.target[r])}static to(t,e,s,i,n){const r=new Tt(t,e,s,i,n);return Tt._active.push(r),r}update(t){if(this._finished||(this._elapsed+=t,this._elapsed<this.delay))return;const e=this._elapsed-this.delay,s=Math.min(e/this.duration,1);!this._started&&s>0&&(this._started=!0,this.onStart&&this.onStart());const i=this.easingFn(s);for(const n in this._startProps){const r=this._startProps[n],o=this.toProps[n];this.target[n]=At.lerp(r,o,i)}this.onUpdate&&this.onUpdate(),s>=1&&(this._finished=!0,this.onComplete&&this.onComplete())}static updateAll(t){for(const e of Tt._active)e.update(t);Tt._active=Tt._active.filter(e=>!e._finished)}static killTarget(t){Tt._active=Tt._active.filter(e=>e.target!==t)}static killAll(){Tt._active=[]}}class ei extends He{constructor(t){super(),this.game=t,this._collection=new Te,this._collection._owner=this,["inputdown","inputup","inputmove","click"].forEach(s=>{this.game.events.on(s,i=>{this.dispatchInputEvent(s,i)})})}_hoverObject(t,e){if(!t.interactive||!t._hitTest)return;const s=t._hitTest(e.x,e.y);s&&!t._hovered?(t._hovered=!0,t.events.emit("mouseover",e)):!s&&t._hovered&&(t._hovered=!1,t.events.emit("mouseout",e))}_hoverScene(t,e){if(t.children&&t.children.length>0)for(let s=t.children.length-1;s>=0;s--){const i=t.children[s];i instanceof Kt?this._hoverScene(i,e):this._hoverObject(i,e)}this._hoverObject(t,e)}dispatchInputEvent(t,e){var s;for(let i=this.gameObjects.length-1;i>=0;i--){const n=this.gameObjects[i];if(n instanceof Kt){if(this._dispatchToScene(n,t,e))break}else if(n.interactive&&((s=n._hitTest)!=null&&s.call(n,e.x,e.y))){n.events.emit(t,e);break}}t==="inputmove"&&this._dispatchHover(e)}_dispatchHover(t){for(let e=this.gameObjects.length-1;e>=0;e--){const s=this.gameObjects[e];s instanceof Kt?this._hoverScene(s,t):this._hoverObject(s,t)}}_dispatchToScene(t,e,s){var i,n;for(let r=t.children.length-1;r>=0;r--){const o=t.children[r];if(o instanceof Kt){if(this._dispatchToScene(o,e,s))return!0}else if(o.interactive&&((i=o._hitTest)!=null&&i.call(o,s.x,s.y)))return o.events.emit(e,s),!0}return t.interactive&&((n=t._hitTest)!=null&&n.call(t,s.x,s.y))?(t.events.emit(e,s),!0):!1}add(t){t.parent=this.game;const e=this._collection.add(t);return e.init&&e.init(),e}remove(t){if(t==null){this.logger.warn("Cannot remove undefined or null object",t);return}this._collection.remove(t)}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}clear(){return this._collection.clear()}get gameObjects(){return this._collection.children}update(t){this.logger.groupCollapsed("Pipeline.update"),this._collection.children.filter(e=>e.active).forEach(e=>e.update(t)),Tt.updateAll(t),this.logger.groupEnd()}render(){const t=i=>i.render(),e=i=>i.visible,s=i=>i.active;this.logger.groupCollapsed("Pipeline.render"),this._collection.getSortedChildren().filter(e).filter(s).forEach(t),this.logger.groupEnd()}}class Di{constructor(t){O(this,le,0),O(this,ce,0),this.canvas=t,this.ctx=t.getContext("2d"),this.events=new $e,this._cursor=null,this.lastTime=0,this.dt=0,this.running=!1,this._frame=0,this.pipeline=new ei(this),y.init(this.ctx),this.targetFPS=60,this._frameInterval=1e3/this.targetFPS,this._accumulator=0,this._pauseOnBlur=!1,this._isPaused=!1,this._init=!1,this.initLogging()}setFPS(t){this.targetFPS=t,this._frameInterval=1e3/t}init(){this.initIO(),this.initMotion(),this._init=!0,this.logger.log("[Game] Initialized")}initMouse(){zs.init(this)}initTouch(){Xs.init(this)}initInput(){W.init(this)}initKeyboard(){Es.init(this)}initIO(){this.initMouse(),this.initTouch(),this.initInput(),this.initKeyboard()}initMotion(){Tt._active=[]}initLogging(){this.logger=new Rt("Game"),Rt.setOutput(console),Rt.disableAll(),Rt.disable(),Rt.setLevel(Rt.INFO),this.logger.groupCollapsed("Initializing Game...")}enableLogging(){Rt.enable()}disableLogging(){Rt.disableAll(),Rt.disable()}markBoundsDirty(){this._boundsDirty=!0}get boundsDirty(){return this._boundsDirty}set boundsDirty(t){this._boundsDirty=t}enableFluidSize(t=window,e={}){const{top:s=0,right:i=0,bottom:n=0,left:r=0}=e;if(t===window){const o=()=>{var a;this.canvas.width=window.innerWidth-r-i,this.canvas.height=window.innerHeight-s-n,(x(this,le)!==this.canvas.width||x(this,ce)!==this.canvas.height)&&(this.markBoundsDirty(),(a=this.onResize)==null||a.call(this)),N(this,le,this.canvas.width),N(this,ce,this.canvas.height)};o(),window.addEventListener("resize",o),this._fluidResizeCleanup=()=>{window.removeEventListener("resize",o)}}else{if(!("ResizeObserver"in window)){console.warn("ResizeObserver not supported in this browser.");return}const o=()=>{const l=t.getBoundingClientRect();this.canvas.width=l.width-r-i,this.canvas.height=l.height-s-n},a=new ResizeObserver(()=>{o()});a.observe(t),o(),this._fluidResizeCleanup=()=>a.disconnect()}}disableFluidSize(){this._fluidResizeCleanup&&(this._fluidResizeCleanup(),this._fluidResizeCleanup=null)}start(){if(this.logger.groupCollapsed("[Game] Starting..."),this.init(),!this._init)throw new Error("Game not initialized. Did you call init()? Remember to call super.init() in your subclass.");this.running=!0,this.loop=this.loop.bind(this),requestAnimationFrame(this.loop),this.logger.log("[Game] Started"),this.logger.groupEnd()}stop(){this.running=!1,this.logger.log("[Game] Stopped")}restart(){this.pipeline.clear(),this.init(),this.start(),this.logger.log("[Game] Restarted")}loop(t){if(!this.running)return;const e=t-this.lastTime;if(this.lastTime=t,this._accumulator+=e,this.actualFps=1e3/e,this._accumulator>=this._frameInterval){const s=this._frameInterval/1e3;this.dt=s,this._frame++,this.logger.groupCollapsed(`Frame #${this._frame}`),this.logger.time("render time"),this.update(s),this.render(),this.logger.timeEnd("render time"),this.logger.groupEnd(),this._accumulator-=this._frameInterval}this.boundsDirty&&(this.boundsDirty=!1),requestAnimationFrame(this.loop)}update(t){this.pipeline.update(t)}render(){y.setContext(this.ctx),this.running&&this.clear(),this.pipeline.render()}clear(){y.clear()}get width(){return this.canvas.width}get height(){return this.canvas.height}set backgroundColor(t){this.canvas.style.backgroundColor=t}set cursor(t){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor)),this._cursor=t,this._cursor.activate(),this.pipeline.add(t)}get cursor(){return this._cursor}resetCursor(){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor),this._cursor=null)}enablePauseOnBlur(t){this._pauseOnBlur=t,t?window.addEventListener("visibilitychange",this._handleVisibilityChange.bind(this),!1):window.removeEventListener("visibilitychange",this._handleVisibilityChange.bind(this),!1)}_handleVisibilityChange(){this.logger.log("Visibility change detected"),document.hidden?this._pauseOnBlur&&this.running&&(this._isPaused=!0,this.stop(),this.logger.log("Paused due to tab visibility change")):this._isPaused&&(this._isPaused=!1,this.start(),this.logger.log("Resumed after tab visibility change"))}}le=new WeakMap;ce=new WeakMap;const vt={button:{default:{bg:"rgba(0, 0, 0, 0.85)",stroke:"rgba(0, 255, 0, 0.4)",text:"#0f0"},hover:{bg:"#0f0",stroke:"#0f0",text:"#000"},pressed:{bg:"#0c0",stroke:"#0f0",text:"#000"},active:{bg:"rgba(0, 255, 0, 0.15)",stroke:"#0f0",text:"#0f0"}}};class si extends Vt{constructor(t,e={}){super(t,e);const{x:s=0,y:i=0,width:n=120,height:r=40,text:o="Button",font:a="14px monospace",textColor:l="#000",textAlign:c="center",textBaseline:u="middle",shape:h=null,label:d=null,onClick:g=null,onHover:m=null,onPressed:p=null,onRelease:v=null,padding:_=10,colorDefaultBg:w=vt.button.default.bg,colorDefaultStroke:b=vt.button.default.stroke,colorDefaultText:S=vt.button.default.text,colorHoverBg:C=vt.button.hover.bg,colorHoverStroke:T=vt.button.hover.stroke,colorHoverText:M=vt.button.hover.text,colorPressedBg:R=vt.button.pressed.bg,colorPressedStroke:k=vt.button.pressed.stroke,colorPressedText:D=vt.button.pressed.text}=e;this.x=s,this.y=i,this.width=n,this.height=r,this.padding=_,this.textAlign=c,this.textBaseline=u,this.initColorScheme({colorDefaultBg:w,colorDefaultStroke:b,colorDefaultText:S,colorHoverBg:C,colorHoverStroke:T,colorHoverText:M,colorPressedBg:R,colorPressedStroke:k,colorPressedText:D}),this.initBackground(h),this.initLabel(o,a,l,d),this.initGroup(),this.initEvents(g,m,p,v),this.setState("default")}initColorScheme(t){this.colors={default:{bg:t.colorDefaultBg,stroke:t.colorDefaultStroke,text:t.colorDefaultText},hover:{bg:t.colorHoverBg,stroke:t.colorHoverStroke,text:t.colorHoverText},pressed:{bg:t.colorPressedBg,stroke:t.colorPressedStroke,text:t.colorPressedText}}}initBackground(t){this.bg=t??new qe({width:this.width,height:this.height,color:this.colors.default.bg,stroke:this.colors.default.stroke,lineWidth:2})}initLabel(t,e,s,i){this.label=i??new Is(t,{font:e,color:s,align:this.textAlign,baseline:this.textBaseline}),this.alignText()}alignText(){if(!this.label)return;const t=this.width/2,e=this.height/2;switch(this.textAlign){case"left":this.label.x=-t+this.padding;break;case"right":this.label.x=t-this.padding;break;case"center":default:this.label.x=0;break}switch(this.textBaseline){case"top":this.label.y=-e+this.padding;break;case"bottom":this.label.y=e-this.padding;break;case"middle":default:this.label.y=0;break}}initGroup(){this.group=new bs,this.group.add(this.bg),this.group.add(this.label)}initEvents(t,e,s,i){this.interactive=!0,this.onHover=e,this.onPressed=s,this.onRelease=i,this.on("mouseover",this.setState.bind(this,"hover")),this.on("mouseout",this.setState.bind(this,"default")),this.on("inputdown",this.setState.bind(this,"pressed")),this.on("inputup",()=>{this.state==="pressed"&&typeof t=="function"&&t(),this.setState("hover")})}setState(t){var e,s,i;if(this.state!==t)switch(this.state=t,t){case"default":this.game.cursor&&setTimeout(()=>{this.game.cursor.activate()},0),this.bg.color=this.colors.default.bg,this.bg.stroke=this.colors.default.stroke,this.label.color=this.colors.default.text,this.game.canvas.style.cursor="default",(e=this.onRelease)==null||e.call(this);break;case"hover":this.game.cursor&&this.game.cursor.deactivate(),this.bg.color=this.colors.hover.bg,this.bg.stroke=this.colors.hover.stroke,this.label.color=this.colors.hover.text,this.game.canvas.style.cursor="pointer",(s=this.onHover)==null||s.call(this);break;case"pressed":this.game.cursor&&this.game.cursor.deactivate(),this.bg.color=this.colors.pressed.bg,this.bg.stroke=this.colors.pressed.stroke,this.label.color=this.colors.pressed.text,this.game.canvas.style.cursor="pointer",(i=this.onPressed)==null||i.call(this);break}}update(t){super.update(t),this._boundsDirty&&this.alignText()}get text(){return this.label.text}set text(t){this.label.text=t,this._boundsDirty=!0}setTextAlign(t){this.textAlign=t,this.label.align=t,this._boundsDirty=!0}setTextBaseline(t){this.textBaseline=t,this.label.baseline=t,this._boundsDirty=!0}setFont(t){this.label.font=t,this._boundsDirty=!0}resize(t,e){this.width=t,this.height=e,this.bg.width=t,this.bg.height=e,this._boundsDirty=!0}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}draw(){super.draw(),this.group.render()}}class Pi extends si{constructor(t,e={}){const s=e.onClick;super(t,{...e,onClick:()=>{this.toggled=!this.toggled,typeof e.onToggle=="function"&&e.onToggle(this.toggled),typeof s=="function"&&s(),this.refreshToggleVisual()}}),this.colorActiveBg=e.colorActiveBg||vt.button.active.bg,this.colorActiveStroke=e.colorActiveStroke||vt.button.active.stroke,this.colorActiveText=e.colorActiveText||vt.button.active.text,this.toggled=!!e.startToggled,this.refreshToggleVisual()}toggle(t){this.toggled=t,this.refreshToggleVisual()}refreshToggleVisual(){this.toggled?(this.bg.fillColor=this.colorActiveBg,this.bg.strokeColor=this.colorActiveStroke,this.label.color=this.colorActiveText):(this.bg.fillColor=this.colors.default.bg,this.bg.strokeColor=this.colors.default.stroke,this.label.color=this.colors.default.text)}setState(t){super.setState(t),this.toggled&&(this.bg.fillColor=this.colorActiveBg,this.bg.strokeColor=this.colorActiveStroke,this.label.color=this.colorActiveText)}}class ii{constructor(){this.x=0,this.y=0,this.z=0,this.vx=0,this.vy=0,this.vz=0,this.size=1,this.color={r:255,g:255,b:255,a:1},this.shape="circle",this.age=0,this.lifetime=1,this.alive=!0,this.custom={}}reset(){this.x=0,this.y=0,this.z=0,this.vx=0,this.vy=0,this.vz=0,this.size=1,this.color.r=255,this.color.g=255,this.color.b=255,this.color.a=1,this.shape="circle",this.age=0,this.lifetime=1,this.alive=!0;for(const t in this.custom)delete this.custom[t]}get progress(){return this.lifetime>0?this.age/this.lifetime:1}}class ni{constructor(t={}){this.rate=t.rate??10,this.position={x:0,y:0,z:0,...t.position},this.spread={x:0,y:0,z:0,...t.spread},this.velocity={x:0,y:0,z:0,...t.velocity},this.velocitySpread={x:0,y:0,z:0,...t.velocitySpread},this.lifetime={min:1,max:2,...t.lifetime},this.size={min:1,max:1,...t.size},this.color={r:255,g:255,b:255,a:1,...t.color},this.shape=t.shape??"circle",this.active=t.active!==!1,this._timer=0}_spread(t){return(Math.random()-.5)*2*t}_range(t,e){return t+Math.random()*(e-t)}emit(t){t.x=this.position.x+this._spread(this.spread.x),t.y=this.position.y+this._spread(this.spread.y),t.z=this.position.z+this._spread(this.spread.z),t.vx=this.velocity.x+this._spread(this.velocitySpread.x),t.vy=this.velocity.y+this._spread(this.velocitySpread.y),t.vz=this.velocity.z+this._spread(this.velocitySpread.z),t.lifetime=this._range(this.lifetime.min,this.lifetime.max),t.age=0,t.alive=!0,t.size=this._range(this.size.min,this.size.max),t.color.r=this.color.r,t.color.g=this.color.g,t.color.b=this.color.b,t.color.a=this.color.a,t.shape=this.shape}update(t){if(!this.active||this.rate<=0)return 0;this._timer+=t;const e=1/this.rate;let s=0;for(;this._timer>=e;)this._timer-=e,s++;return s}reset(){this._timer=0}}const fe={velocity:(f,t)=>{f.x+=f.vx*t,f.y+=f.vy*t,f.z+=f.vz*t},lifetime:(f,t)=>{f.age+=t,f.age>=f.lifetime&&(f.alive=!1)},gravity:(f=200)=>(t,e)=>{t.vy+=f*e},rise:(f=100)=>(t,e)=>{t.vy-=f*e},damping:(f=.98)=>(t,e)=>{t.vx*=f,t.vy*=f,t.vz*=f},fadeOut:(f,t)=>{f.color.a=Math.max(0,1-f.progress)},fadeInOut:(f,t)=>{const e=f.progress;f.color.a=e<.5?e*2:(1-e)*2},shrink:(f=0)=>(t,e)=>{t.custom._initialSize===void 0&&(t.custom._initialSize=t.size),t.size=t.custom._initialSize*(1-t.progress*(1-f))},grow:(f=2)=>(t,e)=>{t.custom._initialSize===void 0&&(t.custom._initialSize=t.size),t.size=t.custom._initialSize*(1+t.progress*(f-1))},colorOverLife:(f,t)=>(e,s)=>{const i=e.progress;e.color.r=Math.floor(f.r+(t.r-f.r)*i),e.color.g=Math.floor(f.g+(t.g-f.g)*i),e.color.b=Math.floor(f.b+(t.b-f.b)*i)},wobble:(f=10)=>(t,e)=>{t.vx+=(Math.random()-.5)*f*e,t.vy+=(Math.random()-.5)*f*e},bounds:(f,t=.8)=>(e,s)=>{e.x<f.left?(e.x=f.left,e.vx=Math.abs(e.vx)*t):e.x>f.right&&(e.x=f.right,e.vx=-Math.abs(e.vx)*t),e.y<f.top?(e.y=f.top,e.vy=Math.abs(e.vy)*t):e.y>f.bottom&&(e.y=f.bottom,e.vy=-Math.abs(e.vy)*t)},attract:(f,t=100)=>(e,s)=>{const i=f.x-e.x,n=f.y-e.y,r=(f.z??0)-e.z,o=Math.sqrt(i*i+n*n+r*r);if(o>1){const a=t*s/o;e.vx+=i*a,e.vy+=n*a,e.vz+=r*a}}};class oi extends Vt{constructor(t,e={}){super(t,e),this.particles=[],this.pool=[],this.maxParticles=e.maxParticles??5e3,this.emitters=new Map,this.camera=e.camera??null,this.depthSort=e.depthSort??!1,this.updaters=e.updaters??[fe.velocity,fe.lifetime],this.blendMode=e.blendMode??"source-over",this.worldSpace=e.worldSpace??!1,this._particleCount=0}addEmitter(t,e){return this.emitters.set(t,e),this}removeEmitter(t){return this.emitters.delete(t),this}getEmitter(t){return this.emitters.get(t)}acquire(){return this.pool.length>0?this.pool.pop():new ii}release(t){t.reset(),this.pool.push(t)}emit(t,e){for(let s=0;s<t&&this.particles.length<this.maxParticles;s++){const i=this.acquire();e.emit(i),this.particles.push(i)}}burst(t,e){const s=typeof e=="string"?this.emitters.get(e):e;s&&this.emit(t,s)}update(t){super.update(t);for(const e of this.emitters.values())if(e.active){const s=e.update(t);this.emit(s,e)}for(let e=this.particles.length-1;e>=0;e--){const s=this.particles[e];for(const i of this.updaters)i(s,t,this);s.alive||(this.release(s),this.particles.splice(e,1))}this._particleCount=this.particles.length}render(){super.render(),this.particles.length!==0&&(this.camera&&this.depthSort?this.renderWithDepthSort():this.renderSimple())}renderSimple(){y.useCtx(t=>{t.globalCompositeOperation=this.blendMode;for(const e of this.particles)this.drawParticle(t,e,e.x,e.y,1);t.globalCompositeOperation="source-over"})}renderWithDepthSort(){const t=[];for(const e of this.particles){const s=this.camera.project(e.x,e.y,e.z);s.z<-this.camera.perspective+10||t.push({p:e,x:s.x,y:s.y,z:s.z,scale:s.scale})}t.sort((e,s)=>s.z-e.z),y.useCtx(e=>{e.globalCompositeOperation=this.blendMode;const s=this.parent&&this.parent.constructor.name==="Scene3D";!this.worldSpace&&!s&&(e.save(),e.translate(this.game.width/2,this.game.height/2));for(const i of t)this.drawParticle(e,i.p,i.x,i.y,i.scale);!this.worldSpace&&!s&&e.restore(),e.globalCompositeOperation="source-over"})}drawParticle(t,e,s,i,n){const{r,g:o,b:a,a:l}=e.color,c=e.size*n;if(c<.5||l<=0)return;t.fillStyle=`rgba(${Math.floor(r)},${Math.floor(o)},${Math.floor(a)},${l})`;const u=e.shape??"circle",h=c/2;t.beginPath(),u==="circle"?t.arc(s,i,h,0,Math.PI*2):u==="square"?t.rect(s-h,i-h,c,c):u==="triangle"&&(t.moveTo(s,i-h),t.lineTo(s+h,i+h),t.lineTo(s-h,i+h),t.closePath()),t.fill()}clear(){for(const t of this.particles)this.release(t);this.particles=[],this._particleCount=0}get particleCount(){return this._particleCount}get poolSize(){return this.pool.length}}class mt{static rectRect(t,e){return t.x<e.x+e.width&&t.x+t.width>e.x&&t.y<e.y+e.height&&t.y+t.height>e.y}static intersects(t,e){return mt.rectRect(t,e)}static pointRect(t,e,s){return t>=s.x&&t<=s.x+s.width&&e>=s.y&&e<=s.y+s.height}static circleCircle(t,e){const s=t.x-e.x,i=t.y-e.y,n=s*s+i*i,r=t.radius+e.radius;return n<=r*r}static getCircleOverlap(t,e){const s=t.x-e.x,i=t.y-e.y,n=s*s+i*i,r=t.radius+e.radius;if(n>=r*r||n<1e-4)return null;const o=Math.sqrt(n),a=r-o,l=1/o;return{overlap:a,nx:s*l,ny:i*l,dist:o}}static applyCircleSeparation(t,e,s={}){const i=s.strength??5e3,n=s.useSizeAsRadius??!0,r=t.length;for(let o=0;o<r;o++){const a=t[o],l=n?a.size*.5:a.radius??10;for(let c=o+1;c<r;c++){const u=t[c],h=n?u.size*.5:u.radius??10,d=mt.getCircleOverlap({x:a.x,y:a.y,radius:l},{x:u.x,y:u.y,radius:h});if(d){const g=i*(d.overlap/(l+h)),m=d.nx*g,p=d.ny*g;e[o].x+=m,e[o].y+=p,e[c].x-=m,e[c].y-=p}}}}static pointCircle(t,e,s){const i=t-s.x,n=e-s.y;return i*i+n*n<=s.radius*s.radius}static circleRect(t,e){const s=Math.max(e.x,Math.min(t.x,e.x+e.width)),i=Math.max(e.y,Math.min(t.y,e.y+e.height)),n=t.x-s,r=t.y-i;return n*n+r*r<=t.radius*t.radius}static lineRect(t,e,s,i,n,r=0){const o=n.x-r/2,a=n.y-r/2,l=n.width+r,c=n.height+r;if(mt.pointRect(t,e,{x:o,y:a,width:l,height:c})||mt.pointRect(s,i,{x:o,y:a,width:l,height:c}))return!0;const u=mt.lineLine(t,e,s,i,o,a,o,a+c),h=mt.lineLine(t,e,s,i,o+l,a,o+l,a+c),d=mt.lineLine(t,e,s,i,o,a,o+l,a),g=mt.lineLine(t,e,s,i,o,a+c,o+l,a+c);return u||h||d||g}static lineLine(t,e,s,i,n,r,o,a){const l=(a-r)*(s-t)-(o-n)*(i-e);if(l===0)return!1;const c=((o-n)*(e-r)-(a-r)*(t-n))/l,u=((s-t)*(e-r)-(i-e)*(t-n))/l;return c>=0&&c<=1&&u>=0&&u<=1}static segmentsRect(t,e,s=0){for(const i of t)if(mt.lineRect(i.x1,i.y1,i.x2,i.y2,e,s))return!0;return!1}static getOverlap(t,e){if(!mt.rectRect(t,e))return null;const s=Math.min(t.x+t.width,e.x+e.width)-Math.max(t.x,e.x),i=Math.min(t.y+t.height,e.y+e.height)-Math.max(t.y,e.y);return{x:s,y:i}}static getMTV(t,e){const s=mt.getOverlap(t,e);if(!s)return null;const i=t.x+t.width/2,n=t.y+t.height/2,r=e.x+e.width/2,o=e.y+e.height/2,a=i<r?-s.x:s.x,l=n<o?-s.y:s.y;return Math.abs(s.x)<Math.abs(s.y)?{x:a,y:0}:{x:0,y:l}}static sweep(t,e,s,i){const n={x:i.x-t.width/2,y:i.y-t.height/2,width:i.width+t.width,height:i.height+t.height},r=t.x+t.width/2,o=t.y+t.height/2;let a,l,c,u;e!==0?(a=(n.x-r)/e,l=(n.x+n.width-r)/e,a>l&&([a,l]=[l,a])):(a=r>=n.x&&r<=n.x+n.width?-1/0:1/0,l=r>=n.x&&r<=n.x+n.width?1/0:-1/0),s!==0?(c=(n.y-o)/s,u=(n.y+n.height-o)/s,c>u&&([c,u]=[u,c])):(c=o>=n.y&&o<=n.y+n.height?-1/0:1/0,u=o>=n.y&&o<=n.y+n.height?1/0:-1/0);const h=Math.max(a,c),d=Math.min(l,u);if(h>d||h<0||h>1)return null;let g=0,m=0;return a>c?g=e>0?-1:1:m=s>0?-1:1,{time:h,normalX:g,normalY:m}}}const Ft={maxParticles:500,particleSize:20,particleColor:{r:100,g:180,b:255,a:.9},physics:"liquid",gravity:200,damping:.98,bounce:.3,maxSpeed:400,fluid:{smoothingRadius:null,restDensity:3,pressureStiffness:80,nearPressureStiffness:3,viscosity:.005,maxForce:5e3},gas:{interactionRadius:null,pressure:150,diffusion:.15,drag:.02,turbulence:50,buoyancy:300,sinking:200,repulsion:300},heat:{enabled:!1,heatZone:.88,coolZone:.25,rate:.03,heatMultiplier:1.5,coolMultiplier:2,middleMultiplier:.005,transitionWidth:.08,neutralTemp:.5,deadZone:.15,buoyancy:300,sinking:200},collision:{enabled:!0,strength:5e3},boundary:{enabled:!0,strength:4e3,radius:null},shake:{enabled:!0,sensitivity:2,maxForce:2500,damping:.8},blendMode:"source-over"};class Ke extends oi{constructor(t,e={}){var s,i,n,r;const o=Ke._mergeConfig(e),a=((s=e.bounds)==null?void 0:s.x)??0,l=((i=e.bounds)==null?void 0:i.y)??0,c=e.width??((n=e.bounds)==null?void 0:n.w)??0,u=e.height??((r=e.bounds)==null?void 0:r.h)??0;super(t,{maxParticles:o.maxParticles,blendMode:o.blendMode,updaters:[fe.velocity,fe.lifetime],x:e.x??a+c/2,y:e.y??l+u/2,width:c,height:u,debug:e.debug??!1,debugColor:e.debugColor??"#0f0"}),this.config=o,this.bounds=e.bounds||null,this.gravityEnabled=e.gravityEnabled??!0,this.modeMix=o.physics==="gas"?1:0,this._targetMode=this.modeMix,this._modeLerpSpeed=5,this._forces=[],this._shake={lastX:window.screenX,lastY:window.screenY,velocityX:0,velocityY:0,forceX:0,forceY:0},this._createEmitter()}static _mergeConfig(t){const e={...Ft,...t},s=e.particleSize;return e.fluid={...Ft.fluid,...t.fluid},e.gas={...Ft.gas,...t.gas},e.heat={...Ft.heat,...t.heat},e.collision={...Ft.collision,...t.collision},e.boundary={...Ft.boundary,...t.boundary},e.shake={...Ft.shake,...t.shake},e.fluid.smoothingRadius===null&&(e.fluid.smoothingRadius=s*2),e.gas.interactionRadius===null&&(e.gas.interactionRadius=s*4),e.boundary.radius===null&&(e.boundary.radius=s*.8),e}_createEmitter(){const{particleSize:t,particleColor:e}=this.config,s=new ni({rate:0,position:{x:0,y:0},spread:{x:100,y:100},velocity:{x:0,y:0},velocitySpread:{x:10,y:10},size:{min:t,max:t+2},lifetime:{min:99999,max:99999},color:e,shape:"circle"});this.addEmitter("fluid",s)}spawn(t,e={}){const s=this.emitters.get("fluid");if(!s)return;let i=e.x,n=e.y,r=e.spreadX??100,o=e.spreadY??100;this.bounds&&i===void 0&&(i=this.bounds.x+this.bounds.w/2,n=this.bounds.y+this.bounds.h*.6,r=Math.min(this.bounds.w*.8,400),o=Math.min(this.bounds.h*.5,250)),s.position.x=i??this.game.width/2,s.position.y=n??this.game.height/2,s.spread.x=r,s.spread.y=o,this.burst(t,"fluid");for(const a of this.particles)a.custom.initialized||(a.custom.initialized=!0,a.custom.mass=1,a.custom.temperature=.5,a.vx=(Math.random()-.5)*20,a.vy=(Math.random()-.5)*20)}setBounds(t){this.bounds=t,this.x=t.x+t.w/2,this.y=t.y+t.h/2,this.width=t.w,this.height=t.h}update(t){t=Math.min(t,.033),this.modeMix=st.lerp(this.modeMix,this._targetMode,t*this._modeLerpSpeed);const e=this.particles;if(e.length===0){super.update(t);return}this._ensureForceArray(e.length),this._resetForces(),this._computePhysicsForces(e),this.modeMix>.5&&((this.config.heat.enabled||this.modeMix>.95)&&(this._updateTemperatures(e),this._applyThermalForces(e)),this.modeMix>.95&&this._applyGasRepulsion(e)),this.config.collision.enabled&&mt.applyCircleSeparation(e,this._forces,{strength:this.config.collision.strength,useSizeAsRadius:!0}),this.bounds&&this.config.boundary.enabled&&this._applyBoundaryForces(e),this.config.shake.enabled&&(this._updateShakeForces(t),this._applyShakeForces()),this._integrateForces(e,t),super.update(t),this.bounds&&this._clampBounds(e)}_ensureForceArray(t){for(;this._forces.length<t;)this._forces.push({x:0,y:0})}_resetForces(){for(let t=0;t<this._forces.length;t++)this._forces[t].x=0,this._forces[t].y=0}_computePhysicsForces(t){const{fluid:e,gas:s}=this.config;if(this.modeMix<.01){const i=Be(t,{kernel:{smoothingRadius:e.smoothingRadius},fluid:{restDensity:e.restDensity,pressureStiffness:e.pressureStiffness,nearPressureStiffness:e.nearPressureStiffness,viscosity:e.viscosity,maxForce:e.maxForce}});this._accumulateForces(i.forces)}else if(this.modeMix>.95){const i=Oe(t,{gas:{interactionRadius:s.interactionRadius,pressure:s.pressure,diffusion:s.diffusion,drag:s.drag,turbulence:s.turbulence,buoyancy:s.buoyancy}});this._accumulateForces(i.forces)}else{const i=Be(t,{kernel:{smoothingRadius:e.smoothingRadius},fluid:e}),n=Oe(t,{gas:s}),r=ls(i.forces,n.forces,this.modeMix);this._accumulateForces(r)}}_accumulateForces(t){const e=Math.min(t.length,this._forces.length);for(let s=0;s<e;s++)this._forces[s].x+=t[s].x,this._forces[s].y+=t[s].y}_applyBoundaryForces(t){const{x:e,y:s,w:i,h:n}=this.bounds,{radius:r,strength:o}=this.config.boundary,a=e,l=e+i,c=s,u=s+n;for(let h=0;h<t.length;h++){const d=t[h],g=d.size*.5,m=d.x-g-a,p=l-d.x-g,v=d.y-g-c,_=u-d.y-g;if(m<r){const w=Math.max(0,1-m/r);this._forces[h].x+=o*w*w}if(p<r){const w=Math.max(0,1-p/r);this._forces[h].x-=o*w*w}if(v<r){const w=Math.max(0,1-v/r);this._forces[h].y+=o*w*w}if(_<r){const w=Math.max(0,1-_/r);this._forces[h].y-=o*w*w}}}_updateTemperatures(t){if(!this.bounds)return;const{heat:e}=this.config,s=this.bounds.y,i=this.bounds.h;for(let n=0;n<t.length;n++){const r=t[n],o=r.custom.temperature??e.neutralTemp,a=Math.min(1,Math.max(0,(r.y-s)/i)),l=os(a,o,e);r.custom.temperature=Math.min(1,Math.max(0,l))}}_applyThermalForces(t){const{heat:e}=this.config,s=e.neutralTemp,i=e.deadZone;for(let n=0;n<t.length;n++){const a=(t[n].custom.temperature??s)-s;if(Math.abs(a)>i){let l=0;a>0?l=-(a-i)*e.buoyancy*2:l=(-a-i)*e.sinking*2,this._forces[n].y+=l}}}_applyGasRepulsion(t){const{gas:e}=this.config,s=e.interactionRadius,i=s*s,n=e.repulsion||200,r=t.length;for(let o=0;o<r;o++){const a=t[o];for(let l=o+1;l<r;l++){const c=t[l],u=a.x-c.x,h=a.y-c.y,d=u*u+h*h;if(d>=i||d<1)continue;const g=Math.sqrt(d),m=1-g/s,p=n*m*m*m,v=u/g*p,_=h/g*p;this._forces[o].x+=v,this._forces[o].y+=_,this._forces[l].x-=v,this._forces[l].y-=_}}}_updateShakeForces(t){const{shake:e}=this.config;if(!e.enabled)return;const s=window.screenX,i=window.screenY,n=s-this._shake.lastX,r=i-this._shake.lastY;t>0&&t<.1&&(this._shake.velocityX=n/t,this._shake.velocityY=r/t),this._shake.lastX=s,this._shake.lastY=i;const o=-this._shake.velocityX*e.sensitivity,a=-this._shake.velocityY*e.sensitivity;this._shake.forceX=st.lerp(this._shake.forceX,o,1-e.damping),this._shake.forceY=st.lerp(this._shake.forceY,a,1-e.damping);const l=Math.sqrt(this._shake.forceX*this._shake.forceX+this._shake.forceY*this._shake.forceY);if(l>e.maxForce){const c=e.maxForce/l;this._shake.forceX*=c,this._shake.forceY*=c}}_applyShakeForces(){const t=this._shake.forceX,e=this._shake.forceY;if(!(Math.abs(t)<1&&Math.abs(e)<1))for(let s=0;s<this._forces.length;s++)this._forces[s].x+=t,this._forces[s].y+=e}_integrateForces(t,e){const{gravity:s,damping:i,maxSpeed:n,heat:r}=this.config,o=n*n,l=st.lerp(i,.995,this.modeMix);for(let c=0;c<t.length;c++){const u=t[c],h=this._forces[c],d=u.custom.mass||1;let g,m;if(this.modeMix>.5){const v=u.custom.temperature??r.neutralTemp;g=d*st.lerp(1.5,.3,v),m=this.gravityEnabled?s*st.lerp(1.2,.6,v):0}else g=d,m=this.gravityEnabled?s:0;u.vx+=h.x/g*e,u.vy+=(h.y/g+m)*e,u.vx*=l,u.vy*=l;const p=u.vx*u.vx+u.vy*u.vy;if(p>o){const v=n/Math.sqrt(p);u.vx*=v,u.vy*=v}}}_clampBounds(t){const{x:e,y:s,w:i,h:n}=this.bounds,{bounce:r}=this.config;for(let o=0;o<t.length;o++){const a=t[o],l=a.size*.5,c=e+l,u=e+i-l,h=s+l,d=s+n-l;a.x<c?(a.x=c,a.vx=Math.abs(a.vx)*r):a.x>u&&(a.x=u,a.vx=-Math.abs(a.vx)*r),a.y<h?(a.y=h,a.vy=Math.abs(a.vy)*r):a.y>d&&(a.y=d,a.vy=-Math.abs(a.vy)*r)}}reset(){const t=this.particles.length;this.particles.length=0,this._forces.length=0,this.spawn(t)}toggleGravity(){return this.gravityEnabled=!this.gravityEnabled,this.gravityEnabled}setPhysicsMode(t,e=!1){let s;if(t==="liquid")s=0;else if(t==="gas")s=1;else if(typeof t=="number")s=Math.max(0,Math.min(1,t));else return;this._targetMode=s,e&&(this.modeMix=s)}getPhysicsMode(){return this.modeMix<.01?"liquid":this.modeMix>.99?"gas":"blending"}isHeatEnabled(){return this.config.heat.enabled||this.modeMix>.5}}class Je{static applyADSR(t,e={}){const{attack:s=.01,decay:i=.1,sustain:n=.7,release:r=.2,startTime:o=0,duration:a=1,peakVolume:l=1}=e,c=l*n,u=Math.max(0,a-s-i);t.setValueAtTime(0,o),t.linearRampToValueAtTime(l,o+s),t.linearRampToValueAtTime(c,o+s+i),t.setValueAtTime(c,o+s+i+u),t.linearRampToValueAtTime(0,o+a+r)}static get presets(){return{pluck:{attack:.001,decay:.2,sustain:0,release:.1},pad:{attack:.5,decay:.3,sustain:.8,release:1},organ:{attack:.01,decay:0,sustain:1,release:.05},perc:{attack:.001,decay:.1,sustain:0,release:.05},string:{attack:.1,decay:.2,sustain:.7,release:.3},brass:{attack:.05,decay:.1,sustain:.8,release:.2},blip:{attack:.001,decay:.05,sustain:0,release:.02},laser:{attack:.001,decay:.15,sustain:0,release:.05},explosion:{attack:.001,decay:.3,sustain:.2,release:.5}}}}class de{static init(t,e){N(this,L,t),N(this,Et,e)}static get ctx(){return x(this,L)}static get now(){return x(this,L).currentTime}static tone(t,e,s={}){const{type:i="sine",volume:n=.5,attack:r=.01,decay:o=.1,sustain:a=.7,release:l=.2,detune:c=0,startTime:u=x(this,L).currentTime}=s,h=x(this,L).createOscillator(),d=x(this,L).createGain();return h.type=i,h.frequency.setValueAtTime(t,u),h.detune.setValueAtTime(c,u),Je.applyADSR(d.gain,{attack:r,decay:o,sustain:a,release:l,startTime:u,duration:e,peakVolume:n}),h.connect(d),d.connect(x(this,Et)),h.start(u),h.stop(u+e+l),h}static continuous(t={}){const{type:e="sine",frequency:s=440,volume:i=.5}=t,n=x(this,L).createOscillator(),r=x(this,L).createGain();n.type=e,n.frequency.value=s,r.gain.value=i,n.connect(r),r.connect(x(this,Et)),n.start();const o=x(this,L);return{osc:n,gain:r,setFrequency:(a,l=0)=>{l>0?n.frequency.linearRampToValueAtTime(a,o.currentTime+l):n.frequency.setValueAtTime(a,o.currentTime)},setVolume:(a,l=0)=>{l>0?r.gain.linearRampToValueAtTime(a,o.currentTime+l):r.gain.setValueAtTime(a,o.currentTime)},stop:(a=0)=>{a>0?(r.gain.linearRampToValueAtTime(0,o.currentTime+a),n.stop(o.currentTime+a+.01)):n.stop()}}}static fm(t,e,s,i,n={}){const{volume:r=.5,startTime:o=x(this,L).currentTime}=n,a=x(this,L).createOscillator(),l=x(this,L).createOscillator(),c=x(this,L).createGain(),u=x(this,L).createGain();return l.frequency.value=e,c.gain.value=s,a.frequency.value=t,u.gain.value=r,l.connect(c),c.connect(a.frequency),a.connect(u),u.connect(x(this,Et)),u.gain.setValueAtTime(r,o),u.gain.linearRampToValueAtTime(0,o+i),l.start(o),a.start(o),l.stop(o+i+.1),a.stop(o+i+.1),{carrier:a,modulator:l,outputGain:u}}static additive(t,e,s,i={}){const{volume:n=.5,startTime:r=x(this,L).currentTime}=i,o=[],a=x(this,L).createGain();return a.gain.value=n/e.length,a.connect(x(this,Et)),a.gain.setValueAtTime(n/e.length,r),a.gain.linearRampToValueAtTime(0,r+s),e.forEach((l,c)=>{if(l>0){const u=x(this,L).createOscillator(),h=x(this,L).createGain();u.frequency.value=t*(c+1),h.gain.value=l,u.connect(h),h.connect(a),u.start(r),u.stop(r+s+.1),o.push(u)}}),o}static sweep(t,e,s,i={}){const{type:n="sine",volume:r=.5,exponential:o=!0,startTime:a=x(this,L).currentTime}=i,l=x(this,L).createOscillator(),c=x(this,L).createGain();return l.type=n,l.frequency.setValueAtTime(t,a),o&&e>0?l.frequency.exponentialRampToValueAtTime(e,a+s):l.frequency.linearRampToValueAtTime(e,a+s),c.gain.setValueAtTime(r,a),c.gain.linearRampToValueAtTime(0,a+s),l.connect(c),c.connect(x(this,Et)),l.start(a),l.stop(a+s+.01),l}static pulse(t,e,s=.5,i={}){const{volume:n=.5,startTime:r=x(this,L).currentTime}=i,o=x(this,L).createOscillator(),a=x(this,L).createOscillator(),l=x(this,L).createGain(),c=x(this,L).createGain(),u=x(this,L).createGain();return o.type="sawtooth",a.type="sawtooth",o.frequency.value=t,a.frequency.value=t,l.gain.value=.5,c.gain.value=-.5,u.gain.setValueAtTime(n,r),u.gain.linearRampToValueAtTime(0,r+e),o.connect(l),a.connect(c),l.connect(u),c.connect(u),u.connect(x(this,Et)),o.start(r),a.start(r),o.stop(r+e+.01),a.stop(r+e+.01),{osc1:o,osc2:a,output:u}}}L=new WeakMap;Et=new WeakMap;O(de,L,null);O(de,Et,null);class ge{static init(t,e){N(this,U,t),N(this,Re,e)}static get ctx(){return x(this,U)}static filter(t="lowpass",e=1e3,s=1){const i=x(this,U).createBiquadFilter();return i.type=t,i.frequency.value=e,i.Q.value=s,i}static delay(t=.3,e=.4,s=.5){const i=x(this,U).createDelay(5),n=x(this,U).createGain(),r=x(this,U).createGain(),o=x(this,U).createGain(),a=x(this,U).createGain(),l=x(this,U).createGain();return i.delayTime.value=t,n.gain.value=e,r.gain.value=s,o.gain.value=1-s,a.connect(i),a.connect(o),i.connect(n),n.connect(i),i.connect(r),r.connect(l),o.connect(l),{input:a,output:l,setTime:c=>i.delayTime.setValueAtTime(c,x(this,U).currentTime),setFeedback:c=>n.gain.setValueAtTime(c,x(this,U).currentTime),setMix:c=>{r.gain.setValueAtTime(c,x(this,U).currentTime),o.gain.setValueAtTime(1-c,x(this,U).currentTime)}}}static reverb(t=2,e=2){const s=x(this,U).createConvolver(),i=x(this,U).sampleRate,n=i*t,r=x(this,U).createBuffer(2,n,i);for(let o=0;o<2;o++){const a=r.getChannelData(o);for(let l=0;l<n;l++)a[l]=(Math.random()*2-1)*Math.pow(1-l/n,e)}return s.buffer=r,s}static distortion(t=50){const e=x(this,U).createWaveShaper(),s=t,i=44100,n=new Float32Array(i);for(let r=0;r<i;r++){const o=r*2/i-1;n[r]=(3+s)*o*20*(Math.PI/180)/(Math.PI+s*Math.abs(o))}return e.curve=n,e.oversample="4x",e}static tremolo(t=5,e=.5){const s=x(this,U).createOscillator(),i=x(this,U).createGain(),n=x(this,U).createGain();return s.frequency.value=t,i.gain.value=e*.5,n.gain.value=1-e*.5,s.connect(i),i.connect(n.gain),s.start(),{input:n,output:n,lfo:s,setRate:r=>s.frequency.setValueAtTime(r,x(this,U).currentTime),setDepth:r=>i.gain.setValueAtTime(r*.5,x(this,U).currentTime),stop:()=>s.stop()}}static compressor(t={}){const{threshold:e=-24,knee:s=30,ratio:i=12,attack:n=.003,release:r=.25}=t,o=x(this,U).createDynamicsCompressor();return o.threshold.value=e,o.knee.value=s,o.ratio.value=i,o.attack.value=n,o.release.value=r,o}static panner(t=0){const e=x(this,U).createStereoPanner();return e.pan.value=t,e}static gain(t=1){const e=x(this,U).createGain();return e.gain.value=t,e}}U=new WeakMap;Re=new WeakMap;O(ge,U,null);O(ge,Re,null);class ri{static white(t,e){const s=t.sampleRate*e,i=t.createBuffer(1,s,t.sampleRate),n=i.getChannelData(0);for(let o=0;o<s;o++)n[o]=Math.random()*2-1;const r=t.createBufferSource();return r.buffer=i,r}static pink(t,e){const s=t.sampleRate*e,i=t.createBuffer(1,s,t.sampleRate),n=i.getChannelData(0);let r=0,o=0,a=0,l=0,c=0,u=0,h=0;for(let g=0;g<s;g++){const m=Math.random()*2-1;r=.99886*r+m*.0555179,o=.99332*o+m*.0750759,a=.969*a+m*.153852,l=.8665*l+m*.3104856,c=.55*c+m*.5329522,u=-.7616*u-m*.016898,n[g]=(r+o+a+l+c+u+h+m*.5362)*.11,h=m*.115926}const d=t.createBufferSource();return d.buffer=i,d}static brown(t,e){const s=t.sampleRate*e,i=t.createBuffer(1,s,t.sampleRate),n=i.getChannelData(0);let r=0;for(let a=0;a<s;a++){const l=Math.random()*2-1;n[a]=(r+.02*l)/1.02,r=n[a],n[a]*=3.5}const o=t.createBufferSource();return o.buffer=i,o}}class ve{static noteToFreq(t){const e=t.match(/^([A-G][#b]?)(\d+)$/);if(!e)throw new Error(`Invalid note: ${t}`);const[,s,i]=e,n=this.NOTE_FREQUENCIES[s];if(n===void 0)throw new Error(`Unknown note: ${s}`);return n*Math.pow(2,parseInt(i))}static scale(t,e="major",s=1){const i=this.noteToFreq(t),n=this.SCALES[e];if(!n)throw new Error(`Unknown scale: ${e}`);const r=[];for(let o=0;o<s;o++)for(const a of n)r.push(i*Math.pow(2,(a+o*12)/12));return r}static chord(t,e="major"){const s=this.noteToFreq(t),i=this.CHORDS[e];if(!i)throw new Error(`Unknown chord type: ${e}`);return i.map(n=>s*Math.pow(2,n/12))}static mapToScale(t,e="C4",s="pentatonic",i=2){const n=this.scale(e,s,i),r=Math.max(0,Math.min(1,t)),o=Math.floor(r*n.length)%n.length;return n[o]}static midiToFreq(t){return 440*Math.pow(2,(t-69)/12)}static freqToMidi(t){return Math.round(12*Math.log2(t/440)+69)}static randomNote(t="C4",e="pentatonic",s=2){const i=this.scale(t,e,s);return i[Math.floor(Math.random()*i.length)]}static detune(t,e){return t*Math.pow(2,e/1200)}}I(ve,"NOTE_FREQUENCIES",{C:16.35,"C#":17.32,Db:17.32,D:18.35,"D#":19.45,Eb:19.45,E:20.6,F:21.83,"F#":23.12,Gb:23.12,G:24.5,"G#":25.96,Ab:25.96,A:27.5,"A#":29.14,Bb:29.14,B:30.87});I(ve,"SCALES",{major:[0,2,4,5,7,9,11],minor:[0,2,3,5,7,8,10],pentatonic:[0,2,4,7,9],pentatonicMinor:[0,3,5,7,10],blues:[0,3,5,6,7,10],dorian:[0,2,3,5,7,9,10],mixolydian:[0,2,4,5,7,9,10],chromatic:[0,1,2,3,4,5,6,7,8,9,10,11],wholeTone:[0,2,4,6,8,10],diminished:[0,2,3,5,6,8,9,11]});I(ve,"CHORDS",{major:[0,4,7],minor:[0,3,7],diminished:[0,3,6],augmented:[0,4,8],sus2:[0,2,7],sus4:[0,5,7],major7:[0,4,7,11],minor7:[0,3,7,10],dom7:[0,4,7,10],dim7:[0,3,6,9],add9:[0,4,7,14],power:[0,7]});class Gt{static init(t,e){N(this,oe,t),N(this,$,t.createAnalyser()),x(this,$).fftSize=2048,e.connect(x(this,$)),x(this,$).connect(t.destination),N(this,Wt,new Uint8Array(x(this,$).frequencyBinCount)),N(this,Nt,new Uint8Array(x(this,$).frequencyBinCount))}static get isInitialized(){return x(this,$)!==null}static get node(){return x(this,$)}static setFFTSize(t){x(this,$)&&(x(this,$).fftSize=t,N(this,Wt,new Uint8Array(x(this,$).frequencyBinCount)),N(this,Nt,new Uint8Array(x(this,$).frequencyBinCount)))}static getWaveform(){return x(this,$)?(x(this,$).getByteTimeDomainData(x(this,Wt)),x(this,Wt)):new Uint8Array(0)}static getFrequency(){return x(this,$)?(x(this,$).getByteFrequencyData(x(this,Nt)),x(this,Nt)):new Uint8Array(0)}static getBands(t=8){const e=this.getFrequency();if(e.length===0)return new Array(t).fill(0);const s=Math.floor(e.length/t),i=[];for(let n=0;n<t;n++){let r=0;for(let o=0;o<s;o++)r+=e[n*s+o];i.push(r/(s*255))}return i}static getAmplitude(){const t=this.getWaveform();if(t.length===0)return 0;let e=0;for(let s=0;s<t.length;s++){const i=(t[s]-128)/128;e+=i*i}return Math.sqrt(e/t.length)}static getPeakFrequency(){if(!x(this,$)||!x(this,oe))return 0;const t=this.getFrequency();let e=0,s=0;for(let n=0;n<t.length;n++)t[n]>s&&(s=t[n],e=n);const i=x(this,oe).sampleRate/2;return e*i/x(this,$).frequencyBinCount}static dispose(){x(this,$)&&(x(this,$).disconnect(),N(this,$,null)),N(this,Wt,null),N(this,Nt,null)}}oe=new WeakMap;$=new WeakMap;Wt=new WeakMap;Nt=new WeakMap;O(Gt,oe,null);O(Gt,$,null);O(Gt,Wt,null);O(Gt,Nt,null);class Ie{static init(t={}){if(x(this,Zt)){console.warn("[Synth] Already initialized");return}const{masterVolume:e=.5,sampleRate:s=44100,enableAnalyzer:i=!1}=t;try{N(this,j,new(window.AudioContext||window.webkitAudioContext)({sampleRate:s})),N(this,ct,x(this,j).createGain()),x(this,ct).gain.value=e,x(this,ct).connect(x(this,j).destination),de.init(x(this,j),x(this,ct)),ge.init(x(this,j),x(this,ct)),i&&Gt.init(x(this,j),x(this,ct)),N(this,Zt,!0),console.log("[Synth] Audio system initialized")}catch(n){console.error("[Synth] Failed to initialize audio:",n)}}static get isInitialized(){return x(this,Zt)}static get ctx(){return x(this,j)}static get master(){return x(this,ct)}static get osc(){return de}static get fx(){return ge}static get env(){return Je}static get noise(){return ri}static get music(){return ve}static get analyzer(){return Gt}static async resume(){x(this,j)&&x(this,j).state==="suspended"&&(await x(this,j).resume(),console.log("[Synth] Audio context resumed"))}static async suspend(){x(this,j)&&x(this,j).state==="running"&&await x(this,j).suspend()}static get now(){return x(this,j)?x(this,j).currentTime:0}static get state(){return x(this,j)?x(this,j).state:"closed"}static set volume(t){x(this,ct)&&x(this,ct).gain.setValueAtTime(Math.max(0,Math.min(1,t)),x(this,j).currentTime)}static get volume(){return x(this,ct)?x(this,ct).gain.value:0}static chain(...t){for(let e=0;e<t.length-1;e++)t[e].connect(t[e+1]);return{first:t[0],last:t[t.length-1],connectTo:e=>t[t.length-1].connect(e)}}static schedule(t,e){const s=Math.max(0,(e-this.now)*1e3);return setTimeout(t,s)}static async close(){x(this,j)&&(Gt.dispose(),await x(this,j).close(),N(this,j,null),N(this,ct,null),N(this,Zt,!1),console.log("[Synth] Audio system closed"))}}j=new WeakMap;ct=new WeakMap;Zt=new WeakMap;O(Ie,j,null);O(Ie,ct,null);O(Ie,Zt,!1);class Qe{constructor(t={}){this.states=t.states||{},this.currentState=null,this.previousState=null,this.stateTime=0,this.context=t.context||null,this.paused=!1,this.onStateChange=null,t.initial&&this.setState(t.initial)}get state(){return this.currentState}get currentStateConfig(){return this.currentState?this.states[this.currentState]:null}is(t){return this.currentState===t}isAny(...t){return t.includes(this.currentState)}addState(t,e){return this.states[t]=e,this}removeState(t){return delete this.states[t],this}setState(t,e){if(!this.states[t])return console.warn(`StateMachine: Unknown state '${t}'`),!1;if(this.currentState){const i=this.states[this.currentState];i!=null&&i.exit&&this._call(i.exit,e)}this.previousState=this.currentState,this.currentState=t,this.stateTime=0;const s=this.states[t];return s!=null&&s.enter&&this._call(s.enter,e),this.onStateChange&&this.onStateChange(t,this.previousState,e),!0}trigger(t,e){const s=this.currentStateConfig;if(!(s!=null&&s.on))return!1;const i=s.on[t];return i?typeof i=="string"?this.setState(i,e):i.guard&&!this._call(i.guard,e)?!1:(i.action&&this._call(i.action,e),i.target?this.setState(i.target,e):!1):!1}update(t){if(this.paused||!this.currentState)return;this.stateTime+=t;const e=this.states[this.currentState];e&&(e.update&&this._call(e.update,t),e.duration!==void 0&&this.stateTime>=e.duration&&(e.next?this.setState(e.next):e.onComplete&&this._call(e.onComplete)))}get progress(){const t=this.currentStateConfig;return t!=null&&t.duration?Math.min(1,this.stateTime/t.duration):0}get remaining(){const t=this.currentStateConfig;return t!=null&&t.duration?Math.max(0,t.duration-this.stateTime):1/0}get isTimed(){var t;return((t=this.currentStateConfig)==null?void 0:t.duration)!==void 0}pause(){this.paused=!0}resume(){this.paused=!1}reset(t){if(this.stateTime=0,this.previousState=null,t)this.setState(t);else{const e=Object.keys(this.states)[0];e&&this.setState(e)}}_call(t,...e){if(typeof t=="function")return this.context?t.call(this.context,...e):t(...e)}static fromSequence(t,e={}){var s;const i={};for(let n=0;n<t.length;n++){const r=t[n],o=n===t.length-1,a=o?e.loop?t[0].name:null:t[n+1].name;i[r.name]={duration:r.duration,next:a,enter:r.enter,update:r.update,exit:r.exit,onComplete:o&&!e.loop?e.onComplete:void 0}}return new Qe({initial:(s=t[0])==null?void 0:s.name,states:i,context:e.context})}}export{yi as A,si as B,ai as C,qe as D,st as E,We as F,Di as G,Ti as H,Ai as I,Ri as J,Es as K,bi as L,H as M,bt as N,pi as O,y as P,wi as R,je as S,Tt as T,fe as U,Ze as W,hi as a,ni as b,oi as c,Pi as d,Ys as e,gi as f,ze as g,mi as h,Si as i,Qe as j,Ci as k,li as l,ki as m,Vt as n,Kt as o,xi as p,Mi as q,fi as r,ui as s,di as t,Ke as u,bs as v,vi as w,_i as x,ht as y,os as z};
