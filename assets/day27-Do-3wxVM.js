import{G as F,P as q,d as A}from"./index-BHpYPlok.js";const y=Math.PI*2,l={coreRadius:40,coreGlow:120,ribbonStartCount:2,ribbonMaxCount:12,ribbonSegments:80,ribbonWidth:6,ribbonOrbitRadius:100,ribbonSpeedMultiplier:5,foodParticlesPerClick:10,foodDriftSpeed:60,foodAbsorbRadius:50,complexityPerParticle:.002,gasCloudParticles:120,gasCloudRadius:220,gasCloudSpeed:.5,shieldRadiusMin:120,shieldRadiusMax:180,membraneDeformRadius:120,membraneDeformStrength:45,particleCount:150,particleRadius:180,starCount:300,timeScale:.4,ribbonPokeRadius:100,ribbonPokeStrength:800,ribbonReturnSpeed:2,ribbonDamping:.95,complexityDecayRate:.003,vitalityDecayRate:.05,vitalityRecoveryRate:.3,nebulaCount:5,nebulaMinSize:150,nebulaMaxSize:300,nebulaAlpha:.08,colorTransitionSpeed:.15};function T(w,t,e){w=(w%360+360)%360,t=(t%360+360)%360;let i=t-w;return Math.abs(i)>180&&(i=i>0?i-360:i+360),((w+i*e)%360+360)%360}function Y(w,t,e,i){const s=Math.cos(i),o=Math.sin(i);return{x:w*s+e*o,y:t,z:-w*o+e*s}}function X(w,t,e,i){const s=Math.cos(i),o=Math.sin(i);return{x:w,y:t*s-e*o,z:t*o+e*s}}function L(w,t,e,i){const s=Math.cos(i),o=Math.sin(i);return{x:w*s-t*o,y:w*o+t*s,z:e}}class O extends F{constructor(t){super(t),this.backgroundColor="#000"}init(){super.init(),q.init(this.ctx),A.init(this),this.scale=A.responsive(1,1.5,2),this.coreRadius=l.coreRadius*this.scale,this.coreGlow=l.coreGlow*this.scale,this.ribbonOrbitRadius=l.ribbonOrbitRadius*this.scale,this.shieldRadiusMin=l.shieldRadiusMin*this.scale,this.shieldRadiusMax=l.shieldRadiusMax*this.scale,this.particleRadius=l.particleRadius*this.scale,this.gasCloudRadius=l.gasCloudRadius*this.scale,this.time=0,this.rotationY=0,this.rotationX=.3,this.hue=Math.random()*360,this.ribbons=[],this.complexity=0,this.vitality=1;for(let e=0;e<l.ribbonStartCount;e++){const i=this.createRibbon(!1);i.growth=1,this.ribbons.push(i)}this.foodParticles=[],this.currentFoodHue=Math.random()*360,this.lastFeedTime=0,this.gasCloud=[];for(let e=0;e<l.gasCloudParticles;e++)this.gasCloud.push(this.createGasParticle());this.particles=[];for(let e=0;e<l.particleCount;e++){const i=Math.random()*y,s=Math.acos(2*Math.random()-1),o=this.particleRadius*(.5+Math.random()*.5);this.particles.push({x:o*Math.sin(s)*Math.cos(i),y:o*Math.sin(s)*Math.sin(i),z:o*Math.cos(s),vx:0,vy:0,vz:0,orbitRadius:o,size:1+Math.random()*2,twinkleSpeed:1+Math.random()*2,twinklePhase:Math.random()*y,orbitSpeed:(.2+Math.random()*.3)*(Math.random()<.5?1:-1),orbitAxis:{x:Math.random()-.5,y:Math.random()-.5,z:Math.random()-.5}})}this.nebulae=[];for(let e=0;e<l.nebulaCount;e++){const i=Math.random()*y,s=Math.acos(2*Math.random()-1),o=400+Math.random()*200;this.nebulae.push({x:o*Math.sin(s)*Math.cos(i),y:o*Math.sin(s)*Math.sin(i),z:o*Math.cos(s),size:l.nebulaMinSize+Math.random()*(l.nebulaMaxSize-l.nebulaMinSize),hue:Math.random()*360,drift:(Math.random()-.5)*.1,pulse:Math.random()*y,pulseSpeed:.2+Math.random()*.3})}this.stars=[];const t=800;for(let e=0;e<l.starCount;e++){const i=Math.random()*y,s=Math.acos(2*Math.random()-1);this.stars.push({x:t*Math.sin(s)*Math.cos(i),y:t*Math.sin(s)*Math.sin(i),z:t*Math.cos(s),size:.5+Math.random()*1.5,brightness:.3+Math.random()*.7,twinkleSpeed:.5+Math.random()*2,twinklePhase:Math.random()*y})}this.mouseX=this.width/2,this.mouseY=this.height/2,this.mouseActive=!1,this.membraneDeform={x:this.width/2,y:this.height/2,intensity:0,vx:0,vy:0,vIntensity:0},this.corePulse=0,this.lastFoodHue=this.hue,this.targetHue=this.hue,this.isDragging=!1,this.lastMouseX=0,this.lastMouseY=0,this.velocityX=0,this.velocityY=.1,this.touchStartX=0,this.touchStartY=0,this.touchStartTime=0,this.hasMoved=!1,this.canvas.addEventListener("mousedown",e=>{this.isDragging=!0,this.lastMouseX=e.clientX,this.lastMouseY=e.clientY}),this.canvas.addEventListener("mouseenter",()=>{this.mouseActive=!0}),this.canvas.addEventListener("mousemove",e=>{const i=this.canvas.getBoundingClientRect();if(this.mouseX=e.clientX-i.left,this.mouseY=e.clientY-i.top,this.mouseActive=!0,this.isDragging){const s=e.clientX-this.lastMouseX,o=e.clientY-this.lastMouseY;this.velocityY=s*.005,this.velocityX=o*.005,this.lastMouseX=e.clientX,this.lastMouseY=e.clientY}}),this.canvas.addEventListener("mouseup",()=>{this.isDragging=!1}),this.canvas.addEventListener("mouseleave",()=>{this.isDragging=!1,this.velocityY=.1,this.mouseX=this.width/2,this.mouseY=this.height/2,this.mouseActive=!1}),this.canvas.addEventListener("click",e=>{const i=this.canvas.getBoundingClientRect(),s=e.clientX-i.left,o=e.clientY-i.top;this.handleFeedClick(s,o)}),this.canvas.addEventListener("touchstart",e=>{e.preventDefault();const i=e.touches[0],s=this.canvas.getBoundingClientRect();this.touchStartX=i.clientX,this.touchStartY=i.clientY,this.touchStartTime=performance.now(),this.hasMoved=!1,this.mouseX=i.clientX-s.left,this.mouseY=i.clientY-s.top,this.mouseActive=!0,this.isDragging=!0,this.lastMouseX=i.clientX,this.lastMouseY=i.clientY},{passive:!1}),this.canvas.addEventListener("touchmove",e=>{e.preventDefault();const i=e.touches[0],s=this.canvas.getBoundingClientRect();this.mouseX=i.clientX-s.left,this.mouseY=i.clientY-s.top,this.mouseActive=!0;const o=i.clientX-this.touchStartX,a=i.clientY-this.touchStartY;if(Math.sqrt(o*o+a*a)>10&&(this.hasMoved=!0),this.isDragging){const r=i.clientX-this.lastMouseX,d=i.clientY-this.lastMouseY;this.velocityY=r*.005,this.velocityX=d*.005,this.lastMouseX=i.clientX,this.lastMouseY=i.clientY}},{passive:!1}),this.canvas.addEventListener("touchend",e=>{e.preventDefault();const i=performance.now()-this.touchStartTime;if(!this.hasMoved&&i<300){this.canvas.getBoundingClientRect();const s=this.mouseX,o=this.mouseY;this.handleFeedClick(s,o)}this.isDragging=!1,this.mouseX=this.width/2,this.mouseY=this.height/2,this.mouseActive=!1},{passive:!1}),this.canvas.addEventListener("touchcancel",()=>{this.isDragging=!1,this.mouseX=this.width/2,this.mouseY=this.height/2,this.mouseActive=!1}),this._onKeyDown=e=>{(e.key==="r"||e.key==="R")&&this.restart()},window.addEventListener("keydown",this._onKeyDown)}restart(){this.time=0,this.hue=Math.random()*360,this.targetHue=this.hue,this.complexity=0,this.vitality=1,this.corePulse=0,this.ribbons=[];for(let t=0;t<l.ribbonStartCount;t++){const e=this.createRibbon(!1);e.growth=1,this.ribbons.push(e)}this.foodParticles=[],this.gasCloud=[];for(let t=0;t<l.gasCloudParticles;t++)this.gasCloud.push(this.createGasParticle());for(const t of this.particles){const e=Math.random()*y,i=Math.acos(2*Math.random()-1),s=this.particleRadius*(.5+Math.random()*.5);t.x=s*Math.sin(i)*Math.cos(e),t.y=s*Math.sin(i)*Math.sin(e),t.z=s*Math.cos(i),t.vx=0,t.vy=0,t.vz=0,t.orbitRadius=s}console.log("Restarted")}stop(){super.stop(),this._onKeyDown&&window.removeEventListener("keydown",this._onKeyDown)}update(t){if(super.update(t),this.time+=t*l.timeScale,Math.abs(this.hue-this.targetHue)>.1?this.hue=T(this.hue,this.targetHue,l.colorTransitionSpeed*t):this.hue=this.targetHue,this.rotationX+=this.velocityX,this.rotationY+=this.velocityY,this.isDragging||(this.velocityX*=.95,this.velocityY*=.95,Math.abs(this.velocityY)<.001&&Math.abs(this.velocityX)<.001&&(this.velocityY=.002)),this.updateFood(t),this.complexity>0){this.complexity-=l.complexityDecayRate*t,this.complexity=Math.max(0,this.complexity);const e=l.ribbonStartCount+Math.floor(this.complexity);let i=this.ribbons.filter(s=>s.targetGrowth===1).length;for(;i>e&&i>l.ribbonStartCount;)for(let s=this.ribbons.length-1;s>=0;s--)if(this.ribbons[s].targetGrowth===1){this.ribbons[s].targetGrowth=0,i--;break}}if(this.complexity===0&&this.ribbons.filter(e=>e.targetGrowth===1).length<=l.ribbonStartCount){if(this.vitality-=l.vitalityDecayRate*t,this.vitality=Math.max(0,this.vitality),this.vitality<.5&&this.ribbons.filter(i=>i.targetGrowth===1).length>1){for(let i=this.ribbons.length-1;i>=0;i--)if(this.ribbons[i].targetGrowth===1){this.ribbons[i].targetGrowth=0;break}}if(this.vitality<.2)for(const e of this.ribbons)e.targetGrowth=0}this.updateRibbonGrowth(t),this.updateMembranePhysics(t),this.updateParticles(t),this.corePulse*=.92}updateRibbonGrowth(t){for(let e=this.ribbons.length-1;e>=0;e--){const i=this.ribbons[e];i.growth<i.targetGrowth?(i.growth+=i.growthSpeed*t,i.growth=Math.min(i.growth,i.targetGrowth)):i.growth>i.targetGrowth&&(i.growth-=i.growthSpeed*.7*t,i.growth=Math.max(i.growth,i.targetGrowth),i.growth<=.01&&this.ribbons.splice(e,1))}}updateParticles(t){const e=80*this.vitality,i=30*(1-this.vitality);for(const s of this.particles){const o=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z);if(o<1)continue;const a=s.x/o,n=s.y/o,r=s.z/o;if(this.vitality>.2){const c=s.orbitRadius*(.8+this.vitality*.4),M=(o-c)*2*t;s.vx-=a*M*e*t,s.vy-=n*M*e*t,s.vz-=r*M*e*t;const u=s.orbitAxis.y*r-s.orbitAxis.z*n,h=s.orbitAxis.z*a-s.orbitAxis.x*r,g=s.orbitAxis.x*n-s.orbitAxis.y*a,p=Math.sqrt(u*u+h*h+g*g)||1;s.vx+=u/p*s.orbitSpeed*this.vitality*t*50,s.vy+=h/p*s.orbitSpeed*this.vitality*t*50,s.vz+=g/p*s.orbitSpeed*this.vitality*t*50}else s.vx+=a*i*t,s.vy+=n*i*t+10*t,s.vz+=r*i*t;s.vx*=.98,s.vy*=.98,s.vz*=.98,s.x+=s.vx*t,s.y+=s.vy*t,s.z+=s.vz*t;const d=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z),b=this.particleRadius*2.5;if(d>b){const c=b/d;s.x*=c,s.y*=c,s.z*=c,s.vx*=-.3,s.vy*=-.3,s.vz*=-.3}}}updateMembranePhysics(t){const e=this.width/2,i=this.height/2,s=this.membraneDeform,o=this.getShieldRadius(),a=this.mouseX-e,n=this.mouseY-i,r=Math.sqrt(a*a+n*n);this.mouseActive&&r>o*.5&&r<o*1.5?(s.x=this.mouseX,s.y=this.mouseY,s.intensity=1,s.vx=0,s.vy=0,s.vIntensity=0):(s.vx+=(e-s.x)*5*t,s.vy+=(i-s.y)*5*t,s.vIntensity+=(0-s.intensity)*4*t,s.vx*=.92,s.vy*=.92,s.vIntensity*=.85,s.x+=s.vx,s.y+=s.vy,s.intensity+=s.vIntensity),s.intensity=Math.max(-.5,Math.min(1.5,s.intensity))}updateFood(t){const e=this.width/2,i=this.height/2;for(let s=this.foodParticles.length-1;s>=0;s--){const o=this.foodParticles[s],a=e-o.x,n=i-o.y,r=Math.sqrt(a*a+n*n);if(r>1){const d=a/r*l.foodDriftSpeed,b=n/r*l.foodDriftSpeed;o.vx+=d*t,o.vy+=b*t}o.vx*=.98,o.vy*=.98,o.x+=o.vx*t,o.y+=o.vy*t,r<this.getShieldRadius()&&(o.size*=.97,o.alpha*=.98),(r<l.foodAbsorbRadius||o.size<1||o.alpha<.05)&&(this.corePulse=Math.min(this.corePulse+.3,1),this.lastFoodHue=o.hue,this.targetHue=o.hue,this.foodParticles.splice(s,1),this.onFoodAbsorbed())}}onFoodAbsorbed(){if(this.vitality+=l.vitalityRecoveryRate,this.vitality=Math.min(1,this.vitality),this.ribbons.length<l.ribbonStartCount&&this.ribbons.push(this.createRibbon(!1)),this.complexity+=l.complexityPerParticle,this.ribbons.length<l.ribbonMaxCount){const t=l.ribbonStartCount+Math.floor(this.complexity);this.ribbons.length<t&&this.ribbons.push(this.createRibbon(!0))}for(const t of this.ribbons)t.speed=Math.min(t.speed*1.001,1.2)}createRibbon(t=!1){const e=[];for(let i=0;i<=l.ribbonSegments;i++)e.push({offsetX:0,offsetY:0,velocityX:0,velocityY:0});return t?{tiltX:(Math.random()-.5)*3,tiltZ:(Math.random()-.5)*3,phase:Math.random()*y,speed:.3+Math.random()*.7,radius:this.ribbonOrbitRadius*(.5+Math.random()*.7),freqA:1+Math.floor(Math.random()*4),freqB:1+Math.floor(Math.random()*5),freqC:1+Math.floor(Math.random()*4),deformState:e,growth:0,targetGrowth:1,growthSpeed:.8+Math.random()*.4}:{tiltX:(Math.random()-.5)*1.5,tiltZ:(Math.random()-.5)*1.5,phase:Math.random()*y,speed:.2+Math.random()*.3,radius:this.ribbonOrbitRadius*(.8+Math.random()*.4),freqA:1,freqB:2,freqC:1,deformState:e,growth:0,targetGrowth:1,growthSpeed:.6+Math.random()*.3}}handleFeedClick(t,e){const i=this.width/2,s=this.height/2;if(Math.sqrt((t-i)**2+(e-s)**2)>this.getShieldRadius()){let a=null;for(const n of this.nebulae){if(n.screenX===void 0)continue;const r=t-n.screenX,d=e-n.screenY;if(Math.sqrt(r*r+d*d)<n.screenSize*.8){a=n;break}}this.spawnFood(t,e,a)}}spawnFood(t,e,i=null){const s=performance.now();i?this.currentFoodHue=i.hue:s-this.lastFeedTime>500&&(this.currentFoodHue=Math.random()*360),this.lastFeedTime=s;for(let o=0;o<l.foodParticlesPerClick;o++){const a=Math.random()*y,n=Math.random()*20,r=t+Math.cos(a)*n,d=e+Math.sin(a)*n;this.foodParticles.push({x:r,y:d,size:3+Math.random()*5,alpha:.5+Math.random()*.4,hue:this.currentFoodHue+(Math.random()-.5)*15,vx:0,vy:0})}}getShieldRadius(){const t=l.ribbonMaxCount-l.ribbonStartCount,e=Math.min(this.complexity/t,1);return this.shieldRadiusMin+e*(this.shieldRadiusMax-this.shieldRadiusMin)}resetRibbonDeform(){for(const t of this.ribbons)for(const e of t.deformState)e.velocityX=0,e.velocityY=0,e.offsetX=0,e.offsetY=0}createGasParticle(t=!0){const e=Math.random()*y,i=Math.acos(2*Math.random()-1),s=this.getShieldRadius()*(.9+Math.random()*.3);return{theta:e,phi:i,radius:s,life:t?Math.random():0,maxLife:1,size:25+Math.random()*40,baseAlpha:.05+Math.random()*.06,speed:25+Math.random()*35,drift:(Math.random()-.5)*.3}}render(){const t=this.ctx,e=this.width,i=this.height,s=e/2,o=i/2;t.fillStyle="#010208",t.fillRect(0,0,e,i),this.renderNebulae(t,e,i),this.renderStars(t,e,i),this.renderFood(t),this.renderGasCloud(t,s,o);const a=t.createRadialGradient(s,o,0,s,o,this.coreGlow*2);a.addColorStop(0,`hsla(${this.hue}, 70%, 70%, 0.15)`),a.addColorStop(.5,`hsla(${this.hue}, 60%, 50%, 0.05)`),a.addColorStop(1,"transparent"),t.fillStyle=a,t.fillRect(0,0,e,i),this.renderShield(t,s,o,!1),this.renderParticles(t,s,o),this.renderRibbons(t,s,o),this.renderCore(t,s,o),this.renderShield(t,s,o,!0)}renderNebulae(t,e,i){const s=e/2,o=i/2,a=this.time;for(const n of this.nebulae){const r=X(n.x,n.y,n.z,this.rotationX),d=Y(r.x,r.y,r.z,this.rotationY);if(d.z<100)continue;const b=600/d.z,c=s+d.x*b,M=o+d.y*b,u=n.size*b;if(c<-u||c>e+u||M<-u||M>i+u)continue;const h=.8+.2*Math.sin(a*n.pulseSpeed+n.pulse),g=l.nebulaAlpha*h,p=3;for(let f=0;f<p;f++){const m=u*(.6+f*.3),v=g*(1-f*.3),C=Math.sin(a*.1+f+n.pulse)*u*.1,S=Math.cos(a*.08+f+n.pulse)*u*.1,R=t.createRadialGradient(c+C,M+S,0,c+C,M+S,m);R.addColorStop(0,`hsla(${n.hue+f*15}, 60%, 50%, ${v})`),R.addColorStop(.3,`hsla(${n.hue+f*10}, 50%, 40%, ${v*.5})`),R.addColorStop(.6,`hsla(${n.hue}, 40%, 30%, ${v*.2})`),R.addColorStop(1,"transparent"),t.fillStyle=R,t.beginPath(),t.arc(c+C,M+S,m,0,y),t.fill()}n.screenX=c,n.screenY=M,n.screenSize=u}}renderStars(t,e,i){const s=this.time,o=e/2,a=i/2;for(const n of this.stars){const r=X(n.x,n.y,n.z,this.rotationX),d=Y(r.x,r.y,r.z,this.rotationY);if(d.z<0)continue;const b=o+d.x*(e/800),c=a+d.y*(i/800);if(b<0||b>e||c<0||c>i)continue;const M=.5+.5*Math.sin(s*n.twinkleSpeed+n.twinklePhase),u=n.brightness*(.4+M*.6),h=n.twinklePhase,g=200+Math.sin(h)*55,p=210+Math.sin(h+1)*45,f=230+Math.sin(h+2)*25;t.fillStyle=`rgba(${Math.floor(g)}, ${Math.floor(p)}, ${Math.floor(f)}, ${u})`,t.beginPath(),t.arc(b,c,n.size,0,y),t.fill(),n.brightness>.6&&n.size>1&&(t.fillStyle=`rgba(${Math.floor(g)}, ${Math.floor(p)}, ${Math.floor(f)}, ${u*.2})`,t.beginPath(),t.arc(b,c,n.size*3,0,y),t.fill())}}renderCore(t,e,i){const s=this.corePulse,o=this.vitality;if(o<.3){const h=this.coreRadius*.8,g=.15+o/.3*.15,p=t.createRadialGradient(e,i,0,e,i,h);p.addColorStop(0,"transparent"),p.addColorStop(.5,"transparent"),p.addColorStop(.7,`hsla(${this.hue}, 30%, 40%, ${g*.5})`),p.addColorStop(.85,`hsla(${this.hue}, 40%, 50%, ${g})`),p.addColorStop(1,"transparent"),t.fillStyle=p,t.beginPath(),t.arc(e,i,h,0,y),t.fill();const f=t.createRadialGradient(e,i,h*.8,e,i,h*2);f.addColorStop(0,"transparent"),f.addColorStop(.3,`hsla(${this.hue}, 30%, 35%, ${g*.3})`),f.addColorStop(.6,`hsla(${this.hue}, 25%, 30%, ${g*.15})`),f.addColorStop(1,"transparent"),t.fillStyle=f,t.beginPath(),t.arc(e,i,h*2,0,y),t.fill();return}const a=this.coreGlow*(1+s*.5)*(.3+o*.7),n=this.coreRadius*(1+s*.3)*(.5+o*.5),r=30+o*70,d=20+o*60,b=.2+o*.8,c=t.createRadialGradient(e,i,0,e,i,a);if(c.addColorStop(0,`rgba(255, 255, 255, ${b})`),c.addColorStop(.2,`hsla(${this.hue}, ${d}%, ${r}%, ${.8*b})`),c.addColorStop(.4,`hsla(${this.hue}, ${d*.9}%, ${r*.6}%, ${.4*b})`),c.addColorStop(.7,`hsla(${this.hue}, ${d*.8}%, ${r*.5}%, ${.1*b})`),c.addColorStop(1,"transparent"),t.fillStyle=c,t.beginPath(),t.arc(e,i,a,0,y),t.fill(),s>.05){const h=t.createRadialGradient(e,i,0,e,i,a*.8);h.addColorStop(0,`hsla(${this.lastFoodHue}, 80%, 70%, ${s*.6})`),h.addColorStop(.5,`hsla(${this.lastFoodHue}, 70%, 50%, ${s*.3})`),h.addColorStop(1,"transparent"),t.fillStyle=h,t.beginPath(),t.arc(e,i,a*.8,0,y),t.fill()}const M=t.createRadialGradient(e,i,0,e,i,n),u=Math.floor(100+o*155);M.addColorStop(0,`rgba(${u}, ${u}, ${u}, ${b})`),M.addColorStop(.4,`hsla(${this.hue}, ${d}%, ${r}%, ${.8*b})`),M.addColorStop(.7,`hsla(${this.hue}, ${d*.9}%, ${r*.7}%, ${.3*b})`),M.addColorStop(1,"transparent"),t.fillStyle=M,t.beginPath(),t.arc(e,i,n,0,y),t.fill()}renderRibbons(t,e,i){const s=this.time,o=1/60;for(const a of this.ribbons){if(a.growth<=.01)continue;const n=[];for(let h=0;h<=l.ribbonSegments;h++){const p=h/l.ribbonSegments*y+s*a.speed*l.ribbonSpeedMultiplier+a.phase;let f=Math.cos(p*a.freqA)*a.radius,m=Math.sin(p*a.freqB)*a.radius*.6,v=Math.sin(p*a.freqC)*a.radius*.8;const C=X(f,m,v,a.tiltX),S=L(C.x,C.y,C.z,a.tiltZ),R=X(S.x,S.y,S.z,this.rotationX),z=Y(R.x,R.y,R.z,this.rotationY);n.push({x:z.x,y:z.y,z:z.z,t:h/l.ribbonSegments})}const r=a.growth,d=n.map((h,g)=>{const p=e+h.x,f=i+h.y,m=a.deformState[g];if(this.mouseActive){const D=p-this.mouseX,G=f-this.mouseY,P=Math.sqrt(D*D+G*G),x=l.ribbonPokeRadius;if(P<x&&P>1){const k=Math.pow(1-P/x,2)*l.ribbonPokeStrength*o;m.velocityX+=D/P*k,m.velocityY+=G/P*k}}m.velocityX-=m.offsetX*l.ribbonReturnSpeed*o,m.velocityY-=m.offsetY*l.ribbonReturnSpeed*o,m.velocityX*=l.ribbonDamping,m.velocityY*=l.ribbonDamping,m.offsetX+=m.velocityX*o,m.offsetY+=m.velocityY*o;let v=p+m.offsetX,C=f+m.offsetY;const S=v-e,R=C-i,z=Math.sqrt(S*S+R*R),$=this.getShieldRadius()-10;return z>$&&(v=e+S/z*$,C=i+R/z*$,m.offsetX=v-p,m.offsetY=C-f,m.velocityX*=-.3,m.velocityY*=-.3),{x:v,y:C,z:h.z}});t.lineCap="round",t.lineJoin="round";const b=d.length-1,c=Math.floor(r*b),M=r>=.99?b:Math.min(c,Math.floor(b*.4)),u=r>=.99?0:Math.max(0,c-M);for(let h=3;h>=0;h--){const g=l.ribbonWidth+h*6,p=h===0?.9:.15/(h+1);t.strokeStyle=`hsla(${this.hue}, 70%, 65%, ${p})`,t.lineWidth=g,t.beginPath();let f=!1;for(let m=u;m<=c&&m<d.length;m++){const v=d[m];f?t.lineTo(v.x,v.y):(t.moveTo(v.x,v.y),f=!0)}t.stroke()}t.globalCompositeOperation="lighter";for(let h=u;h<c&&h<d.length-1;h++){const g=d[h],p=d[h+1];if(n[h].z>0){const f=n[h].z/a.radius*.5;t.strokeStyle=`rgba(255, 255, 255, ${f})`,t.lineWidth=l.ribbonWidth*.5,t.beginPath(),t.moveTo(g.x,g.y),t.lineTo(p.x,p.y),t.stroke()}}t.globalCompositeOperation="source-over"}}renderParticles(t,e,i){const s=this.time;t.globalCompositeOperation="lighter";for(const o of this.particles){const a=X(o.x,o.y,o.z,this.rotationX),n=Y(a.x,a.y,a.z,this.rotationY),r=e+n.x,d=i+n.y,b=.3+.7*(.5+.5*Math.sin(s*o.twinkleSpeed+o.twinklePhase)),c=Math.sqrt(o.x*o.x+o.y*o.y+o.z*o.z),M=.3+.7*((n.z+c)/(c*2+1)),u=b*M*.6;t.fillStyle=`hsla(${this.hue}, 70%, 75%, ${u})`,t.beginPath(),t.arc(r,d,o.size,0,y),t.fill()}t.globalCompositeOperation="source-over"}renderFood(t){t.globalCompositeOperation="lighter";for(const e of this.foodParticles){const i=t.createRadialGradient(e.x,e.y,0,e.x,e.y,e.size);i.addColorStop(0,`hsla(${e.hue}, 80%, 60%, ${e.alpha})`),i.addColorStop(.4,`hsla(${e.hue}, 70%, 50%, ${e.alpha*.5})`),i.addColorStop(1,"transparent"),t.fillStyle=i,t.beginPath(),t.arc(e.x,e.y,e.size,0,y),t.fill()}t.globalCompositeOperation="source-over"}renderGasCloud(t,e,i){if(this.vitality<.1)return;const s=1/60;t.globalCompositeOperation="lighter";for(let o=0;o<this.gasCloud.length;o++){const a=this.gasCloud[o];if(a.life+=s*l.gasCloudSpeed,a.radius+=a.speed*s,a.theta+=a.drift*s,a.life>=a.maxLife){this.gasCloud[o]=this.createGasParticle(!1);continue}const n=a.life/a.maxLife,r=Math.min(n*4,1),d=1-Math.pow(n,2),b=r*d;let c=a.radius*Math.sin(a.phi)*Math.cos(a.theta),M=a.radius*Math.sin(a.phi)*Math.sin(a.theta),u=a.radius*Math.cos(a.phi);const h=X(c,M,u,this.rotationX),g=Y(h.x,h.y,h.z,this.rotationY),p=e+g.x,f=i+g.y,m=.4+.6*((g.z+a.radius)/(a.radius*2)),v=a.baseAlpha*b*m*this.vitality,C=a.size*(1+n*.8),S=t.createRadialGradient(p,f,0,p,f,C);S.addColorStop(0,`hsla(${this.hue}, 70%, 70%, ${v})`),S.addColorStop(.3,`hsla(${this.hue}, 60%, 55%, ${v*.6})`),S.addColorStop(.6,`hsla(${this.hue}, 50%, 45%, ${v*.25})`),S.addColorStop(1,"transparent"),t.fillStyle=S,t.beginPath(),t.arc(p,f,C,0,y),t.fill()}t.globalCompositeOperation="source-over"}getMembraneDeform(t,e,i,s){const o=this.membraneDeform;if(Math.abs(o.intensity)<.01)return{x:0,y:0};const a=t-o.x,n=e-o.y,r=Math.sqrt(a*a+n*n),d=l.membraneDeformRadius;if(r>d)return{x:0,y:0};const c=Math.cos(r/d*Math.PI*.5)*l.membraneDeformStrength*o.intensity,M=t-i,u=e-s,h=Math.sqrt(M*M+u*u)||1;return{x:M/h*c,y:u/h*c}}renderShield(t,e,i,s){const o=this.getShieldRadius();t.globalCompositeOperation="lighter";const a=8;for(let r=1;r<a;r++){const d=r/a*Math.PI,b=Math.sin(d)*o,c=Math.cos(d)*o,M=48;t.beginPath();let u=!1;for(let g=0;g<=M;g++){const p=g/M*y;let f=Math.cos(p)*b,m=Math.sin(p)*b;const C=X(f,m,c,this.rotationX),S=Y(C.x,C.y,C.z,this.rotationY);if(s&&S.z<0){u=!1;continue}if(!s&&S.z>=0){u=!1;continue}let R=e+S.x,z=i+S.y;const $=this.getMembraneDeform(R,z,e,i);R+=$.x,z+=$.y,u?t.lineTo(R,z):(t.moveTo(R,z),u=!0)}const h=Math.sin(d)*.3;t.strokeStyle=`hsla(${this.hue}, 60%, 65%, ${h})`,t.lineWidth=1,t.stroke()}const n=12;for(let r=0;r<n;r++){const d=r/n*y,b=32;t.beginPath();let c=!1;for(let M=0;M<=b;M++){const u=M/b*Math.PI;let h=Math.sin(u)*Math.cos(d)*o,g=Math.sin(u)*Math.sin(d)*o,p=Math.cos(u)*o;const f=X(h,g,p,this.rotationX),m=Y(f.x,f.y,f.z,this.rotationY);if(s&&m.z<0){c=!1;continue}if(!s&&m.z>=0){c=!1;continue}let v=e+m.x,C=i+m.y;const S=this.getMembraneDeform(v,C,e,i);v+=S.x,C+=S.y,c?t.lineTo(v,C):(t.moveTo(v,C),c=!0)}t.strokeStyle=`hsla(${this.hue}, 60%, 65%, 0.2)`,t.lineWidth=1,t.stroke()}if(s){const r=t.createRadialGradient(e,i,o*.7,e,i,o*1.1);r.addColorStop(0,"transparent"),r.addColorStop(.7,`hsla(${this.hue}, 60%, 65%, 0.05)`),r.addColorStop(.9,`hsla(${this.hue}, 60%, 65%, 0.15)`),r.addColorStop(1,"transparent"),t.fillStyle=r,t.beginPath(),t.arc(e,i,o*1.1,0,y),t.fill()}t.globalCompositeOperation="source-over"}}function I(w){const t=new O(w);return t.start(),{stop:()=>t.stop(),game:t}}export{I as default};
