import{G as J,P as K,C as Q,l as V}from"./index-BHpYPlok.js";const s={background:"#000",maxDepth:3,colors:{stroke:"#0f0"},camera:{perspective:800,rotationX:.5,rotationY:-.6,inertia:!0,friction:.92,clampX:!1},animation:{autoRotateSpeed:.2,zoomSpeed:.06,zoomMin:.3,zoomMax:20,buildDelay:.008}};function R(d,t,i,l,a,e,o=[]){if(a>=e)return o.push({x:d,y:t,z:i,size:l,depth:a}),o;const c=l/3,n=l/3;for(let m=-1;m<=1;m++)for(let r=-1;r<=1;r++)for(let h=-1;h<=1;h++){if((m===0?1:0)+(r===0?1:0)+(h===0?1:0)>=2)continue;const p=d+m*n,z=t+r*n,x=i+h*n;R(p,z,x,c,a+1,e,o)}return o}class _ extends J{constructor(t){super(t),this.backgroundColor=s.background}init(){super.init(),K.init(this.ctx),this.camera=new Q({perspective:s.camera.perspective,rotationX:s.camera.rotationX,rotationY:s.camera.rotationY,inertia:s.camera.inertia,friction:s.camera.friction,clampX:s.camera.clampX}),this.camera.enableMouseControl(this.canvas),this.time=0,this.zoom=1,this.targetZoom=1,this.autoZoom=!0,this.zoomDirection=1,this.globalRotation=0,this.buildProgress=0,this.cubesBuilt=0,this.generateSponge(),this.canvas.addEventListener("click",()=>{this.autoZoom=!this.autoZoom,this.autoZoom||(this.targetZoom=this.zoom)}),this.canvas.addEventListener("wheel",t=>{t.preventDefault(),this.autoZoom=!1;const i=t.deltaY>0?.9:1.1;this.targetZoom=Math.max(s.animation.zoomMin,Math.min(s.animation.zoomMax,this.targetZoom*i))},{passive:!1})}generateSponge(){const i=Math.min(this.width,this.height)*.4,l=R(0,0,0,i,0,s.maxDepth);l.sort((a,e)=>a.depth-e.depth),this.cubes=l.map((a,e)=>{const o=a.depth/s.maxDepth,c=135,n=12+o*8;return{cube:new V(a.size*.95,{x:a.x,y:a.y,z:a.z,camera:this.camera,faceColors:{front:`hsl(${c}, 100%, ${n}%)`,back:`hsl(${c}, 100%, ${n}%)`,top:`hsl(${c}, 100%, ${n+2}%)`,bottom:`hsl(${c}, 100%, ${n-2}%)`,left:`hsl(${c}, 100%, ${n}%)`,right:`hsl(${c}, 100%, ${n}%)`},stroke:s.colors.stroke,lineWidth:1}),depth:a.depth,buildDelay:e*s.animation.buildDelay,visible:!1,scale:0}}),this.buildProgress=0,this.cubesBuilt=0}update(t){super.update(t),this.time+=t,this.camera.update(t),this.globalRotation+=s.animation.autoRotateSpeed*t,this.autoZoom&&(this.targetZoom+=this.zoomDirection*s.animation.zoomSpeed*t,this.targetZoom>=s.animation.zoomMax?this.zoomDirection=-1:this.targetZoom<=s.animation.zoomMin&&(this.zoomDirection=1)),this.zoom+=(this.targetZoom-this.zoom)*.05,this.buildProgress+=t;for(const i of this.cubes)!i.visible&&this.buildProgress>i.buildDelay&&(i.visible=!0,this.cubesBuilt++),i.visible&&i.scale<1&&(i.scale=Math.min(1,i.scale+t*3)),i.cube.selfRotationY=this.globalRotation}render(){this.ctx.fillStyle="#000",this.ctx.fillRect(0,0,this.width,this.height);const t=this.ctx,i=this.width/2,l=this.height/2,a=[];for(const e of this.cubes){if(!e.visible)continue;const o=e.cube,c=e.scale*this.zoom,n=o.x*this.zoom,m=o.y*this.zoom,r=o.z*this.zoom,h=o.size*c/this.zoom,f=this.getCubeFaces(n,m,r,h,o);a.push(...f)}a.sort((e,o)=>o.depth-e.depth),t.save(),t.translate(i,l);for(const e of a){t.beginPath(),t.moveTo(e.vertices[0].x,e.vertices[0].y);for(let o=1;o<e.vertices.length;o++)t.lineTo(e.vertices[o].x,e.vertices[o].y);t.closePath(),t.fillStyle=e.color,t.fill(),t.strokeStyle=s.colors.stroke,t.lineWidth=1,t.stroke()}t.restore(),t.fillStyle=s.colors.stroke,t.font="12px monospace",t.textAlign="left",t.fillText(`MENGER SPONGE | Depth: ${s.maxDepth} | Cubes: ${this.cubesBuilt}/${this.cubes.length}`,10,this.height-10),t.textAlign="right",t.fillText(`Zoom: ${this.zoom.toFixed(2)}x | ${this.autoZoom?"AUTO":"MANUAL"}`,this.width-10,this.height-10)}getCubeFaces(t,i,l,a,e){const o=a/2,c=[],n=[{name:"front",corners:[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1]],normal:[0,0,-1]},{name:"back",corners:[[1,-1,1],[-1,-1,1],[-1,1,1],[1,1,1]],normal:[0,0,1]},{name:"top",corners:[[-1,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1]],normal:[0,-1,0]},{name:"bottom",corners:[[-1,1,-1],[1,1,-1],[1,1,1],[-1,1,1]],normal:[0,1,0]},{name:"left",corners:[[-1,-1,1],[-1,-1,-1],[-1,1,-1],[-1,1,1]],normal:[-1,0,0]},{name:"right",corners:[[1,-1,-1],[1,-1,1],[1,1,1],[1,1,-1]],normal:[1,0,0]}],m=this.globalRotation,r=Math.cos(m),h=Math.sin(m);for(const f of n){let[p,z,x]=f.normal;const y=p*r-x*h,D=p*h+x*r,P=Math.cos(this.camera.rotationY),L=Math.sin(this.camera.rotationY),A=Math.cos(this.camera.rotationX),E=Math.sin(this.camera.rotationX);let F=y*L+D*P;const $=z*E+F*A;if($>.01)continue;const Z=.5,S=-.8,Y=-.6,G=Math.sqrt(Z**2+S**2+Y**2),T=-(y*Z+z*S+D*Y)/G,B=Math.max(0,T),N=Math.pow(1-Math.abs($),2)*.3,C=.2+B*.6+N,u=f.corners.map(([v,M,W])=>{let g=v*o,w=M*o,b=W*o;const j=g*r-b*h,H=g*h+b*r;return g=j,b=H,g+=t,w+=i,b+=l,this.camera.project(g,w,b)}),O=u.reduce((v,M)=>v+M.z,0)/u.length,q=Math.round(10+C*30),I=`hsl(135, ${100-C*20}%, ${q}%)`,k=u[1].x-u[0].x,X=u[1].y-u[0].y,U=Math.sqrt(k*k+X*X);c.push({vertices:u,depth:O,color:I,name:f.name,size:U})}return c}onResize(){this.cubes&&this.generateSponge()}}function et(d){const t=new _(d);return t.start(),{stop:()=>t.stop(),game:t}}export{et as default};
