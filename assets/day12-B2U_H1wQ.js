import{G as b,P as M,m as D,n as Y,K as C,o as W,E}from"./index-D3AXu9BF.js";const u={background:"#000",colors:{primary:["#D40920","#1356A2","#F7D842"],neutral:"#F2F5F1",line:"#111"},iso:{gridSize:10,elevationScale:1,tileRatio:.052},subdivision:{step:1,splitProbability:.72,minSize:1},height:{colored:{min:1,max:3},neutral:{min:.5}},animation:{riseDuration:1.2},camera:{rotationStep:Math.PI/2,animationDuration:.4}};class w extends W{constructor(t,h,i){super(t),this.isoScene=h,this.gridX=i.x,this.gridY=i.y,this.gridW=i.w,this.gridD=i.d,this.targetHeight=i.h,this.targetBaseZ=i.baseZ||0,this.baseColor=i.color,this.currentBaseZ=this.targetBaseZ,this.currentHeight=0,this.totalTime=0,this.animDelay=i.delay||0,this.animProgress=0,this.animCompleted=!1,this.topColor=i.color,this.leftColor=this.shadeColor(i.color,-25),this.rightColor=this.shadeColor(i.color,-45)}get isoDepth(){const t=this.isoScene,h=t.camera?t.camera.angle:0,i=Math.cos(h),n=Math.sin(h),s=[{x:this.gridX,y:this.gridY},{x:this.gridX+this.gridW,y:this.gridY},{x:this.gridX,y:this.gridY+this.gridD},{x:this.gridX+this.gridW,y:this.gridY+this.gridD}];let a=1/0,d=-1/0;for(const l of s){const e=l.x*i-l.y*n,y=l.x*n+l.y*i,f=e+y;f<a&&(a=f),f>d&&(d=f)}const c=(a+d)/2,g=t.tileWidth||38,r=(this.currentBaseZ+this.currentHeight)/g;return c+r*2}shadeColor(t,h){const i=parseInt(t.replace("#",""),16),n=Math.round(2.55*h),s=Math.max(0,Math.min(255,(i>>16)+n)),a=Math.max(0,Math.min(255,(i>>8&255)+n)),d=Math.max(0,Math.min(255,(i&255)+n));return`#${(16777216+s*65536+a*256+d).toString(16).slice(1)}`}update(t){if(this.animCompleted||(this.totalTime+=t,this.totalTime<this.animDelay))return;const h=this.totalTime-this.animDelay,i=u.animation.riseDuration;this.animProgress=Math.min(h/i,1);const n=E.easeOutQuad(this.animProgress);this.currentHeight=n*this.targetHeight,this.animProgress>=1&&(this.currentHeight=this.targetHeight,this.animCompleted=!0)}render(){if(this.totalTime<this.animDelay||this.currentHeight<.5)return;const t=this.isoScene;t.camera&&t.camera.angle;const h=this.currentHeight,i=this.currentBaseZ+h,n=this.currentBaseZ,s=t.toIsometric(this.gridX,this.gridY,i),a=t.toIsometric(this.gridX+this.gridW,this.gridY,i),d=t.toIsometric(this.gridX+this.gridW,this.gridY+this.gridD,i),c=t.toIsometric(this.gridX,this.gridY+this.gridD,i),g=t.toIsometric(this.gridX,this.gridY,n),r=t.toIsometric(this.gridX+this.gridW,this.gridY,n),l=t.toIsometric(this.gridX+this.gridW,this.gridY+this.gridD,n),e=t.toIsometric(this.gridX,this.gridY+this.gridD,n),y=[{verts:[s,a,r,g]},{verts:[a,d,l,r]},{verts:[d,c,e,l]},{verts:[c,s,g,e]}];for(const o of y){const m=o.verts.reduce((v,S)=>v+S.y,0)/4,p=o.verts.reduce((v,S)=>v+S.x,0)/4;o.screenY=m,o.screenX=p}y.sort((o,m)=>o.screenY-m.screenY);const f=[...y].sort((o,m)=>o.screenX-m.screenX);f[0].color=this.leftColor,f[1].color=this.shadeColor(this.baseColor,-30),f[2].color=this.shadeColor(this.baseColor,-35),f[3].color=this.rightColor,M.useCtx(o=>{o.strokeStyle=u.colors.line,o.lineWidth=2;for(const m of y){o.beginPath(),o.moveTo(m.verts[0].x,m.verts[0].y);for(let p=1;p<m.verts.length;p++)o.lineTo(m.verts[p].x,m.verts[p].y);o.closePath(),o.fillStyle=m.color,o.fill(),o.stroke()}o.beginPath(),o.moveTo(s.x,s.y),o.lineTo(a.x,a.y),o.lineTo(d.x,d.y),o.lineTo(c.x,c.y),o.closePath(),o.fillStyle=this.topColor,o.fill(),o.stroke()})}}class T extends b{constructor(t){super(t),this.backgroundColor=u.background}init(){super.init(),M.init(this.ctx);const t=Math.min(this.width,this.height);this.tileWidth=Math.round(t*u.iso.tileRatio),this.tileHeight=Math.round(this.tileWidth/2),this.isoCamera=new D({rotationStep:u.camera.rotationStep,animationDuration:u.camera.animationDuration,easing:"easeOutCubic"}),this.isoScene=new Y(this,{x:this.width/2,y:this.height/2,tileWidth:this.tileWidth,tileHeight:this.tileHeight,gridSize:u.iso.gridSize,elevationScale:u.iso.elevationScale,depthSort:!0,camera:this.isoCamera}),this.pipeline.add(this.isoScene),this.generateComposition(),this.wasSwipe=!1,this.events.on(C.Q,()=>this.isoCamera.rotateLeft()),this.events.on(C.E,()=>this.isoCamera.rotateRight()),this.setupTouchControls()}setupTouchControls(){let t=0,h=!1,i=!1;const n=10;this.canvas.addEventListener("touchstart",s=>{const a=s.touches[0];t=a.clientX,a.clientY,i=!1},{passive:!0}),this.canvas.addEventListener("touchend",s=>{const d=s.changedTouches[0].clientX-t;Math.abs(d)>n?(d>0?this.isoCamera.rotateRight():this.isoCamera.rotateLeft(),i=!0):this.regenerate()},{passive:!0}),this.canvas.addEventListener("mousedown",s=>{t=s.clientX,s.clientY,h=!0,i=!1}),this.canvas.addEventListener("mousemove",s=>{if(h){const a=s.clientX-t;Math.abs(a)>n&&(i=!0)}}),this.canvas.addEventListener("mouseup",s=>{if(h){const a=s.clientX-t;Math.abs(a)>n&&(a>0?this.isoCamera.rotateRight():this.isoCamera.rotateLeft(),i=!0),h=!1}}),this.canvas.addEventListener("click",s=>{i||this.regenerate(),i=!1}),this.canvas.addEventListener("mouseleave",()=>{h=!1})}subdivide(){const t=u.iso.gridSize,{step:h,splitProbability:i,minSize:n}=u.subdivision;let s=[{x:-t,y:-t,w:t*2,d:t*2}];const a=[];for(let c=-t;c<=t;c+=h)a.push(c);const d=c=>{const{splitX:g,splitY:r}=c;for(let l=s.length-1;l>=0;l--){const e=s[l];g!==void 0&&g>e.x+n&&g<e.x+e.w-n&&Math.random()<i&&(s.splice(l,1),s.push({x:e.x,y:e.y,w:g-e.x,d:e.d},{x:g,y:e.y,w:e.w-(g-e.x),d:e.d})),r!==void 0&&r>e.y+n&&r<e.y+e.d-n&&Math.random()<i&&(s.splice(l,1),s.push({x:e.x,y:e.y,w:e.w,d:r-e.y},{x:e.x,y:r,w:e.w,d:e.d-(r-e.y)}))}};for(const c of a)d({splitY:c}),d({splitX:c});return s}generateComposition(){const t=this.subdivide(),{colors:h,height:i}=u,n=u.iso.gridSize*Math.SQRT2,s=.5,a=s+.3,d=i.neutral.min*this.tileWidth;t.forEach(r=>{const l=r.x+r.w/2,e=r.y+r.d/2,o=Math.sqrt(l*l+e*e)/n*s+Math.random()*.1,m=new w(this,this.isoScene,{x:r.x,y:r.y,w:r.w,d:r.d,h:d,baseZ:0,color:h.neutral,delay:o});this.isoScene.add(m)});const c=new Set,g=Math.floor(t.length*.4);for(;c.size<g&&c.size<t.length;)c.add(Math.floor(Math.random()*t.length));t.forEach((r,l)=>{if(!c.has(l))return;const e=r.x+r.w/2,y=r.y+r.d/2,o=Math.sqrt(e*e+y*y)/n,m=a+o*.5+Math.random()*.1,p=h.primary[Math.floor(Math.random()*h.primary.length)],S=(i.colored.min+Math.random()*(i.colored.max-i.colored.min))*this.tileWidth,X=new w(this,this.isoScene,{x:r.x,y:r.y,w:r.w,d:r.d,h:S,baseZ:d,color:p,delay:m});this.isoScene.add(X)})}regenerate(){this.isoScene.clear(),this.generateComposition()}onResize(){this.isoScene&&(this.isoScene.x=this.width/2,this.isoScene.y=this.height/2)}update(t){super.update(t),this.isoCamera.update(t)}}function H(x){const t=new T(x);return t.start(),{stop:()=>t.stop(),game:t}}export{H as default};
