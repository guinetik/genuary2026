import{G as D,i as v,o as c,E as u,P as p,u as E,m as _,v as P,w as f,A as X,x as O,y as B,D as A}from"./gcanvas.es-CMQjSjBY.js";function Y(n,t={}){const{maxDistance:e=50,rate:s=.01,falloff:i=1,temperatureKey:o="temperature",filter:h=null}=t,r=n.length,b=e*e;for(let l=0;l<r;l++){const d=n[l];if(!(h&&!h(d))){d.custom[o]===void 0&&(d.custom[o]=.5);for(let m=l+1;m<r;m++){const g=n[m];if(h&&!h(g))continue;g.custom[o]===void 0&&(g.custom[o]=.5);const y=d.x-g.x,S=d.y-g.y,x=y*y+S*S;if(x>=b||x<1e-4)continue;const T=Math.sqrt(x),w=B(d.custom[o],g.custom[o],T,e,s,i);d.custom[o]=Math.max(0,Math.min(1,d.custom[o]+w)),g.custom[o]=Math.max(0,Math.min(1,g.custom[o]-w))}}}}class W extends A{constructor(t,e,s={}){super(s),this.radiusX=t,this.radiusY=e,this.width=t*2,this.height=e*2}draw(){super.draw(),this.color&&p.shapes.fillEllipse(0,0,this.radiusX,this.radiusY,0,this.color),this.stroke&&p.shapes.strokeEllipse(0,0,this.radiusX,this.radiusY,0,this.stroke,this.lineWidth)}}class M extends A{constructor(t={}){super(t),this.baseWidth=t.baseWidth||8,this.height=t.height||18,this.flip=t.flip||!1}draw(){super.draw();const t=this.baseWidth/2,e=this.height,s=this.flip?[{x:-t,y:0},{x:0,y:-e},{x:t,y:0}]:[{x:-t,y:0},{x:0,y:-e},{x:t,y:0}];p.shapes.polygon(s,this.color,this.stroke,this.lineWidth)}}class k extends _{constructor(t,e={}){super(t,e),this.size=e.size||24,this.eyeAngle=0,this.mouthOpen=0,this.puff=1,this.spitEffect={active:!1,direction:0,timer:0},this._buildShapes()}_buildShapes(){this.body=new P({x:0,y:0}),this.head=new f(this.size,{color:"#9b59b6"}),this.body.add(this.head),this.leftHorn=new M({x:-12,y:-14,baseWidth:8,height:18,color:"#6c3483"}),this.rightHorn=new M({x:12,y:-14,baseWidth:8,height:18,flip:!0,color:"#6c3483"}),this.body.add(this.leftHorn),this.body.add(this.rightHorn);const t=-4,e=8;this.leftEyeWhite=new f(6,{x:-e,y:t,color:"#fff"}),this.rightEyeWhite=new f(6,{x:e,y:t,color:"#fff"}),this.body.add(this.leftEyeWhite),this.body.add(this.rightEyeWhite),this.leftPupil=new f(3,{x:-e,y:t,color:"#000"}),this.rightPupil=new f(3,{x:e,y:t,color:"#000"}),this.body.add(this.leftPupil),this.body.add(this.rightPupil),this.closedMouth=new X(8,.2,Math.PI-.2,{y:10,stroke:"rgba(0, 0, 0, 0.8)",lineWidth:3}),this.openMouth=new W(5,5,{y:12,color:"rgba(40, 10, 40, 0.9)",stroke:"rgba(0, 0, 0, 0.8)",lineWidth:3}),this.body.add(this.closedMouth),this.currentMouth="closed"}setEyeAngle(t){this.eyeAngle=t;const e=8,s=t*10;this.leftPupil.x=-e+s,this.rightPupil.x=e+s}setMouthOpen(t){if(this.mouthOpen=t,t>.1&&this.currentMouth==="closed"?(this.body.remove(this.closedMouth),this.body.add(this.openMouth),this.currentMouth="open"):t<=.1&&this.currentMouth==="open"&&(this.body.remove(this.openMouth),this.body.add(this.closedMouth),this.currentMouth="closed"),this.currentMouth==="open"){const e=3+t*4,s=2+t*6;this.openMouth.radiusX=e,this.openMouth.radiusY=s}}startSpitEffect(t){this.spitEffect.active=!0,this.spitEffect.direction=t,this.spitEffect.timer=.2}update(t){super.update(t),this.spitEffect.active&&(this.spitEffect.timer-=t,this.spitEffect.timer<=0&&(this.spitEffect.active=!1))}draw(){super.draw(),p.save(),p.ctx.scale(this.puff,this.puff),this.body.render(),p.restore(),this.spitEffect.active&&this._drawSpitLines()}_drawSpitLines(){const t=this.spitEffect.direction,e=10,s=this.spitEffect.timer/.2,i=p.ctx;i.strokeStyle=`rgba(255, 255, 255, ${s*.9})`,i.lineWidth=3,i.lineCap="round";for(let o=0;o<3;o++){const h=(o-1)*6,r=20+o*8;i.beginPath(),i.moveTo(t*12,e+h*.3),i.lineTo(t*(12+r),e+h),i.stroke()}}}class C extends _{constructor(t,e={}){super(t,e),this.text=e.text||"...",this.targetX=e.targetX||0,this.targetY=e.targetY||0,this.alpha=0,this._buildShapes()}_buildShapes(){this.cloud=new O(70,{color:"rgba(255, 255, 255, 0.95)"}),this.trailCircles=[new f(10,{color:"rgba(255, 255, 255, 0.9)"}),new f(7,{color:"rgba(255, 255, 255, 0.85)"}),new f(4,{color:"rgba(255, 255, 255, 0.8)"})]}draw(){if(super.draw(),this.alpha<=0)return;const t=p.ctx;t.globalAlpha=this.alpha;const e=this.targetX-this.x,s=this.targetY-this.y;for(let i=0;i<this.trailCircles.length;i++){const o=(i+1)/(this.trailCircles.length+1),h=e*o*.6,r=s*o*.6+30;t.save(),t.translate(h,r),this.trailCircles[i].render(),t.restore()}this.cloud.render(),t.fillStyle="#333",t.font="bold 10px 'Fira Code', monospace",t.textAlign="center",t.textBaseline="middle",t.fillText(this.text,0,0),t.globalAlpha=1}}const a={particleSize:20,baseParticles:200,baseArea:1920*1080,minParticles:100,maxParticles:300,gravity:0,container:{marginX:0,marginY:0},wall:{width:8},heatTransfer:{maxDistance:36,rateEntropy:.015,rateSorting:.002,falloff:1},demon:{tempThreshold:.5,detectionRange:600},phases:{entropyDuration:10,exhaustedDuration:4,departureDuration:2}};class H extends D{constructor(t){super(t),this.backgroundColor=null,this.demonArrived=!1,this.visuals={leftBgAlpha:0,rightBgAlpha:0,wallProgress:0},this.spitDirection=0,this.gobbleFromDirection=0,this.gobbleTarget=null,this.gobbleStartX=0,this.gobbleStartY=0,this.gobbleProgress=0,this.gobbleDuration=.3,this.gobbleStateTimer=0,this.phaseTimer=0,this.phaseState=new v({initial:"entropy",context:this,states:{entropy:{enter:()=>this._enterEntropy(),update:e=>this._updateEntropy(e)},arrival:{enter:()=>this._enterArrival(),update:e=>this._updateArrival(e)},sorting:{enter:()=>this._enterSorting(),update:e=>this._updateSorting(e)},exhausted:{enter:()=>this._enterExhausted(),update:e=>this._updateExhausted(e)},departure:{enter:()=>this._enterDeparture(),update:e=>this._updateDeparture(e)}}}),this.gobbleState=new v({initial:"idle",context:this,states:{idle:{enter:()=>{this.gobbleTarget=null,this.gobbleProgress=0,this.gobbleStateTimer=.15,this.demon&&this.demon.setMouthOpen(0)},update:e=>this._idleUpdate(e)},gobbling:{enter:()=>{const e=this.gobbleStartX-this.wallX,s=this.gobbleStartY-(this.bounds.y+this.bounds.h/2),i=Math.sqrt(e*e+s*s),o=.08,h=.25,r=a.demon.detectionRange;this.gobbleDuration=o+i/r*(h-o),this.demon&&c.to(this.demon,{puff:1.4},this.gobbleDuration,u.easeOutQuad),this.gobbleStateTimer=this.gobbleDuration},update:e=>this._gobblingUpdate(e)},holding:{enter:()=>{this.gobbleProgress=1,this.demon&&this.demon.setMouthOpen(0),this.gobbleStateTimer=.25},update:e=>this._holdingUpdate(e)},spitting:{enter:()=>{this._doSpit(),this.demon&&c.to(this.demon,{puff:1},.1,u.easeOutQuad),this.gobbleStateTimer=.2},update:e=>this._spittingUpdate(e)}}})}init(){super.init(),p.init(this.ctx),console.log("[Day16] Initializing Maxwell's Demon..."),this._updateBounds(),this.wallX=this.bounds.x+this.bounds.w/2;const e=this.width*this.height/a.baseArea;this.particleCount=Math.floor(Math.min(a.maxParticles,Math.max(a.minParticles,a.baseParticles*e))),console.log(`[Day16] Canvas: ${this.width}x${this.height}, particles: ${this.particleCount}`),this.fluid=new E(this,{maxParticles:this.particleCount,particleSize:a.particleSize,width:this.bounds.w,height:this.bounds.h,bounds:this.bounds,physics:"gas",debug:!1,gravity:a.gravity,heat:{enabled:!1},particleColor:{r:255,g:255,b:255,a:.9}}),this.fluid.spawn(this.particleCount),this._initParticles(),this.pipeline.add(this.fluid),this.demon=new k(this,{x:this.wallX,y:this.bounds.y+this.bounds.h/2,size:24,visible:!1}),this.pipeline.add(this.demon),this.thoughtBubble=new C(this,{x:this.wallX,y:this.bounds.y+this.bounds.h/2-100,targetX:this.wallX,targetY:this.bounds.y+this.bounds.h/2-30,text:""}),this.pipeline.add(this.thoughtBubble),this._enterEntropy(),console.log("[Day16] Init complete, starting entropy phase")}_initParticles(){for(const t of this.fluid.particles)t.custom.temperature=.1+Math.random()*.8,t.custom.sorted=!1}_updateBounds(){const{marginX:t,marginY:e}=a.container;this.bounds={x:t,y:e,w:this.width-t*2,h:this.height-e*2}}update(t){c.updateAll(t),this.phaseState.update(t),super.update(t);const e=this.demonArrived?a.heatTransfer.rateSorting:a.heatTransfer.rateEntropy;Y(this.fluid.particles,{maxDistance:a.heatTransfer.maxDistance,rate:e,falloff:a.heatTransfer.falloff,filter:s=>!s.custom.sorted&&s!==this.gobbleTarget}),this._lockSortedTemperatures(),this._colorByTemperature(),this._enforceTemperatureSpeeds()}_enterEntropy(){console.log("[Day16] Entering ENTROPY phase"),this.phaseTimer=0,this.demonArrived=!1,this.thoughtBubble&&(this.thoughtBubble.alpha=0)}_updateEntropy(t){this.phaseTimer+=t,this.phaseTimer>=a.phases.entropyDuration&&this.phaseState.setState("arrival")}_enterArrival(){this.phaseTimer=0,this.demonArrived=!0,this.demon&&(this.demon.visible=!0,this.demon.scaleX=0,this.demon.scaleY=0,c.to(this.demon,{scaleX:1,scaleY:1},.5,u.easeOutBack)),c.to(this.visuals,{leftBgAlpha:.3},.4,u.easeOutQuad,{delay:.3}),c.to(this.visuals,{rightBgAlpha:.3},.4,u.easeOutQuad,{delay:.5}),c.to(this.visuals,{wallProgress:1},.6,u.easeInOutQuad,{delay:.7})}_updateArrival(t){this.phaseTimer+=t,this.visuals.wallProgress>=1&&this.phaseState.setState("sorting")}_enterSorting(){this.phaseTimer=0,this.gobbleState.setState("idle")}_updateSorting(t){this._enforceWall(),this.gobbleState.update(t),this.gobbleState.currentState==="idle"&&!this.gobbleTarget&&this._checkAllSorted()&&(console.log("[Day16] All sorted! Transitioning to exhausted"),this.phaseState.setState("exhausted"))}_enterExhausted(){console.log("[Day16] EXHAUSTED - showing bubble"),this.phaseTimer=0,this.demon&&(this.demon.setEyeAngle(0),this.demon.setMouthOpen(0)),this.thoughtBubble&&(console.log("[Day16] Setting bubble text and alpha"),this.thoughtBubble.text="YOU ARE ALL FREE NOW",this.thoughtBubble.alpha=1)}_updateExhausted(t){this.phaseTimer+=t,this._enforceWall(),this.phaseTimer>=a.phases.exhaustedDuration&&this.phaseState.setState("departure")}_enterDeparture(){this.phaseTimer=0,this.thoughtBubble&&c.to(this.thoughtBubble,{alpha:0},.3,u.easeOutQuad),this.demon&&c.to(this.demon,{scaleX:0,scaleY:0},.5,u.easeInBack,{delay:.3,onComplete:()=>{this.demon.visible=!1}}),c.to(this.visuals,{leftBgAlpha:0},.8,u.easeOutQuad,{delay:.5}),c.to(this.visuals,{rightBgAlpha:0},.8,u.easeOutQuad,{delay:.5}),c.to(this.visuals,{wallProgress:0},.8,u.easeInQuad,{delay:.5})}_updateDeparture(t){this.phaseTimer+=t,this.phaseTimer>=a.phases.departureDuration&&(console.log("[Day16] Departure complete, returning to entropy"),this._randomizeParticleVelocities(),this.phaseState.setState("entropy"))}_checkAllSorted(){for(const t of this.fluid.particles)if(!t.custom.sorted)return!1;return!0}_randomizeParticleVelocities(){for(const t of this.fluid.particles){const e=50+Math.random()*150,s=Math.random()*Math.PI*2;t.vx=Math.cos(s)*e,t.vy=Math.sin(s)*e,t.custom.sorted=!1,t.custom.temperature=.1+Math.random()*.8}}_enforceWall(){const t=this.wallX,e=a.wall.width/2;for(const s of this.fluid.particles){if(s===this.gobbleTarget)continue;const i=s.x-t;Math.abs(i)<e+a.particleSize/2&&(i>0?(s.x=t+e+a.particleSize/2,s.vx=Math.abs(s.vx)*.8):(s.x=t-e-a.particleSize/2,s.vx=-Math.abs(s.vx)*.8))}}_idleUpdate(t){if(this.gobbleStateTimer-=t,this.gobbleStateTimer>0){this.demon&&(this.demon.eyeAngle*=.95,this.demon.setEyeAngle(this.demon.eyeAngle));return}const{detectionRange:e,tempThreshold:s}=a.demon;let i=null,o=1/0,h=!1,r=null,b=!1;for(const l of this.fluid.particles){if(l.custom.sorted)continue;const d=l.x-this.wallX,m=Math.abs(d),y=(l.custom.temperature??.5)>s;if(r||(r=l,b=y),m>e)continue;const S=d>0,x=d<0;(y&&S||!y&&x)&&m<o&&(o=m,i=l,h=y)}if(!i&&r&&(i=r,h=b),i){this.gobbleTarget=i,i.custom.isHot=h;const l=i.x>this.wallX;this.gobbleFromDirection=l?1:-1,this.spitDirection=h?-1:1,this.gobbleStartX=i.x,this.gobbleStartY=i.y,this.demon&&this.demon.setEyeAngle(this.gobbleFromDirection*.5),this.gobbleState.setState("gobbling")}this.demon&&(this.demon.eyeAngle*=.95,this.demon.setEyeAngle(this.demon.eyeAngle))}_gobblingUpdate(t){this.gobbleStateTimer-=t;const e=Math.min(1,Math.max(0,1-this.gobbleStateTimer/this.gobbleDuration));if(this.gobbleProgress=e,this.demon&&this.demon.setMouthOpen(e*e),this.gobbleTarget){const s=this.bounds.y+this.bounds.h/2,i=this.wallX,o=s+14,h=i-this.gobbleTarget.x,r=o-this.gobbleTarget.y,b=Math.sqrt(h*h+r*r);if(b>5){const l=1500+e*2500;this.gobbleTarget.vx=h/b*l,this.gobbleTarget.vy=r/b*l}else{this.gobbleTarget.x=i,this.gobbleTarget.y=o,this.gobbleTarget.vx=0,this.gobbleTarget.vy=0,this.gobbleProgress=1,this.gobbleState.setState("holding");return}}}_holdingUpdate(t){this.gobbleStateTimer-=t;const s=1-this.gobbleStateTimer/.5;this.gobbleTarget&&(this.gobbleTarget.x=-1e3,this.gobbleTarget.y=-1e3,this.gobbleTarget.vx=0,this.gobbleTarget.vy=0),this.demon&&(s<.4?this.demon.setEyeAngle(this.gobbleFromDirection*.5):s<.7?(this.demon.eyeAngle*=.7,this.demon.setEyeAngle(this.demon.eyeAngle)):this.demon.setEyeAngle(this.spitDirection*.5)),this.gobbleStateTimer<=0&&this.gobbleState.setState("spitting")}_doSpit(){if(!this.gobbleTarget)return;const t=this.bounds.y+this.bounds.h/2;this.gobbleTarget.x=this.wallX,this.gobbleTarget.y=t+14;const e=450+Math.random()*150,s=(Math.random()-.5)*.3;this.gobbleTarget.vx=this.spitDirection*e,this.gobbleTarget.vy=s*e,this.gobbleTarget.custom.sorted=!0,this.gobbleTarget.custom.lockedTemp=this.gobbleTarget.custom.isHot?.9:.1,this.gobbleTarget.custom.temperature=this.gobbleTarget.custom.lockedTemp,this.demon&&(this.demon.startSpitEffect(this.spitDirection),this.demon.setMouthOpen(1),this.demon.setEyeAngle(this.spitDirection*.5))}_spittingUpdate(t){if(this.gobbleStateTimer-=t,this.demon){const e=this.gobbleStateTimer/.2;this.demon.setMouthOpen(e)}this.gobbleStateTimer<=0&&this.gobbleState.setState("idle")}_lockSortedTemperatures(){for(const t of this.fluid.particles)t.custom.sorted&&t.custom.lockedTemp!==void 0&&(t.custom.temperature=t.custom.lockedTemp)}_enforceTemperatureSpeeds(){for(const s of this.fluid.particles){if(s===this.gobbleTarget||!s.custom.sorted)continue;const i=Math.sqrt(s.vx*s.vx+s.vy*s.vy);if(i<1)continue;const h=(s.custom.isHot?150:50)/i;s.vx+=(s.vx*h-s.vx)*.05,s.vy+=(s.vy*h-s.vy)*.05}}_colorByTemperature(){for(const t of this.fluid.particles){const e=t.custom.temperature;t.color.r=Math.floor(255*e),t.color.g=Math.floor(80*(1-Math.abs(e-.5)*2)),t.color.b=Math.floor(255*(1-e))}}render(){const t=this.ctx;t.fillStyle="#000",t.fillRect(0,0,this.width,this.height);const{leftBgAlpha:e,rightBgAlpha:s,wallProgress:i}=this.visuals;if(e>0&&(t.fillStyle=`rgba(60, 20, 20, ${e})`,t.fillRect(this.bounds.x,this.bounds.y,this.bounds.w/2,this.bounds.h)),s>0&&(t.fillStyle=`rgba(20, 20, 60, ${s})`,t.fillRect(this.wallX,this.bounds.y,this.bounds.w/2,this.bounds.h)),i>0){t.fillStyle="#666";const o=this.bounds.h*i;t.fillRect(this.wallX-a.wall.width/2,this.bounds.y,a.wall.width,o)}this.pipeline.render(t)}}function R(n){console.log("[Day16] Module loaded, creating game...");const t=new H(n);function e(){n.width>0&&n.height>0?(console.log("[Day16] Canvas ready, starting game"),t.start()):(console.log("[Day16] Canvas not ready, retrying..."),requestAnimationFrame(e))}return e(),{stop:()=>t.stop(),game:t,handlesResize:!0}}export{R as default};
