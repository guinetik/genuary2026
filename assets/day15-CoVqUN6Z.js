import{G as st,P as et,C as it,s as ot,u as nt,E as W}from"./gcanvas.es-CkPclmv-.js";const a={bhRadiusRatio:.045,bhMass:1,starCountBase:225,starCountPerMegapixel:800,starFieldRadius:1200,lensRadiusMultiplier:8,lensStrengthMultiplier:2.5,lensFalloff:.007,occlusionRadius:2.6,diskInnerRadius:1.8,diskOuterRadius:8,diskParticles:3e3,diskThickness:.15,baseOrbitalSpeed:.6,colorHot:{r:255,g:250,b:220},colorMid:{r:255,g:160,b:50},colorCool:{r:180,g:40,b:20},particleSizeMin:.5,particleSizeMax:1,particleScale:.0025,perspective:800,initialTilt:.4},Z=[{size:1.5,brightness:1},{size:1,brightness:.7},{size:.6,brightness:.5}];class at extends st{constructor(t){super(t),this.backgroundColor="#000"}init(){super.init(),et.init(this.ctx);const t=Math.min(this.width,this.height),h=this.width*this.height/1e6;this.baseScale=t,this.bhRadius=t*a.bhRadiusRatio,this.starCount=Math.floor(a.starCountBase+a.starCountPerMegapixel*h),this.lensEffectRadius=this.bhRadius*a.lensRadiusMultiplier,this.lensStrength=this.bhRadius*a.lensStrengthMultiplier;const c=Math.max(1,t/600);this.camera=new it({perspective:a.perspective*c,rotationX:a.initialTilt,rotationY:0,sensitivity:.004,inertia:!0,friction:.92,clampX:!1,autoRotate:!0,autoRotateSpeed:.08,autoRotateAxis:"y"}),this.camera.enableMouseControl(this.canvas),this.time=0,this.lensingStrength=1,this.mouseX=this.width/2,this.mouseY=this.height/2,this.mouseDownPos=null,this.isDragging=!1,this.initStarfield(),this.initAccretionDisk(),this.initFallingMatter(),this.canvas.addEventListener("mousemove",e=>{const s=this.canvas.getBoundingClientRect();this.mouseX=e.clientX-s.left,this.mouseY=e.clientY-s.top}),this.canvas.addEventListener("mousedown",e=>{const s=this.canvas.getBoundingClientRect();this.mouseDownPos={x:e.clientX-s.left,y:e.clientY-s.top},this.isDragging=!1}),this.canvas.addEventListener("mousemove",e=>{if(this.mouseDownPos){const s=this.canvas.getBoundingClientRect(),n=e.clientX-s.left-this.mouseDownPos.x,r=e.clientY-s.top-this.mouseDownPos.y;Math.sqrt(n*n+r*r)>5&&(this.isDragging=!0)}}),this.canvas.addEventListener("mouseup",e=>{!this.isDragging&&this.mouseDownPos&&this.spawnMatterAtMouse(),this.mouseDownPos=null,this.isDragging=!1}),this.canvas.addEventListener("touchstart",e=>{if(e.touches.length===1){const s=this.canvas.getBoundingClientRect(),n=e.touches[0];this.mouseX=n.clientX-s.left,this.mouseY=n.clientY-s.top,this.mouseDownPos={x:this.mouseX,y:this.mouseY},this.isDragging=!1}}),this.canvas.addEventListener("touchmove",e=>{if(e.touches.length===1&&this.mouseDownPos){const s=this.canvas.getBoundingClientRect(),n=e.touches[0],r=n.clientX-s.left-this.mouseDownPos.x,i=n.clientY-s.top-this.mouseDownPos.y;Math.sqrt(r*r+i*i)>10&&(this.isDragging=!0)}}),this.canvas.addEventListener("touchend",e=>{!this.isDragging&&this.mouseDownPos&&this.spawnMatterAtMouse(),this.mouseDownPos=null,this.isDragging=!1})}initStarfield(){this.stars=[];for(let t=0;t<this.starCount;t++){const l=Math.random()*Math.PI*2,h=Math.acos(2*Math.random()-1),c=a.starFieldRadius*(.5+Math.random()*.5),e=Z[Math.floor(Math.random()*Z.length)];this.stars.push({x:c*Math.sin(h)*Math.cos(l),y:c*Math.sin(h)*Math.sin(l),z:c*Math.cos(h),type:e,twinkleSpeed:1+Math.random()*2,twinklePhase:Math.random()*Math.PI*2})}}initAccretionDisk(){this.diskParticles=[];const t=this.bhRadius*a.diskInnerRadius,l=this.bhRadius*a.diskOuterRadius;for(let h=0;h<a.diskParticles;h++){const c=Math.pow(Math.random(),.5),e=t+(l-t)*c,s=Math.random()*Math.PI*2,n=ot(e,a.bhMass,a.baseOrbitalSpeed,l),r=(Math.random()-.5)*this.bhRadius*a.diskThickness;this.diskParticles.push({angle:s,distance:e,yOffset:r,speed:n,size:a.particleSizeMin+Math.random()*(a.particleSizeMax-a.particleSizeMin),baseColor:this.getHeatColor(e,t,l)})}}getHeatColor(t,l,h){const c=Math.max(0,Math.min(1,(t-l)/(h-l)));let e,s,n;if(c<.5){const r=c*2;e=a.colorHot.r+(a.colorMid.r-a.colorHot.r)*r,s=a.colorHot.g+(a.colorMid.g-a.colorHot.g)*r,n=a.colorHot.b+(a.colorMid.b-a.colorHot.b)*r}else{const r=(c-.5)*2;e=a.colorMid.r+(a.colorCool.r-a.colorMid.r)*r,s=a.colorMid.g+(a.colorCool.g-a.colorMid.g)*r,n=a.colorMid.b+(a.colorCool.b-a.colorMid.b)*r}return{r:Math.round(e),g:Math.round(s),b:Math.round(n)}}initFallingMatter(){this.fallingParticles=[]}spawnMatterAtMouse(){const t=this.width/2,l=this.height/2,h=this.mouseX-t,c=this.mouseY-l,e=350,s=this.camera.perspective/(this.camera.perspective-e);let n=h/s,r=c/s,i=-e;const u=Math.cos(-this.camera.rotationX),d=Math.sin(-this.camera.rotationX);let f=r*u-i*d,g=r*d+i*u;const p=Math.cos(-this.camera.rotationY),b=Math.sin(-this.camera.rotationY);let R=n*p-g*b,x=n*b+g*p,S=f;this.fallingParticles.push({x:R,y:S,z:x,vx:0,vy:0,vz:0,size:4+Math.random()*3,age:0,maxAge:20}),this.fallingParticles.length>50&&(this.fallingParticles=this.fallingParticles.slice(-40))}update(t){super.update(t),this.time+=t,this.camera.update(t);for(let e=this.diskParticles.length-1;e>=0;e--){const s=this.diskParticles[e];s.angle+=s.speed*t,s.age!==void 0&&(s.age+=t,s.age>s.maxAge&&this.diskParticles.splice(e,1))}const l=300,h=500,c=this.bhRadius*2;for(let e=this.fallingParticles.length-1;e>=0;e--){const s=this.fallingParticles[e],n=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z);if(n>1){const r=Math.max(0,Math.min(1,n/h)),i=1-W.easeInExpo(r),u=l*(1+i*50),d=-s.x/n,f=-s.y/n,g=-s.z/n;s.vx+=d*u*t,s.vy+=f*u*t,s.vz+=g*u*t,s.vx+=f*u*t*.1,s.vy+=-d*u*t*.1}s.x+=s.vx*t,s.y+=s.vy*t,s.z+=s.vz*t,s.age+=t,(n<c||s.age>s.maxAge)&&this.fallingParticles.splice(e,1)}}render(){const t=this.ctx,l=this.width,h=this.height,c=l/2,e=h/2;t.fillStyle="rgba(0, 0, 0, 0.12)",t.fillRect(0,0,l,h),this.renderStarfield(t,c,e),this.renderFallingMatter(t,c,e),this.renderDisk(t,c,e),this.renderBlackHole(t,c,e)}renderStarfield(t,l,h){const c=this.time,e=this.lensingStrength>0,s=this.lensEffectRadius,n=this.lensStrength*this.lensingStrength,r=this.bhRadius*a.occlusionRadius,i=r*r,u=s*s,d=this.width,f=this.height;for(const g of this.stars){const p=this.camera.project(g.x,g.y,g.z);if(p.scale<=0)continue;let b=p.x,R=p.y;const x=b*b+R*R;if(p.z>0&&e&&x<u){const M=nt(b,R,s,n,a.lensFalloff,5);b=M.x,R=M.y}if(x<i)continue;const S=l+b,w=h+R;if(S<-10||S>d+10||w<-10||w>f+10)continue;const k=.5+.5*Math.sin(c*g.twinkleSpeed+g.twinklePhase);if(k<.1)continue;const P=g.type.size*p.scale*g.type.brightness,X=Math.round(180+g.type.brightness*75);if(t.fillStyle=this._getRgba(X,X,X,k*.8),P<1.5){const M=Math.max(1,P);t.fillRect(S-M*.5,w-M*.5,M,M)}else t.beginPath(),t.arc(S,w,P,0,Math.PI*2),t.fill()}}renderDisk(t,l,h){const c=[],e=Math.cos(this.camera.rotationY),s=Math.sin(this.camera.rotationY),n=Math.cos(this.camera.rotationX),r=Math.sin(this.camera.rotationX),i=Math.abs(r),u=this.camera.rotationY,d=this.bhRadius,f=d*6,g=d*1.8,p=d*3,b=d*5,R=d*2,x=this.lensingStrength>0,S=this.lensingStrength,w=1-i,E=i>.05,k=Math.PI*.5,P=this.camera.perspective;for(const o of this.diskParticles){const C=Math.cos(o.angle),Y=Math.sin(o.angle),z=C*o.distance,m=o.yOffset,A=Y*o.distance;let D=z*e-A*s,y=z*s+A*e,v=m*n-y*r;y=m*r+y*n;const F=D*D,H=v*v,K=F+H,O=Math.sqrt(K),B=y>0;if(x&&O<f){const I=Math.exp(-O/g),J=I*1.2*S,Q=o.angle+u,$=Math.sin(Q)>0;if(O>0){let q=J;!$&&B&&(q*=1-w*.6);const _=(O+g*q)/O;D*=_,v*=_}if(E){const q=D/b,_=Math.max(0,Math.cos(q*k)),tt=B?Math.min(1,y/p):Math.min(1,Math.abs(y)/p),T=R*I*tt*i;B?$?v-=T*_:v+=T*_*.5:v+=T*_*.4}}const L=P/(P+y);if(y<-P+10)continue;const N=D*L,U=v*L,V=1+Math.cos(o.angle+this.camera.rotationY)*.4;let G=1;if(o.age!==void 0){const I=o.age/o.maxAge;G=1-Math.pow(I,2)}c.push({x:N,y:U,z:y,scale:L,color:o.baseColor,doppler:V,alpha:G,size:o.size})}c.sort((o,C)=>C.z-o.z);const X=this.baseScale*a.particleScale,M=[];for(const o of c){const{r:C,g:Y,b:z}=o.color,m=X*o.scale*o.size;if(m<.1)continue;const A=Math.min(255,Math.round(C*o.doppler)),D=Math.min(255,Math.round(Y*o.doppler)),y=Math.min(255,Math.round(z*o.doppler)),v=Math.max(0,Math.min(1,o.alpha*o.doppler*.8)),F=l+o.x,H=h+o.y;t.fillStyle=this._getRgba(A,D,y,v),m<1.5?t.fillRect(F-m*.5,H-m*.5,m,m):(t.beginPath(),t.arc(F,H,m,0,Math.PI*2),t.fill()),o.doppler>1.1&&o.alpha>.5&&M.push({x:F,y:H,size:m*1.5,color:this._getRgba(A,D,y,v*.3)})}if(M.length>0){t.globalCompositeOperation="lighter";for(const o of M)t.fillStyle=o.color,o.size<2?t.fillRect(o.x-o.size,o.y-o.size,o.size*2,o.size*2):(t.beginPath(),t.arc(o.x,o.y,o.size,0,Math.PI*2),t.fill());t.globalCompositeOperation="source-over"}}_getRgba(t,l,h,c){const e=Math.round(c*100),s=t<<24|l<<16|h<<8|e;this._colorCache||(this._colorCache=new Map);let n=this._colorCache.get(s);if(!n&&(n=`rgba(${t},${l},${h},${(e/100).toFixed(2)})`,this._colorCache.set(s,n),this._colorCache.size>1e3)){const r=this._colorCache.keys();for(let i=0;i<500;i++)this._colorCache.delete(r.next().value)}return n}renderFallingMatter(t,l,h){if(!this.fallingParticles||this.fallingParticles.length===0)return;const c=400,e=250,s=[],n=[],r=[];for(const i of this.fallingParticles){const u=this.camera.project(i.x,i.y,i.z);if(!u||u.scale<=0)continue;const d=l+u.x,f=h+u.y;if(d<-50||d>this.width+50||f<-50||f>this.height+50)continue;const g=Math.sqrt(i.x*i.x+i.y*i.y+i.z*i.z),p=Math.min(1,g/c),b=255,R=Math.round(200*p),x=Math.round(150*p*p),w=Math.pow(p,.5)*.9,E=Math.max(1,i.size*u.scale),k=Math.max(0,1-g/e),P=1+W.easeInExpo(k)*15,X=1/(1+k*2),M=-d+l,o=-f+h,C=Math.sqrt(M*M+o*o)||1,Y=Math.atan2(o/C,M/C),z=E*P,m=E*X;n.push({x:d,y:f,angle:Y,w:z*1.5,h:m*2,color:this._getRgba(b,R,x,w*.2)}),s.push({x:d,y:f,angle:Y,w:z,h:m,color:this._getRgba(b,R,x,w)}),P>2&&r.push({x:d,y:f,angle:Y,offsetX:z*.6,w:z*.3,h:m*.5,color:this._getRgba(255,255,255,w*.6)})}if(n.length>0){t.globalCompositeOperation="lighter";for(const i of n)t.fillStyle=i.color,this._drawRotatedEllipse(t,i.x,i.y,i.w,i.h,i.angle);t.globalCompositeOperation="source-over"}for(const i of s)t.fillStyle=i.color,this._drawRotatedEllipse(t,i.x,i.y,i.w,i.h,i.angle);for(const i of r)t.fillStyle=i.color,this._drawRotatedEllipseOffset(t,i.x,i.y,i.w,i.h,i.angle,i.offsetX)}_drawRotatedEllipse(t,l,h,c,e,s){t.beginPath(),t.ellipse(l,h,Math.max(.5,c),Math.max(.5,e),s,0,Math.PI*2),t.fill()}_drawRotatedEllipseOffset(t,l,h,c,e,s,n){const r=l+Math.cos(s)*n,i=h+Math.sin(s)*n;t.beginPath(),t.ellipse(r,i,Math.max(.5,c),Math.max(.5,e),s,0,Math.PI*2),t.fill()}renderBlackHole(t,l,h){}}function lt(j){const t=new at(j);return t.start(),{stop:()=>t.stop(),game:t}}export{lt as default};
